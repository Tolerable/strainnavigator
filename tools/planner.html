<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strain Breeding Planner</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f8f6e9;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #1a3c20, #2d5e32);
            color: white;
            padding: 10px 20px;
            text-align: center;
        }
        
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .sidebar {
            width: 300px;
            background-color: #fff;
            border-right: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .sidebar-header {
            padding: 10px;
            border-bottom: 1px solid #ddd;
            background-color: #f0f0f0;
        }
        
        .search-box {
            display: flex;
            padding: 10px;
            border-bottom: 1px solid #ddd;
        }
        
        .search-box input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px 0 0 4px;
        }
        
        .search-box button {
            padding: 8px 15px;
            background-color: #2d5e32;
            color: white;
            border: none;
            border-radius: 0 4px 4px 0;
            cursor: pointer;
        }
        
        .filter-tabs {
            display: flex;
            overflow-x: auto;
            border-bottom: 1px solid #ddd;
            background-color: #f8f8f8;
        }
        
        .filter-tab {
            padding: 8px 12px;
            cursor: pointer;
            white-space: nowrap;
            font-size: 12px;
            font-weight: 500;
        }
        
        .filter-tab.active {
            background-color: #5d4a7e;
            color: white;
        }
        
        .strain-list {
            flex: 1;
            overflow-y: auto;
        }
        
        .strain-item {
            padding: 10px 15px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .strain-item:hover {
            background-color: #f0f0f0;
        }
        
        .strain-info {
            display: flex;
            flex-direction: column;
        }
        
        .strain-name {
            font-weight: 500;
        }
        
        .strain-type {
            font-size: 12px;
            margin-top: 2px;
            display: flex;
            gap: 5px;
        }
        
        .strain-tag {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            color: white;
            font-weight: 600;
        }
        
        .tag-reg { background-color: #9575cd; }
        .tag-fem { background-color: #f06292; }
        .tag-auto { background-color: #ffb74d; }
        .tag-photo { background-color: #4db6ac; }
        .tag-fast { background-color: #4fc3f7; }
        
        .strain-count {
            background-color: rgba(93, 74, 126, 0.1);
            color: #5d4a7e;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: #2d2d2d;
        }
        
        .canvas-tools {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            display: flex;
            gap: 5px;
        }
        
        .canvas-tool {
            background-color: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 4px;
            padding: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }
        
        .canvas-tool.active {
            background-color: #5d4a7e;
            color: white;
        }
        
        /* Strain nodes and links */
        .breeding-node {
            position: absolute;
            background-color: white;
            border-radius: 6px;
            padding: 10px;
            min-width: 120px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            cursor: grab;
            user-select: none;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 2;
        }
        
        .breeding-node.reg {
            border-left: 5px solid #9575cd;
        }
        
        .breeding-node.fem {
            border-left: 5px solid #f06292;
        }
        
        .breeding-node.auto {
            border-left: 5px solid #ffb74d;
        }
        
        .breeding-node.photo {
            border-left: 5px solid #4db6ac;
        }
        
        .breeding-node.fast {
            border-left: 5px solid #4fc3f7;
        }
        
        .breeding-node.selected {
            box-shadow: 0 0 0 3px #ffeb3b;
        }
        
        .node-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
        }
        
        .node-name {
            font-weight: 600;
            word-break: break-word;
        }
        
        .node-controls {
            display: flex;
            gap: 5px;
        }
        
        .node-control {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            cursor: pointer;
            background-color: rgba(0, 0, 0, 0.1);
            color: #333;
        }
        
        .node-control:hover {
            background-color: rgba(0, 0, 0, 0.2);
        }
        
        .connection-point {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #e0e0e0;
            cursor: pointer;
            margin: 0 auto;
            border: 2px solid white;
        }
        
        .connection-point:hover {
            background-color: #5d4a7e;
        }
        
        .connection-line {
            position: absolute;
            pointer-events: none;
            z-index: 1;
        }
        
        .breeding-result {
            background-color: rgba(237, 231, 246, 0.9);
            border-left: 5px solid #673ab7;
        }
        
        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        
        .modal.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        .modal-content {
            background-color: white;
            border-radius: 8px;
            width: 400px;
            max-width: 90vw;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
        }
        
        .modal-header {
            padding: 15px;
            border-bottom: 1px solid #eee;
            font-weight: 600;
        }
        
        .modal-body {
            padding: 15px;
            max-height: 70vh;
            overflow-y: auto;
        }
        
        .modal-footer {
            padding: 15px;
            border-top: 1px solid #eee;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        .btn {
            padding: 8px 16px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-weight: 500;
        }
        
        .btn-primary {
            background-color: #2d5e32;
            color: white;
        }
        
        .btn-secondary {
            background-color: #f0f0f0;
            color: #333;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        .form-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .help-text {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 300px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body>
    <header>
        <h2>Strain Breeding Planner</h2>
    </header>
    
    <div class="main-container">
        <div class="sidebar">
            <div class="sidebar-header">
                <h3>Strain Collection</h3>
            </div>
            
            <div class="search-box">
                <input type="text" id="search-input" placeholder="Search strains...">
                <button id="search-btn">Search</button>
            </div>
            
            <div class="filter-tabs">
                <div class="filter-tab active" data-filter="all">ALL</div>
                <div class="filter-tab" data-filter="reg">REG</div>
                <div class="filter-tab" data-filter="fem">FEM</div>
                <div class="filter-tab" data-filter="auto">AUTO</div>
                <div class="filter-tab" data-filter="photo">PHOTO</div>
                <div class="filter-tab" data-filter="fast">FAST</div>
            </div>
            
            <div class="strain-list" id="strain-list">
                <!-- Strains will be loaded here -->
                <div class="strain-item">
                    <div class="strain-info">
                        <div class="strain-name">Loading strains...</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="canvas-container" id="breeding-canvas">
            <div class="canvas-tools">
                <button class="canvas-tool" id="new-diagram" title="New Diagram">New</button>
                <button class="canvas-tool" id="save-diagram" title="Save Diagram">Save</button>
                <button class="canvas-tool" id="load-diagram" title="Load Diagram">Load</button>
            </div>
            
            <div class="help-text">
                Click on strains to add them to the diagram. Connect strains by dragging from one connection point to another. Right-click nodes for more options.
            </div>
        </div>
    </div>
    
    <!-- Name Cross Modal -->
    <div class="modal" id="name-cross-modal">
        <div class="modal-content">
            <div class="modal-header">Name Your Cross</div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Default Name</label>
                    <div id="default-cross-name"></div>
                </div>
                <div class="form-group">
                    <label class="form-label">Custom Name (optional)</label>
                    <input type="text" class="form-input" id="custom-cross-name" placeholder="Enter a custom name">
                </div>
                <div class="form-group">
                    <label class="form-label">Type</label>
                    <select class="form-input" id="cross-type">
                        <option value="reg">REG</option>
                        <option value="fem">FEM</option>
                        <option value="auto">AUTO</option>
                        <option value="photo">PHOTO</option>
                        <option value="fast">FAST</option>
                    </select>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="cancel-cross-btn">Cancel</button>
                <button class="btn btn-primary" id="create-cross-btn">Create</button>
            </div>
        </div>
    </div>
    
    <!-- Load Diagram Modal -->
    <div class="modal" id="load-diagram-modal">
        <div class="modal-content">
            <div class="modal-header">Load Breeding Diagram</div>
            <div class="modal-body">
                <div id="saved-diagrams-list">
                    No saved diagrams found.
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="cancel-load-btn">Cancel</button>
                <button class="btn btn-primary" id="confirm-load-btn">Load</button>
            </div>
        </div>
    </div>
    
    <!-- Save Diagram Modal -->
    <div class="modal" id="save-diagram-modal">
        <div class="modal-content">
            <div class="modal-header">Save Breeding Diagram</div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Diagram Name</label>
                    <input type="text" class="form-input" id="diagram-name" placeholder="Enter a name for this diagram">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="cancel-save-btn">Cancel</button>
                <button class="btn btn-primary" id="confirm-save-btn">Save</button>
            </div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Configuration
            const sheetId = '1A7kFjfw6cjmQQOwz-5liWVGgFK0K5lwS8AfIZ_Zthbg';
            
            // DOM Elements
            const strainList = document.getElementById('strain-list');
            const searchInput = document.getElementById('search-input');
            const searchBtn = document.getElementById('search-btn');
            const filterTabs = document.querySelectorAll('.filter-tab');
            const breedingCanvas = document.getElementById('breeding-canvas');
            
            // Button Elements
            const newDiagramBtn = document.getElementById('new-diagram');
            const saveDiagramBtn = document.getElementById('save-diagram');
            const loadDiagramBtn = document.getElementById('load-diagram');
            
            // Modal Elements
            const nameCrossModal = document.getElementById('name-cross-modal');
            const defaultCrossName = document.getElementById('default-cross-name');
            const customCrossName = document.getElementById('custom-cross-name');
            const crossType = document.getElementById('cross-type');
            const cancelCrossBtn = document.getElementById('cancel-cross-btn');
            const createCrossBtn = document.getElementById('create-cross-btn');
            
            const loadDiagramModal = document.getElementById('load-diagram-modal');
            const savedDiagramsList = document.getElementById('saved-diagrams-list');
            const cancelLoadBtn = document.getElementById('cancel-load-btn');
            const confirmLoadBtn = document.getElementById('confirm-load-btn');
            
            const saveDiagramModal = document.getElementById('save-diagram-modal');
            const diagramNameInput = document.getElementById('diagram-name');
            const cancelSaveBtn = document.getElementById('cancel-save-btn');
            const confirmSaveBtn = document.getElementById('confirm-save-btn');
            
            // State
            let allStrains = [];
            let nodes = [];
            let connections = [];
            let selectedNode = null;
            let connecting = false;
            let connectingFrom = null;
            let tempLine = null;
            let nodeCounter = 0;
            let selectedDiagram = null;
            let pendingCrossData = null;
            
            // Initialize
            loadStrains();
            setupEventListeners();
            
            // Functions
            function loadStrains() {
                strainList.innerHTML = '<div class="strain-item"><div class="strain-info"><div class="strain-name">Loading strains...</div></div></div>';
                
                const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv`;
                
                fetch(csvUrl)
                    .then(response => {
                        if (!response.ok) throw new Error('Network error');
                        return response.text();
                    })
                    .then(csv => {
                        allStrains = parseCSV(csv);
                        renderStrainList(allStrains);
                    })
                    .catch(error => {
                        console.error('Error loading data:', error);
                        strainList.innerHTML = '<div class="strain-item"><div class="strain-info"><div class="strain-name">Error loading strains</div></div></div>';
                    });
            }
            
            function parseCSV(csv) {
                const lines = csv.split('\n');
                const headers = lines[0].split(',').map(header => header.trim());
                
                const result = [];
                for (let i = 1; i < lines.length; i++) {
                    if (!lines[i].trim()) continue;
                    
                    const values = parseCSVLine(lines[i]);
                    
                    if (values.length < 2 || !values[0].trim()) continue;
                    if (values[0].trim().toUpperCase() === 'STRAIN' || values[0].trim() === 'Unnamed Seed') continue;
                    
                    const entry = {};
                    for (let j = 0; j < headers.length; j++) {
                        entry[headers[j]] = j < values.length ? values[j].trim() : '';
                    }
                    
                    // Generate unique ID
                    entry.id = `strain-${i}`;
                    result.push(entry);
                }
                
                return result;
            }
            
            function parseCSVLine(line) {
                let results = [];
                let currentValue = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        results.push(currentValue);
                        currentValue = '';
                    } else {
                        currentValue += char;
                    }
                }
                
                results.push(currentValue);
                return results;
            }
            
            function renderStrainList(strains) {
                if (!strains.length) {
                    strainList.innerHTML = '<div class="strain-item"><div class="strain-info"><div class="strain-name">No strains found</div></div></div>';
                    return;
                }
                
                strainList.innerHTML = '';
                
                strains.forEach(strain => {
                    const strainName = strain.STRAIN || strain.Strain || strain.Name || 'Unnamed';
                    const count = strain.COUNT || strain.Count || '';
                    const type = strain['REG / FEM'] || strain.Type || '';
                    
                    // Create type tags
                    let tags = '';
                    if (type.toLowerCase().includes('reg')) tags += '<span class="strain-tag tag-reg">REG</span>';
                    if (type.toLowerCase().includes('fem')) tags += '<span class="strain-tag tag-fem">FEM</span>';
                    if (type.toLowerCase().includes('auto')) tags += '<span class="strain-tag tag-auto">AUTO</span>';
                    if (type.toLowerCase().includes('photo')) tags += '<span class="strain-tag tag-photo">PHOTO</span>';
                    if (type.toLowerCase().includes('fast')) tags += '<span class="strain-tag tag-fast">FAST</span>';
                    
                    const item = document.createElement('div');
                    item.className = 'strain-item';
                    item.dataset.id = strain.id;
                    item.dataset.name = strainName;
                    item.dataset.type = type;
                    item.dataset.parent1 = strain.PARENT1 || strain.parent1 || '';
                    item.dataset.parent2 = strain.PARENT2 || strain.parent2 || '';
                    item.dataset.count = count;
                    
                    item.innerHTML = `
                        <div class="strain-info">
                            <div class="strain-name">${strainName}</div>
                            <div class="strain-type">${tags}</div>
                        </div>
                        <div class="strain-count">${count}</div>
                    `;
                    
                    item.addEventListener('click', function() {
                        addNodeToCanvas(strain);
                    });
                    
                    strainList.appendChild(item);
                });
            }
            
            function setupEventListeners() {
                // Canvas events
                breedingCanvas.addEventListener('click', handleCanvasClick);
                breedingCanvas.addEventListener('mousemove', handleCanvasMouseMove);
                
                // Search functionality
                searchBtn.addEventListener('click', performSearch);
                searchInput.addEventListener('keyup', e => {
                    if (e.key === 'Enter') performSearch();
                });
                
                // Filter tabs
                filterTabs.forEach(tab => {
                    tab.addEventListener('click', function() {
                        filterTabs.forEach(t => t.classList.remove('active'));
                        this.classList.add('active');
                        filterStrains(this.dataset.filter);
                    });
                });
                
                // Action buttons
                newDiagramBtn.addEventListener('click', newDiagram);
                saveDiagramBtn.addEventListener('click', showSaveDiagramModal);
                loadDiagramBtn.addEventListener('click', showLoadDiagramModal);
                
                // Cross modal
                cancelCrossBtn.addEventListener('click', () => hideModal(nameCrossModal));
                createCrossBtn.addEventListener('click', createCross);
                
                // Load diagram modal
                cancelLoadBtn.addEventListener('click', () => hideModal(loadDiagramModal));
                confirmLoadBtn.addEventListener('click', confirmLoadDiagram);
                
                // Save diagram modal
                cancelSaveBtn.addEventListener('click', () => hideModal(saveDiagramModal));
                confirmSaveBtn.addEventListener('click', confirmSaveDiagram);
            }
            
            function performSearch() {
                const searchTerm = searchInput.value.trim().toLowerCase();
                
                if (!searchTerm) {
                    renderStrainList(allStrains);
                    return;
                }
                
                const filteredStrains = allStrains.filter(strain => {
                    const name = (strain.STRAIN || strain.Strain || strain.Name || '').toLowerCase();
                    const breeder = (strain.BREEDER || strain.Breeder || '').toLowerCase();
                    const type = (strain['REG / FEM'] || strain.Type || '').toLowerCase();
                    const parent1 = (strain.PARENT1 || strain.parent1 || '').toLowerCase();
                    const parent2 = (strain.PARENT2 || strain.parent2 || '').toLowerCase();
                    
                    return name.includes(searchTerm) || 
                        breeder.includes(searchTerm) || 
                        type.includes(searchTerm) || 
                        parent1.includes(searchTerm) || 
                        parent2.includes(searchTerm);
                });
                
                renderStrainList(filteredStrains);
            }
            
            function filterStrains(filter) {
                if (filter === 'all') {
                    renderStrainList(allStrains);
                    return;
                }
                
                const filteredStrains = allStrains.filter(strain => {
                    const type = (strain['REG / FEM'] || strain.Type || '').toLowerCase();
                    return type.includes(filter.toLowerCase());
                });
                
                renderStrainList(filteredStrains);
            }
            
            function addNodeToCanvas(strain) {
                nodeCounter++;
                const nodeId = `node-${nodeCounter}`;
                
                const strainName = strain.STRAIN || strain.Strain || strain.Name || 'Unnamed';
                const type = strain['REG / FEM'] || strain.Type || '';
                
                // Determine node type class
                let nodeClass = 'breeding-node';
                if (type.toLowerCase().includes('reg')) nodeClass += ' reg';
                if (type.toLowerCase().includes('fem')) nodeClass += ' fem';
                if (type.toLowerCase().includes('auto')) nodeClass += ' auto';
                if (type.toLowerCase().includes('photo')) nodeClass += ' photo';
                if (type.toLowerCase().includes('fast')) nodeClass += ' fast';
                
                const node = document.createElement('div');
                node.id = nodeId;
                node.className = nodeClass;
                node.dataset.name = strainName;
                node.dataset.type = type;
                node.dataset.origin = 'strain'; // vs 'cross'
                node.dataset.parent1 = strain.PARENT1 || strain.parent1 || '';
                node.dataset.parent2 = strain.PARENT2 || strain.parent2 || '';
                
                // Position in the center-ish of the canvas with some randomness
                const x = breedingCanvas.clientWidth * (0.3 + Math.random() * 0.4);
                const y = breedingCanvas.clientHeight * (0.3 + Math.random() * 0.4);
                
                node.style.left = `${x}px`;
                node.style.top = `${y}px`;
                
                node.innerHTML = `
                    <div class="node-header">
                        <div class="node-name">${strainName}</div>
                        <div class="node-controls">
                            <div class="node-control" data-action="remove" title="Remove">×</div>
                        </div>
                    </div>
                    <div class="connection-point" data-node="${nodeId}"></div>
                `;
                
                // Make draggable
                node.addEventListener('mousedown', startDragging);
                
                // Connection point
                const connectionPoint = node.querySelector('.connection-point');
                connectionPoint.addEventListener('mousedown', startConnecting);
                
                // Add control actions
                const removeBtn = node.querySelector('[data-action="remove"]');
                removeBtn.addEventListener('click', function(event) {
                    event.stopPropagation();
                    removeNode(nodeId);
                });
                
                // Add to canvas
                breedingCanvas.appendChild(node);
                
                // Add to nodes array
                nodes.push({
                    id: nodeId,
                    name: strainName,
                    type: type,
                    origin: 'strain',
                    parent1: strain.PARENT1 || strain.parent1 || '',
                    parent2: strain.PARENT2 || strain.parent2 || ''
                });
                
                // Set as selected
                selectNode(nodeId);
            }
            
            function addCrossNodeToCanvas(crossData) {
                nodeCounter++;
                const nodeId = `node-${nodeCounter}`;
                
                // Determine node type class
                let nodeClass = 'breeding-node breeding-result';
                if (crossData.type.toLowerCase().includes('reg')) nodeClass += ' reg';
                if (crossData.type.toLowerCase().includes('fem')) nodeClass += ' fem';
                if (crossData.type.toLowerCase().includes('auto')) nodeClass += ' auto';
                if (crossData.type.toLowerCase().includes('photo')) nodeClass += ' photo';
                if (crossData.type.toLowerCase().includes('fast')) nodeClass += ' fast';
                
                const node = document.createElement('div');
                node.id = nodeId;
                node.className = nodeClass;
                node.dataset.name = crossData.name;
                node.dataset.type = crossData.type;
                node.dataset.origin = 'cross';
                node.dataset.parent1 = crossData.parent1Name;
                node.dataset.parent2 = crossData.parent2Name;
                
                // Position between the two parents with offset down
                const parent1El = document.getElementById(crossData.parent1);
                const parent2El = document.getElementById(crossData.parent2);
                
                const parent1Rect = parent1El.getBoundingClientRect();
                const parent2Rect = parent2El.getBoundingClientRect();
                const canvasRect = breedingCanvas.getBoundingClientRect();
                
                const x = (parent1Rect.left + parent2Rect.left) / 2 - canvasRect.left + 
                          (parent1Rect.width + parent2Rect.width) / 4;
                const y = Math.max(parent1Rect.bottom, parent2Rect.bottom) - canvasRect.top + 50;
                
                node.style.left = `${x}px`;
                node.style.top = `${y}px`;
                
                node.innerHTML = `
                    <div class="node-header">
                        <div class="node-name">${crossData.name}</div>
                        <div class="node-controls">
                            <div class="node-control" data-action="remove" title="Remove">×</div>
                        </div>
                    </div>
                    <div class="connection-point" data-node="${nodeId}"></div>
                `;
                
                // Make draggable
                node.addEventListener('mousedown', startDragging);
                
                // Connection point
                const connectionPoint = node.querySelector('.connection-point');
                connectionPoint.addEventListener('mousedown', startConnecting);
                
                // Add control actions
                const removeBtn = node.querySelector('[data-action="remove"]');
                removeBtn.addEventListener('click', function(event) {
                    event.stopPropagation();
                    removeNode(nodeId);
                });
                
                // Add to canvas
                breedingCanvas.appendChild(node);
                
                // Add to nodes array
                nodes.push({
                    id: nodeId,
                    name: crossData.name,
                    type: crossData.type,
                    origin: 'cross',
                    parent1: crossData.parent1Name,
                    parent2: crossData.parent2Name
                });
                
                // Create connections to parents
                createConnection(crossData.parent1, nodeId);
                createConnection(crossData.parent2, nodeId);
                
                // Set as selected
                selectNode(nodeId);
            }
            
            function startDragging(event) {
                event.preventDefault();
                event.stopPropagation();
                
                // Select this node
                selectNode(this.id);
                
                // Don't drag if we're clicking a control
                if (event.target.classList.contains('node-control') || 
                    event.target.classList.contains('connection-point')) {
                    return;
                }
                
                const node = this;
                const rect = node.getBoundingClientRect();
                const offsetX = event.clientX - rect.left;
                const offsetY = event.clientY - rect.top;
                
                // Move function
                function moveNode(e) {
                    const x = e.clientX - offsetX;
                    const y = e.clientY - offsetY;
                    
                    node.style.left = `${x}px`;
                    node.style.top = `${y}px`;
                    
                    // Update any connections to/from this node
                    updateConnections(node.id);
                }
                
                // End drag function
                function endDrag() {
                    document.removeEventListener('mousemove', moveNode);
                    document.removeEventListener('mouseup', endDrag);
                }
                
                document.addEventListener('mousemove', moveNode);
                document.addEventListener('mouseup', endDrag);
            }
            
            function startConnecting(event) {
                event.preventDefault();
                event.stopPropagation();
                
                // Get node id from the connection point
                const nodeId = this.dataset.node;
                
                // Start connecting
                connecting = true;
                connectingFrom = nodeId;
                
                // Create a temporary line
                tempLine = document.createElement('svg');
                tempLine.classList.add('connection-line');
                tempLine.style.position = 'absolute';
                tempLine.style.top = '0';
                tempLine.style.left = '0';
                tempLine.style.width = '100%';
                tempLine.style.height = '100%';
                tempLine.style.pointerEvents = 'none';
                tempLine.style.zIndex = '1';
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('stroke', '#5d4a7e');
                line.setAttribute('stroke-width', '2');
                
                tempLine.appendChild(line);
                breedingCanvas.appendChild(tempLine);
                
                // Update line position
                updateTempLine(event);
                
                // Set up events
                document.addEventListener('mousemove', updateTempLine);
                document.addEventListener('mouseup', finishConnecting);
            }
            
            function updateTempLine(event) {
                if (!connecting || !tempLine) return;
                
                const canvasRect = breedingCanvas.getBoundingClientRect();
                const sourceNodeEl = document.getElementById(connectingFrom);
                const sourceConnPoint = sourceNodeEl.querySelector('.connection-point');
                const sourceRect = sourceConnPoint.getBoundingClientRect();
                
                const sourceX = sourceRect.left - canvasRect.left + sourceRect.width / 2;
                const sourceY = sourceRect.top - canvasRect.top + sourceRect.height / 2;
                
                const targetX = event.clientX - canvasRect.left;
                const targetY = event.clientY - canvasRect.top;
                
                const line = tempLine.querySelector('line');
                line.setAttribute('x1', sourceX);
                line.setAttribute('y1', sourceY);
                line.setAttribute('x2', targetX);
                line.setAttribute('y2', targetY);
            }
            
            function finishConnecting(event) {
                if (!connecting) return;
                
                document.removeEventListener('mousemove', updateTempLine);
                document.removeEventListener('mouseup', finishConnecting);
                
                // Remove temp line
                if (tempLine) {
                    tempLine.remove();
                    tempLine = null;
                }
                
                // Check if we're over a connection point
                const element = document.elementFromPoint(event.clientX, event.clientY);
                if (element && element.classList.contains('connection-point')) {
                    const targetNodeId = element.dataset.node;
                    
                    // Don't connect to self
                    if (targetNodeId !== connectingFrom) {
                        // Show cross naming modal
                        showNameCrossModal(connectingFrom, targetNodeId);
                    }
                }
                
                connecting = false;
                connectingFrom = null;
            }
            
            function showNameCrossModal(sourceId, targetId) {
                // Get node data
                const sourceNode = nodes.find(n => n.id === sourceId);
                const targetNode = nodes.find(n => n.id === targetId);
                
                if (!sourceNode || !targetNode) return;
                
                // Generate default cross name
                const defaultName = `${sourceNode.name} × ${targetNode.name}`;
                defaultCrossName.textContent = defaultName;
                
                // Determine likely cross type based on parents
                let suggestedType = 'reg';
                const sourceType = sourceNode.type.toLowerCase();
                const targetType = targetNode.type.toLowerCase();
                
                if ((sourceType.includes('fem') && targetType.includes('reg')) || 
                    (sourceType.includes('reg') && targetType.includes('fem'))) {
                    suggestedType = 'fem';
                }
                
                if (sourceType.includes('auto') || targetType.includes('auto')) {
                    suggestedType = 'auto';
                }
                
                crossType.value = suggestedType;
                
                // Store data for when user confirms
                pendingCrossData = {
                    parent1: sourceId,
                    parent2: targetId,
                    parent1Name: sourceNode.name,
                    parent2Name: targetNode.name,
                    defaultName: defaultName
                };
                
                // Show modal
                showModal(nameCrossModal);
            }
            
            function createCross() {
                if (!pendingCrossData) return;
                
                // Get data from form
                const customName = customCrossName.value.trim();
                const type = crossType.value;
                
                // Create cross data
                const crossData = {
                    ...pendingCrossData,
                    name: customName || pendingCrossData.defaultName,
                    type: type
                };
                
                // Add cross node to canvas
                addCrossNodeToCanvas(crossData);
                
                // Hide modal
                hideModal(nameCrossModal);
                customCrossName.value = '';
                pendingCrossData = null;
            }
            
            function createConnection(sourceId, targetId) {
                // Create SVG for the connection
                const svg = document.createElement('svg');
                svg.classList.add('connection-line');
                svg.id = `connection-${sourceId}-${targetId}`;
                svg.style.position = 'absolute';
                svg.style.top = '0';
                svg.style.left = '0';
                svg.style.width = '100%';
                svg.style.height = '100%';
                svg.style.pointerEvents = 'none';
                svg.style.zIndex = '1';
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('stroke', '#5d4a7e');
                line.setAttribute('stroke-width', '2');
                
                svg.appendChild(line);
                breedingCanvas.appendChild(svg);
                
                // Add to connections array
                connections.push({
                    id: `connection-${sourceId}-${targetId}`,
                    source: sourceId,
                    target: targetId
                });
                
                // Update connection position
                updateConnection(sourceId, targetId);
            }
            
            function updateConnections(nodeId) {
                // Update all connections involving this node
                connections.forEach(connection => {
                    if (connection.source === nodeId || connection.target === nodeId) {
                        updateConnection(connection.source, connection.target);
                    }
                });
            }
            
            function updateConnection(sourceId, targetId) {
                const connectionId = `connection-${sourceId}-${targetId}`;
                const svg = document.getElementById(connectionId);
                
                if (!svg) return;
                
                const sourceNodeEl = document.getElementById(sourceId);
                const targetNodeEl = document.getElementById(targetId);
                
                if (!sourceNodeEl || !targetNodeEl) return;
                
                const sourceConnPoint = sourceNodeEl.querySelector('.connection-point');
                const targetConnPoint = targetNodeEl.querySelector('.connection-point');
                
                const canvasRect = breedingCanvas.getBoundingClientRect();
                const sourceRect = sourceConnPoint.getBoundingClientRect();
                const targetRect = targetConnPoint.getBoundingClientRect();
                
                const sourceX = sourceRect.left - canvasRect.left + sourceRect.width / 2;
                const sourceY = sourceRect.top - canvasRect.top + sourceRect.height / 2;
                const targetX = targetRect.left - canvasRect.left + targetRect.width / 2;
                const targetY = targetRect.top - canvasRect.top + targetRect.height / 2;
                
                const line = svg.querySelector('line');
                line.setAttribute('x1', sourceX);
                line.setAttribute('y1', sourceY);
                line.setAttribute('x2', targetX);
                line.setAttribute('y2', targetY);
            }
            
            function removeNode(nodeId) {
                // Remove node from DOM
                const nodeEl = document.getElementById(nodeId);
                if (nodeEl) nodeEl.remove();
                
                // Remove node from state
                nodes = nodes.filter(node => node.id !== nodeId);
                
                // Remove connections involving this node
                connections = connections.filter(connection => {
                    if (connection.source === nodeId || connection.target === nodeId) {
                        // Remove connection element
                        const connectionEl = document.getElementById(connection.id);
                        if (connectionEl) connectionEl.remove();
                        return false;
                    }
                    return true;
                });
                
                // Clear selection if this was selected
                if (selectedNode && selectedNode.id === nodeId) {
                    selectedNode = null;
                }
            }
            
            function selectNode(nodeId) {
                // Clear current selection
                document.querySelectorAll('.breeding-node.selected').forEach(node => {
                    node.classList.remove('selected');
                });
                
                // Set new selection
                const nodeEl = document.getElementById(nodeId);
                if (nodeEl) {
                    nodeEl.classList.add('selected');
                    selectedNode = nodes.find(node => node.id === nodeId);
                }
            }
            
            function handleCanvasClick(event) {
                // If not clicking on a node, clear selection
                if (!event.target.closest('.breeding-node')) {
                    document.querySelectorAll('.breeding-node.selected').forEach(node => {
                        node.classList.remove('selected');
                    });
                    selectedNode = null;
                }
            }
            
            function handleCanvasMouseMove(event) {
                if (connecting) {
                    updateTempLine(event);
                }
            }
            
            // Diagram Management
            function newDiagram() {
                if (nodes.length > 0) {
                    if (!confirm('Create a new diagram? This will clear all current nodes.')) {
                        return;
                    }
                }
                
                // Clear all nodes
                document.querySelectorAll('.breeding-node').forEach(node => node.remove());
                
                // Clear all connections
                document.querySelectorAll('.connection-line').forEach(conn => conn.remove());
                
                // Reset state
                nodes = [];
                connections = [];
                selectedNode = null;
                nodeCounter = 0;
            }
            
            function showSaveDiagramModal() {
                if (nodes.length === 0) {
                    alert('Nothing to save. Add some strains to your diagram first.');
                    return;
                }
                
                showModal(saveDiagramModal);
            }
            
            function confirmSaveDiagram() {
                const diagramName = diagramNameInput.value.trim();
                
                if (!diagramName) {
                    alert('Please enter a name for your diagram.');
                    return;
                }
                
                // Capture current positions
                const positionData = {};
                nodes.forEach(node => {
                    const nodeEl = document.getElementById(node.id);
                    if (nodeEl) {
                        positionData[node.id] = {
                            left: nodeEl.style.left,
                            top: nodeEl.style.top
                        };
                    }
                });
                
                // Create save data
                const saveData = {
                    name: diagramName,
                    date: new Date().toISOString(),
                    nodes: nodes,
                    connections: connections,
                    positions: positionData
                };
                
                // Get existing saved diagrams
                let savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
                
                // Check for existing with same name
                const existingIndex = savedDiagrams.findIndex(d => d.name === diagramName);
                if (existingIndex >= 0) {
                    if (confirm(`A diagram named "${diagramName}" already exists. Overwrite it?`)) {
                        savedDiagrams[existingIndex] = saveData;
                    } else {
                        return;
                    }
                } else {
                    savedDiagrams.push(saveData);
                }
                
                // Save to localStorage
                localStorage.setItem('breedingDiagrams', JSON.stringify(savedDiagrams));
                
                // Hide modal
                hideModal(saveDiagramModal);
                diagramNameInput.value = '';
                
                alert(`Diagram "${diagramName}" saved successfully.`);
            }
            
            function showLoadDiagramModal() {
                // Get saved diagrams
                const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
                
                if (savedDiagrams.length === 0) {
                    savedDiagramsList.innerHTML = 'No saved diagrams found.';
                    confirmLoadBtn.disabled = true;
                } else {
                    // Create list of saved diagrams
                    let html = '<div class="form-group"><label class="form-label">Select a diagram:</label>';
                    html += '<div class="form-input">';
                    
                    savedDiagrams.forEach((diagram, index) => {
                        const date = new Date(diagram.date).toLocaleDateString();
                        html += `
                            <div>
                                <input type="radio" name="diagram" id="diagram-${index}" value="${index}" 
                                    ${index === 0 ? 'checked' : ''}>
                                <label for="diagram-${index}">${diagram.name} (${date})</label>
                            </div>
                        `;
                    });
                    
                    html += '</div></div>';
                    savedDiagramsList.innerHTML = html;
                    confirmLoadBtn.disabled = false;
                }
                
                showModal(loadDiagramModal);
            }
            
            function confirmLoadDiagram() {
                // Get selected diagram
                const selectedRadio = document.querySelector('input[name="diagram"]:checked');
                if (!selectedRadio) return;
                
                const index = parseInt(selectedRadio.value);
                const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
                
                if (index < 0 || index >= savedDiagrams.length) return;
                
                // Check if current diagram should be cleared
                if (nodes.length > 0) {
                    if (!confirm('Loading a new diagram will replace the current one. Continue?')) {
                        return;
                    }
                }
                
                const diagram = savedDiagrams[index];
                
                // Clear existing
                newDiagram();
                
                // Load nodes first
                diagram.nodes.forEach(node => {
                    const nodeEl = document.createElement('div');
                    nodeEl.id = node.id;
                    
                    // Determine node type class
                    let nodeClass = 'breeding-node';
                    if (node.origin === 'cross') nodeClass += ' breeding-result';
                    if (node.type.toLowerCase().includes('reg')) nodeClass += ' reg';
                    if (node.type.toLowerCase().includes('fem')) nodeClass += ' fem';
                    if (node.type.toLowerCase().includes('auto')) nodeClass += ' auto';
                    if (node.type.toLowerCase().includes('photo')) nodeClass += ' photo';
                    if (node.type.toLowerCase().includes('fast')) nodeClass += ' fast';
                    
                    nodeEl.className = nodeClass;
                    nodeEl.dataset.name = node.name;
                    nodeEl.dataset.type = node.type;
                    nodeEl.dataset.origin = node.origin;
                    nodeEl.dataset.parent1 = node.parent1 || '';
                    nodeEl.dataset.parent2 = node.parent2 || '';
                    
                    // Set position
                    if (diagram.positions && diagram.positions[node.id]) {
                        nodeEl.style.left = diagram.positions[node.id].left;
                        nodeEl.style.top = diagram.positions[node.id].top;
                    } else {
                        // Fallback position
                        nodeEl.style.left = `${100 + Math.random() * 300}px`;
                        nodeEl.style.top = `${100 + Math.random() * 200}px`;
                    }
                    
                    nodeEl.innerHTML = `
                        <div class="node-header">
                            <div class="node-name">${node.name}</div>
                            <div class="node-controls">
                                <div class="node-control" data-action="remove" title="Remove">×</div>
                            </div>
                        </div>
                        <div class="connection-point" data-node="${node.id}"></div>
                    `;
                    
                    // Make draggable
                    nodeEl.addEventListener('mousedown', startDragging);
                    
                    // Connection point
                    const connectionPoint = nodeEl.querySelector('.connection-point');
                    connectionPoint.addEventListener('mousedown', startConnecting);
                    
                    // Add control actions
                    const removeBtn = nodeEl.querySelector('[data-action="remove"]');
                    removeBtn.addEventListener('click', function(event) {
                        event.stopPropagation();
                        removeNode(node.id);
                    });
                    
                    // Add to canvas
                    breedingCanvas.appendChild(nodeEl);
                });
                
                // Set node counter to prevent id conflicts
                if (diagram.nodes.length > 0) {
                    // Extract highest node number
                    const nodeIds = diagram.nodes.map(n => {
                        const match = n.id.match(/node-(\d+)/);
                        return match ? parseInt(match[1]) : 0;
                    });
                    nodeCounter = Math.max(...nodeIds);
                }
                
                // Add to nodes array
                nodes = JSON.parse(JSON.stringify(diagram.nodes));
                
                // Now create connections
                connections = [];
                diagram.connections.forEach(conn => {
                    createConnection(conn.source, conn.target);
                });
                
                hideModal(loadDiagramModal);
            }
            
            function showModal(modal) {
                modal.classList.add('visible');
            }
            
            function hideModal(modal) {
                modal.classList.remove('visible');
            }
        });
    </script>
</body>
</html>
