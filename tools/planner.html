<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strain Breeding Planner - ᵗʰᵉ Rev™</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        :root {
            --primary: #2D5E32;
            --primary-light: #68A357;
            --primary-dark: #1A3C20;
            --accent: #5D4A7E;
            --bg-color: #F8F6E9;
            --text: #333;
            --text-light: #666;
            --border: #ddd;
            --auto-color: #FFB74D;
            --photo-color: #4DB6AC;
            --reg-color: #9575CD;
            --fem-color: #F06292;
            --fast-color: #4FC3F7;
            --limited-color: #FFC107;
            --rare-color: #9C27B0;
            --female-color: #E091B9;
            --male-color: #91B7E0;
            --node-color: #D2691E;
            --link-color: #A0522D;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--bg-color);
            color: var(--text);
            line-height: 1.6;
        }
        
        header {
            background: linear-gradient(135deg, var(--primary-dark), var(--primary));
            color: white;
            padding: 1rem;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .subtitle {
            font-size: 1.2rem;
            font-weight: 300;
            opacity: 0.9;
        }
        
        .container {
            display: flex;
            height: calc(100vh - 60px);
            padding: 15px;
        }
        
        .sidebar {
            width: 320px;
            margin-right: 15px;
            display: flex;
            flex-direction: column;
        }
        
        .main-content {
            flex: 1;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        .panel-header {
            background-color: var(--primary);
            color: white;
            padding: 10px 15px;
            font-weight: 500;
        }
        
        .panel-content {
            padding: 15px;
        }
        
        /* Strain List Styles */
        .search-container {
            display: flex;
            margin-bottom: 10px;
        }
        
        #search-input {
            flex: 1;
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 4px 0 0 4px;
        }
        
        #search-btn {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 0 4px 4px 0;
            cursor: pointer;
        }
        
        .filter-btns {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        .filter-btn {
            background: #f0f0f0;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }
        
        .filter-btn.active {
            background-color: var(--accent);
            color: white;
        }
        
        .strain-list {
            list-style: none;
            overflow-y: auto;
            height: calc(100vh - 240px);
            border: 1px solid var(--border);
        }
        
        .strain-item {
            padding: 8px 12px;
            border-bottom: 1px solid var(--border);
            cursor: grab;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .strain-item:hover {
            background-color: rgba(45, 94, 50, 0.05);
        }
        
        .strain-item-drag {
            opacity: 0.6;
        }
        
        .strain-name {
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .strain-type {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            font-size: 10px;
            color: white;
        }
        
        .type-badge {
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 500;
        }
        
        .badge-reg { background-color: var(--reg-color); }
        .badge-fem { background-color: var(--fem-color); }
        .badge-auto { background-color: var(--auto-color); }
        .badge-photo { background-color: var(--photo-color); }
        .badge-fast { background-color: var(--fast-color); }
        
        .strain-count {
            font-weight: bold;
            color: var(--accent);
            font-size: 12px;
            background-color: rgba(93, 74, 126, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        /* Canvas Area */
        .canvas-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid var(--border);
        }
        
        .canvas-title {
            font-size: 18px;
            font-weight: 500;
        }
        
        .canvas-actions {
            display: flex;
            gap: 10px;
        }
        
        .action-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            background-color: var(--primary);
            color: white;
            cursor: pointer;
            font-size: 14px;
        }
        
        .action-btn:hover {
            background-color: var(--primary-dark);
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: #2d2d2d;
        }
        
        .info-panel {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            max-width: 300px;
            z-index: 1000;
        }
        
        /* Node and Link Styles */
        .node {
            cursor: pointer;
        }
        
        .node-label {
            font-size: 12px;
            pointer-events: none;
            text-shadow: 0 1px 0 rgba(0, 0, 0, 0.2);
        }
        
        .link {
            stroke-opacity: 0.6;
            stroke-width: 2px;
        }
        
        /* Drag-drop indicator */
        .drop-indicator {
            position: absolute;
            border: 2px dashed var(--accent);
            background-color: rgba(93, 74, 126, 0.1);
            border-radius: 8px;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: var(--accent);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 999;
        }
        
        .drop-indicator.visible {
            opacity: 1;
        }
        
        /* Node menu */
        .node-menu {
            position: absolute;
            background: white;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            padding: 5px 0;
            z-index: 1000;
            display: none;
        }
        
        .node-menu.visible {
            display: block;
        }
        
        .menu-item {
            padding: 6px 15px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .menu-item:hover {
            background-color: rgba(45, 94, 50, 0.1);
        }
        
        .menu-divider {
            height: 1px;
            background-color: var(--border);
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <header>
        <div class="subtitle">Strain Breeding Planner - ᵗʰᵉ Rev™</div>
    </header>
    
    <div class="container">
        <div class="sidebar">
            <div class="panel">
                <div class="panel-header">Strain Collection</div>
                <div class="panel-content">
                    <div class="search-container">
                        <input type="text" id="search-input" placeholder="Search strains...">
                        <button id="search-btn">Search</button>
                    </div>
                    
                    <div class="filter-btns">
                        <button class="filter-btn active" data-filter="all">All</button>
                        <button class="filter-btn" data-filter="reg">REG</button>
                        <button class="filter-btn" data-filter="fem">FEM</button>
                        <button class="filter-btn" data-filter="auto">AUTO</button>
                        <button class="filter-btn" data-filter="photo">PHOTO</button>
                        <button class="filter-btn" data-filter="fast">FAST</button>
                    </div>
                    
                    <div class="strain-list" id="strain-list">
                        <!-- Strains will be loaded here -->
                        <div class="strain-item">
                            <div>Loading strains...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="canvas-header">
                <div class="canvas-title">Breeding Diagram</div>
                <div class="canvas-actions">
                    <button id="new-diagram" class="action-btn">New Diagram</button>
                    <button id="save-diagram" class="action-btn">Save Diagram</button>
                    <button id="load-diagram" class="action-btn">Load Diagram</button>
                </div>
            </div>
            
            <div class="canvas-container" id="canvas">
                <!-- D3 graph will be rendered here -->
                <div class="drop-indicator" id="drop-indicator">
                    Drop strain here to add to diagram
                </div>
                <div class="node-menu" id="node-menu">
                    <div class="menu-item" data-action="details">View Details</div>
                    <div class="menu-item" data-action="addParent">Add Parent</div>
                    <div class="menu-item" data-action="addChild">Add Child</div>
                    <div class="menu-divider"></div>
                    <div class="menu-item" data-action="remove">Remove Node</div>
                </div>
            </div>
            
            <div class="info-panel">
                Drag strains from the list to create a breeding diagram. Right-click nodes for more options.
            </div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Configuration
            const sheetId = '1A7kFjfw6cjmQQOwz-5liWVGgFK0K5lwS8AfIZ_Zthbg';
            const nodeColors = {
                default: '#D2691E',
                female: '#E091B9',
                male: '#91B7E0',
                auto: '#FFB74D',
                photo: '#4DB6AC',
                reg: '#9575CD',
                fem: '#F06292',
                fast: '#4FC3F7'
            };
            
            // State
            let allStrains = [];
            let graph = {
                nodes: [],
                links: []
            };
            let simulation;
            let svg;
            let selectedNode = null;
            let draggedStrain = null;
            let nodeMenu = document.getElementById('node-menu');
            
            // Elements
            const canvas = document.getElementById('canvas');
            const strainList = document.getElementById('strain-list');
            const dropIndicator = document.getElementById('drop-indicator');
            const searchInput = document.getElementById('search-input');
            const searchBtn = document.getElementById('search-btn');
            
            // Initialize
            initCanvas();
            loadStrains();
            setupEventListeners();
            
            // Functions
            function initCanvas() {
                // Create SVG canvas for the graph
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                
                svg = d3.select('#canvas')
                    .append('svg')
                    .attr('width', width)
                    .attr('height', height);
                
                // Add a background to capture events
                svg.append('rect')
                    .attr('width', width)
                    .attr('height', height)
                    .attr('fill', 'transparent')
                    .on('click', clearSelection);
                
                // Create force simulation
                simulation = d3.forceSimulation()
                    .force('link', d3.forceLink().id(d => d.id).distance(150))
                    .force('charge', d3.forceManyBody().strength(-500))
                    .force('center', d3.forceCenter(width / 2, height / 2))
                    .on('tick', ticked);
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    const newWidth = canvas.clientWidth;
                    const newHeight = canvas.clientHeight;
                    
                    svg.attr('width', newWidth)
                        .attr('height', newHeight);
                    
                    simulation.force('center', d3.forceCenter(newWidth / 2, newHeight / 2));
                    simulation.alpha(0.3).restart();
                });
            }
            
            function loadStrains() {
                strainList.innerHTML = '<div class="strain-item"><div>Loading strains...</div></div>';
                
                const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv`;
                
                fetch(csvUrl)
                    .then(response => {
                        if (!response.ok) throw new Error('Network error');
                        return response.text();
                    })
                    .then(csv => {
                        allStrains = parseCSV(csv);
                        renderStrainList(allStrains);
                        setupDragAndDrop();
                    })
                    .catch(error => {
                        console.error('Error loading data:', error);
                        strainList.innerHTML = '<div class="strain-item"><div>Error loading strains</div></div>';
                    });
            }
            
            function parseCSV(csv) {
                const lines = csv.split('\n');
                const headers = lines[0].split(',').map(header => header.trim());
                
                const result = [];
                for (let i = 1; i < lines.length; i++) {
                    if (!lines[i].trim()) continue;
                    
                    const values = parseCSVLine(lines[i]);
                    
                    if (values.length < 2 || !values[0].trim()) continue;
                    if (values[0].trim().toUpperCase() === 'STRAIN' || values[0].trim() === 'Unnamed Seed') continue;
                    
                    const entry = {};
                    for (let j = 0; j < headers.length; j++) {
                        entry[headers[j]] = j < values.length ? values[j].trim() : '';
                    }
                    
                    // Generate unique ID
                    entry.id = `strain-${i}`;
                    result.push(entry);
                }
                
                return result;
            }
            
            function parseCSVLine(line) {
                let results = [];
                let currentValue = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        results.push(currentValue);
                        currentValue = '';
                    } else {
                        currentValue += char;
                    }
                }
                
                results.push(currentValue);
                return results;
            }
            
            function renderStrainList(strains) {
                if (!strains.length) {
                    strainList.innerHTML = '<div class="strain-item"><div>No strains found</div></div>';
                    return;
                }
                
                strainList.innerHTML = '';
                
                strains.forEach(strain => {
                    const strainName = strain.STRAIN || strain.Strain || strain.Name || 'Unnamed';
                    const count = strain.COUNT || strain.Count || '';
                    const type = strain['REG / FEM'] || strain.Type || '';
                    
                    // Create type badges
                    let badges = '';
                    if (type.toLowerCase().includes('reg')) badges += '<span class="type-badge badge-reg">REG</span>';
                    if (type.toLowerCase().includes('fem')) badges += '<span class="type-badge badge-fem">FEM</span>';
                    if (type.toLowerCase().includes('auto')) badges += '<span class="type-badge badge-auto">AUTO</span>';
                    if (type.toLowerCase().includes('photo')) badges += '<span class="type-badge badge-photo">PHOTO</span>';
                    if (type.toLowerCase().includes('fast')) badges += '<span class="type-badge badge-fast">FAST</span>';
                    
                    const item = document.createElement('div');
                    item.className = 'strain-item';
                    item.draggable = true;
                    item.dataset.id = strain.id;
                    item.dataset.name = strainName;
                    item.dataset.type = type;
                    
                    item.innerHTML = `
                        <div>
                            <div class="strain-name">${strainName}</div>
                            <div class="strain-type">${badges}</div>
                        </div>
                        <div class="strain-count">${count}</div>
                    `;
                    
                    strainList.appendChild(item);
                });
            }
            
            function setupDragAndDrop() {
                // Make strain items draggable
                document.querySelectorAll('.strain-item').forEach(item => {
                    item.addEventListener('dragstart', handleDragStart);
                    item.addEventListener('dragend', handleDragEnd);
                });
                
                // Make canvas a drop target
                canvas.addEventListener('dragover', handleDragOver);
                canvas.addEventListener('dragenter', handleDragEnter);
                canvas.addEventListener('dragleave', handleDragLeave);
                canvas.addEventListener('drop', handleDrop);
            }
            
            function handleDragStart(e) {
                this.classList.add('strain-item-drag');
                draggedStrain = {
                    id: this.dataset.id,
                    name: this.dataset.name,
                    type: this.dataset.type
                };
                
                // Find the full strain data
                const strainData = allStrains.find(s => s.id === this.dataset.id);
                if (strainData) {
                    draggedStrain.parent1 = strainData.PARENT1 || strainData.parent1 || '';
                    draggedStrain.parent2 = strainData.PARENT2 || strainData.parent2 || '';
                }
                
                e.dataTransfer.setData('text/plain', JSON.stringify(draggedStrain));
            }
            
            function handleDragEnd() {
                this.classList.remove('strain-item-drag');
                draggedStrain = null;
            }
            
            function handleDragOver(e) {
                e.preventDefault();
            }
            
            function handleDragEnter(e) {
                e.preventDefault();
                showDropIndicator();
            }
            
            function handleDragLeave() {
                hideDropIndicator();
            }
            
            function handleDrop(e) {
                e.preventDefault();
                hideDropIndicator();
                
                const data = e.dataTransfer.getData('text/plain');
                if (!data) return;
                
                try {
                    const strain = JSON.parse(data);
                    
                    // Get coordinates relative to the canvas
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    addNodeToGraph(strain, x, y);
                } catch (error) {
                    console.error('Error parsing drag data:', error);
                }
            }
            
            function showDropIndicator() {
                dropIndicator.classList.add('visible');
                dropIndicator.style.top = '50%';
                dropIndicator.style.left = '50%';
                dropIndicator.style.transform = 'translate(-50%, -50%)';
                dropIndicator.style.width = '300px';
                dropIndicator.style.height = '150px';
            }
            
            function hideDropIndicator() {
                dropIndicator.classList.remove('visible');
            }
            
            function addNodeToGraph(strain, x, y) {
                // Check if this strain is already in the graph
                const existingNode = graph.nodes.find(node => node.id === strain.id);
                if (existingNode) {
                    // Node already exists, just update its position
                    existingNode.fx = x;
                    existingNode.fy = y;
                    simulation.alpha(0.3).restart();
                    return;
                }
                
                // Create a new node
                const newNode = {
                    id: strain.id,
                    name: strain.name,
                    type: strain.type,
                    x: x,
                    y: y,
                    parent1: strain.parent1,
                    parent2: strain.parent2
                };
                
                // Add to graph
                graph.nodes.push(newNode);
                
                // If this strain has known parents, try to add links
                if (strain.parent1 || strain.parent2) {
                    // Check if parents are already in the graph
                    const parent1Node = graph.nodes.find(node => 
                        node.name.toLowerCase() === strain.parent1.toLowerCase());
                    
                    const parent2Node = graph.nodes.find(node => 
                        node.name.toLowerCase() === strain.parent2.toLowerCase());
                    
                    if (parent1Node) {
                        graph.links.push({
                            source: parent1Node.id,
                            target: newNode.id,
                            type: 'parent'
                        });
                    }
                    
                    if (parent2Node) {
                        graph.links.push({
                            source: parent2Node.id,
                            target: newNode.id,
                            type: 'parent'
                        });
                    }
                }
                
                updateGraph();
            }
            
            function updateGraph() {
                // Update the simulation with new data
                simulation.nodes(graph.nodes);
                simulation.force('link').links(graph.links);
                
                // Create links
                const link = svg.selectAll('.link')
                    .data(graph.links, d => `${d.source.id || d.source}-${d.target.id || d.target}`);
                
                link.exit().remove();
                
                const linkEnter = link.enter()
                    .append('line')
                    .attr('class', 'link')
                    .attr('stroke', d => getNodeColor(d.type, 'link'))
                    .attr('opacity', 0)
                    .transition()
                    .duration(500)
                    .attr('opacity', 1);
                
                // Create nodes
                const node = svg.selectAll('.node')
                    .data(graph.nodes, d => d.id);
                
                node.exit().remove();
                
                const nodeEnter = node.enter()
                    .append('g')
                    .attr('class', 'node')
                    .call(d3.drag()
                        .on('start', dragstarted)
                        .on('drag', dragged)
                        .on('end', dragended))
                    .on('click', handleNodeClick)
                    .on('contextmenu', handleNodeRightClick);
                
                nodeEnter.append('circle')
                    .attr('r', 0)
                    .attr('fill', d => getNodeColor(d.type))
                    .transition()
                    .duration(500)
                    .attr('r', 20);
                
                nodeEnter.append('text')
                    .attr('class', 'node-label')
                    .attr('text-anchor', 'middle')
                    .attr('dy', '0.35em')
                    .attr('fill', 'white')
                    .text(d => d.name)
                    .attr('opacity', 0)
                    .transition()
                    .duration(500)
                    .attr('opacity', 1);
                
                // Update node title based on drag
                node.select('circle')
                    .attr('stroke', d => d === selectedNode ? '#fff' : 'none')
                    .attr('stroke-width', d => d === selectedNode ? 2 : 0);
                
                // Restart simulation
                simulation.alpha(0.3).restart();
            }
            
            function ticked() {
                svg.selectAll('.link')
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                svg.selectAll('.node')
                    .attr('transform', d => `translate(${d.x}, ${d.y})`);
            }
            
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            function handleNodeClick(event, d) {
                // Prevent the event from bubbling up
                event.stopPropagation();
                
                // Update selected node
                selectedNode = d;
                
                // Update visual selection indication
                svg.selectAll('.node circle')
                    .attr('stroke', node => node === selectedNode ? '#fff' : 'none')
                    .attr('stroke-width', node => node === selectedNode ? 2 : 0);
            }
            
            function handleNodeRightClick(event, d) {
                event.preventDefault();
                event.stopPropagation();
                
                // Update selected node
                selectedNode = d;
                
                // Show context menu at mouse position
                nodeMenu.style.left = `${event.clientX}px`;
                nodeMenu.style.top = `${event.clientY}px`;
                nodeMenu.classList.add('visible');
                
                // Update visual selection indication
                svg.selectAll('.node circle')
                    .attr('stroke', node => node === selectedNode ? '#fff' : 'none')
                    .attr('stroke-width', node => node === selectedNode ? 2 : 0);
            }
            
            function clearSelection() {
                selectedNode = null;
                
                // Hide context menu
                nodeMenu.classList.remove('visible');
                
                // Clear selection visuals
                svg.selectAll('.node circle')
                    .attr('stroke', 'none')
                    .attr('stroke-width', 0);
            }
            
            function getNodeColor(type, elementType = 'node') {
                if (!type) return nodeColors.default;
                
                const lowerType = type.toLowerCase();
                
                if (elementType === 'link') return nodeColors.default;
                
                if (lowerType.includes('fem')) return nodeColors.fem;
                if (lowerType.includes('reg')) return nodeColors.reg;
                if (lowerType.includes('auto')) return nodeColors.auto;
                if (lowerType.includes('photo')) return nodeColors.photo;
                if (lowerType.includes('fast')) return nodeColors.fast;
                
                return nodeColors.default;
            }
            
            function setupEventListeners() {
                // Search functionality
                searchBtn.addEventListener('click', performSearch);
                searchInput.addEventListener('keyup', e => {
                    if (e.key === 'Enter') performSearch();
                });
                
                // Filter buttons
                document.querySelectorAll('.filter-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                        this.classList.add('active');
                        filterStrains(this.dataset.filter);
                    });
                });
                
                // Main action buttons
                document.getElementById('new-diagram').addEventListener('click', newDiagram);
                document.getElementById('save-diagram').addEventListener('click', saveDiagram);
                document.getElementById('load-diagram').addEventListener('click', loadDiagram);
                
                // Node menu actions
                document.querySelectorAll('.menu-item').forEach(item => {
                    item.addEventListener('click', function() {
                        if (!selectedNode) return;
                        
                        const action = this.dataset.action;
                        
                        switch(action) {
                            case 'details':
                                showNodeDetails(selectedNode);
                                break;
                            case 'addParent':
                                promptAddParent(selectedNode);
                                break;
                            case 'addChild':
                                promptAddChild(selectedNode);
                                break;
                            case 'remove':
                                removeNode(selectedNode);
                                break;
                        }
                        
                        // Hide menu
                        nodeMenu.classList.remove('visible');
                    });
                });
                
                // Close node menu when clicking outside
                document.addEventListener('click', function(event) {
                    if (!nodeMenu.contains(event.target)) {
                        nodeMenu.classList.remove('visible');
                    }
                });
            }
            
            // Filter and search functions
            function performSearch() {
                const searchTerm = searchInput.value.trim().toLowerCase();
                
                if (!searchTerm) {
                    renderStrainList(allStrains);
                    return;
                }
                
                const filteredStrains = allStrains.filter(strain => {
                    const name = (strain.STRAIN || strain.Strain || strain.Name || '').toLowerCase();
                    const breeder = (strain.BREEDER || strain.Breeder || '').toLowerCase();
                    const type = (strain['REG / FEM'] || strain.Type || '').toLowerCase();
                    const parent1 = (strain.PARENT1 || strain.parent1 || '').toLowerCase();
                    const parent2 = (strain.PARENT2 || strain.parent2 || '').toLowerCase();
                    
                    return name.includes(searchTerm) || 
                        breeder.includes(searchTerm) || 
                        type.includes(searchTerm) || 
                        parent1.includes(searchTerm) || 
                        parent2.includes(searchTerm);
                });
                
                renderStrainList(filteredStrains);
            }
            
            function filterStrains(filter) {
                if (filter === 'all') {
                    renderStrainList(allStrains);
                    return;
                }
                
                const filteredStrains = allStrains.filter(strain => {
                    const type = (strain['REG / FEM'] || strain.Type || '').toLowerCase();
                    return type.includes(filter.toLowerCase());
                });
                
                renderStrainList(filteredStrains);
            }
            
            // Node operations
            function showNodeDetails(node) {
                // Find the full strain data
                const strain = allStrains.find(s => s.id === node.id);
                
                if (!strain) {
                    alert(`Details for ${node.name} not available`);
                    return;
                }
                
                const strainName = strain.STRAIN || strain.Strain || strain.Name || 'Unnamed';
                const breeder = strain.BREEDER || strain.Breeder || '';
                const type = strain['REG / FEM'] || strain.Type || '';
                const count = strain.COUNT || strain.Count || '';
                const parent1 = strain.PARENT1 || strain.parent1 || '';
                const parent2 = strain.PARENT2 || strain.parent2 || '';
                
                let details = `Strain: ${strainName}\n`;
                if (breeder) details += `Breeder: ${breeder}\n`;
                if (type) details += `Type: ${type}\n`;
                if (count) details += `Count: ${count}\n`;
                if (parent1) details += `Parent 1: ${parent1}\n`;
                if (parent2) details += `Parent 2: ${parent2}\n`;
                
                alert(details);
            }
            
            function promptAddParent(node) {
                const parentType = prompt('What type of parent? (Female/Male)');
                if (!parentType) return;
                
                const parentName = prompt('Enter parent name:');
                if (!parentName) return;
                
                // Create parent node
                const newId = `parent-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
                const parentNode = {
                    id: newId,
                    name: parentName,
                    type: parentType.toLowerCase() === 'female' ? 'female' : 'male',
                    x: node.x + (Math.random() * 100 - 50),
                    y: node.y - 150
                };
                
                // Add parent to graph
                graph.nodes.push(parentNode);
                
                // Add link from parent to child
                graph.links.push({
                    source: newId,
                    target: node.id,
                    type: parentType.toLowerCase() === 'female' ? 'female' : 'male'
                });
                
                updateGraph();
            }
            
            function promptAddChild(node) {
                const childName = prompt('Enter child strain name:');
                if (!childName) return;
                
                const childType = prompt('Enter child type (REG/FEM/AUTO/etc):');
                
                // Create child node
                const newId = `child-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
                const childNode = {
                    id: newId,
                    name: childName,
                    type: childType || '',
                    x: node.x + (Math.random() * 100 - 50),
                    y: node.y + 150,
                    parent1: node.name
                };
                
                // Add child to graph
                graph.nodes.push(childNode);
                
                // Add link from parent to child
                graph.links.push({
                    source: node.id,
                    target: newId,
                    type: 'parent'
                });
                
                updateGraph();
            }
            
            function removeNode(node) {
                if (!confirm(`Are you sure you want to remove ${node.name} from the diagram?`)) {
                    return;
                }
                
                // Remove node
                graph.nodes = graph.nodes.filter(n => n.id !== node.id);
                
                // Remove any links connected to this node
                graph.links = graph.links.filter(link => 
                    link.source.id !== node.id && link.target.id !== node.id);
                
                selectedNode = null;
                updateGraph();
            }
            
            // Diagram operations
            function newDiagram() {
                if (graph.nodes.length > 0 && !confirm('Are you sure you want to create a new diagram? All unsaved changes will be lost.')) {
                    return;
                }
                
                graph = {
                    nodes: [],
                    links: []
                };
                
                updateGraph();
            }
            
            function saveDiagram() {
                const name = prompt('Name this breeding diagram:');
                if (!name) return;
                
                const diagramData = {
                    name: name,
                    date: new Date().toISOString(),
                    data: graph
                };
                
                // Get existing saved diagrams
                let savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
                
                // Add or update
                const existingIndex = savedDiagrams.findIndex(d => d.name === name);
                if (existingIndex >= 0) {
                    savedDiagrams[existingIndex] = diagramData;
                } else {
                    savedDiagrams.push(diagramData);
                }
                
                // Save to local storage
                localStorage.setItem('breedingDiagrams', JSON.stringify(savedDiagrams));
                
                alert(`Diagram "${name}" saved successfully!`);
            }
            
            function loadDiagram() {
                // Get saved diagrams
                const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
                
                if (savedDiagrams.length === 0) {
                    alert('No saved diagrams found.');
                    return;
                }
                
                // Create list of saved diagrams
                let diagramList = 'Select a diagram to load:\n';
                savedDiagrams.forEach((diagram, index) => {
                    const date = new Date(diagram.date).toLocaleDateString();
                    diagramList += `${index + 1}. ${diagram.name} (${date})\n`;
                });
                
                const selection = prompt(diagramList);
                if (!selection) return;
                
                const index = parseInt(selection) - 1;
                if (isNaN(index) || index < 0 || index >= savedDiagrams.length) {
                    alert('Invalid selection.');
                    return;
                }
                
                const selectedDiagram = savedDiagrams[index];
                
                // If current diagram has changes, confirm
                if (graph.nodes.length > 0 && !confirm('Loading a new diagram will replace the current one. Continue?')) {
                    return;
                }
                
                // Load the selected diagram
                graph = selectedDiagram.data;
                
                updateGraph();
                alert(`Diagram "${selectedDiagram.name}" loaded successfully!`);
            }
        });
    </script>
</body>
</html>
