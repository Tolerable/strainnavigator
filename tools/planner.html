<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/dagre/0.8.5/dagre.min.js"></script>
    <title>StrainNavigator Breeding Planner</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #2d2d2d;
            color: #fff;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #1a3c20, #2d5e32);
            color: white;
            padding: 5px 20px;
            text-align: center;
        }
        
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .sidebar {
            width: 300px;
            background-color: #333;
            border-right: 1px solid #444;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
		.sidebar-header {
			padding: 10px;
			border-bottom: 1px solid #444;
			background-color: #282828;
			position: relative;
			display: flex;
			align-items: center;
			justify-content: space-between;
		}

		.sidebar-header h3 {
			margin: 0;
			font-size: 16px;
		}

		/* For the manage button */
		.sidebar-header .btn-secondary {
			position: static; /* Remove absolute positioning */
			padding: 4px 8px;
			font-size: 12px;
		}
        
        .search-box {
            display: flex;
            padding: 10px;
            border-bottom: 1px solid #444;
        }
        
        .search-box input {
            flex: 1;
            padding: 8px;
            border: 1px solid #555;
            background-color: #222;
            color: #fff;
            border-radius: 4px 0 0 4px;
        }
        
        .search-box button {
            padding: 8px 15px;
            background-color: #2d5e32;
            color: white;
            border: none;
            border-radius: 0 4px 4px 0;
            cursor: pointer;
        }

		.saved-plan-item.selected-plan {
			background-color: #444;
		}
        
		.filter-tabs {
			display: flex;
			border-bottom: 1px solid #444;
			background-color: #282828;
			overflow-x: hidden;
			justify-content: space-between;
		}

		.filter-tab {
			padding: 8px 0;
			cursor: pointer;
			white-space: nowrap;
			font-size: 12px;
			font-weight: 500;
			flex: 1;
			text-align: center;
		}
        
        .filter-tab.active {
            background-color: #5d4a7e;
            color: white;
        }
        
        .strain-list {
            flex: 1;
            overflow-y: auto;
            background-color: #333;
        }
        
        .strain-item {
            padding: 10px 15px;
            border-bottom: 1px solid #444;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .strain-item:hover {
            background-color: #444;
        }
        
        .strain-info {
            display: flex;
            flex-direction: column;
        }
        
        .strain-name {
            font-weight: 500;
            color: #fff;
        }
        
        .strain-type {
            font-size: 12px;
            margin-top: 2px;
            display: flex;
            gap: 5px;
        }
        
        .strain-tag {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            color: white;
            font-weight: 600;
        }
        
        .tag-reg { background-color: #9575cd; }
        .tag-fem { background-color: #f06292; }
        .tag-auto { background-color: #ffb74d; }
        .tag-photo { background-color: #4db6ac; }
        .tag-fast { background-color: #4fc3f7; }
        
        .strain-count {
            background-color: rgba(93, 74, 126, 0.3);
            color: #b39ddb;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
        }

		.strain-trait.photo {
			background-color: #4db6ac;
		}

		.strain-trait.auto {
			background-color: #ffb74d;
		}

		.strain-trait.reg {
			background-color: #9575cd;
		}

		.strain-trait.fem {
			background-color: #f06292;
		}

		.strain-trait.fast {
			background-color: #4fc3f7;
		}
        
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: auto;
            background-color: #2d2d2d;
        }
        
		.canvas-tools {
			position: fixed;
			top: 85px; /* Increased from 70px to add more space from header */
			left: 310px;
			z-index: 100;
			display: flex;
			gap: 5px;
			background-color: rgba(0,0,0,0.5);
			padding: 5px;
			border-radius: 4px;
		}
        
        .canvas-tool {
            background-color: #333;
            border: 1px solid #444;
            color: #fff;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
        }
        
        .canvas-tool:hover {
            background-color: #444;
        }
        
		.arrange-options {
			position: fixed;
			top: 85px; /* Increased from 70px to add more space from header */
			right: 10px;
			z-index: 100;
			display: flex;
			gap: 5px;
			background-color: rgba(0,0,0,0.5);
			padding: 5px;
			border-radius: 4px;
		}
        
        /* Strain nodes and connections */
        .breeding-canvas {
            position: relative;
            width: 3000px;
            height: 2000px;
        }
        
		/* Node styling for ComfyUI-like appearance */
		.breeding-node {
			background-color: #333333;
			border-radius: 6px;
			min-width: 160px;
			box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
			user-select: none;
			position: absolute;
			z-index: 10;
			border: 1px solid #444;
			color: #fff;
		}

		.strain-node {
			border-left: 3px solid #FFB74D;
		}

		.cross-node {
			border-left: 3px solid #9C27B0;
		}

		.node-header {
			background-color: #222;
			border-bottom: 1px solid #444;
			padding: 8px 10px;
			font-weight: 600;
			border-radius: 6px 6px 0 0;
			display: flex;
			justify-content: space-between;
		}

		.node-content {
			padding: 10px;
		}

		.node-traits {
			display: flex;
			flex-wrap: wrap;
			gap: 5px;
			margin-bottom: 8px;
		}

		.strain-trait {
			padding: 2px 6px;
			border-radius: 3px;
			font-size: 11px;
			font-weight: 500;
			color: white;
		}

        
        .breeding-node.selected {
            box-shadow: 0 0 0 3px #ffeb3b;
        }
        
        .node-name {
            font-weight: 600;
            word-break: break-word;
        }
        
        .node-controls {
            display: flex;
            gap: 5px;
        }
        
        .node-control {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            cursor: pointer;
            background-color: rgba(0, 0, 0, 0.1);
            color: #333;
        }
        
        .node-control:hover {
            background-color: rgba(0, 0, 0, 0.2);
        }
        
        .node-type {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .node-type span {
            background-color: #eee;
            padding: 2px 6px;
            border-radius: 3px;
            margin-right: 3px;
        }
        
		.connection-points {
			display: flex;
			justify-content: space-around;
			padding: 8px 0;
			margin-top: 5px;
		}

		/* Connection ports styling */
		.connection-input {
			display: flex;
			justify-content: center;
			position: absolute;
			width: 100%;
			top: -10px;
		}

		.connection-outputs {
			display: flex;
			justify-content: space-around;
			padding: 5px 0;
			margin-top: 5px;
			border-top: 1px solid #444;
		}

		.connection-output {
			display: flex;
			flex-direction: column;
			align-items: center;
			padding: 0 10px;
		}

		.connection-label {
			font-size: 12px;
			margin-bottom: 3px;
			color: #bbb;
		}

		.connection-point {
			width: 12px;
			height: 12px;
			border-radius: 50%;
			cursor: pointer;
			border: 2px solid #fff;
		}

		.connection-point-female {
			background-color: #e091b9;
		}

		.connection-point-male {
			background-color: #91b7e0;
		}

		.connection-point:hover {
			transform: scale(1.2);
			box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
		}

		.connection-point-input {
			background-color: #4CAF50;
			top: -5px;
		}

		/* Connection line styling */
		.connector {
			stroke-linecap: round;
			filter: drop-shadow(0 0 3px rgba(0, 0, 0, 0.3));
		}
        
        /* Node types */
        .breeding-node.reg {
            border-top: 4px solid #9575cd;
        }
        
        .breeding-node.fem {
            border-top: 4px solid #f06292;
        }
        
        .breeding-node.auto {
            border-top: 4px solid #ffb74d;
        }
        
        .breeding-node.photo {
            border-top: 4px solid #4db6ac;
        }
        
        .breeding-node.fast {
            border-top: 4px solid #4fc3f7;
        }
        
        .breeding-node.cross {
            border-top: 4px solid #673ab7;
            background-color: rgba(237, 231, 246, 0.9);
        }
        
        /* SVG Connector styling */
        .connection-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        
		.connector {
			stroke-linecap: round;
			stroke-linejoin: round;
			filter: drop-shadow(0 0 3px rgba(0, 0, 0, 0.3));
		}

		.connector-female {
			stroke: #e091b9;
		}

		.connector-male {
			stroke: #91b7e0;
		}
        
        .connector-highlight {
            stroke: #673ab7;
            stroke-width: 3;
        }

		.type-selection {
			display: flex;
			flex-direction: column;
			gap: 12px;
		}

		.type-group {
			display: flex;
			flex-direction: column;
			gap: 5px;
		}

		.type-group > div {
			display: flex;
			gap: 15px;
		}

		.type-group label {
			display: flex;
			align-items: center;
			gap: 5px;
			cursor: pointer;
			color: #ddd;
		}

		.type-group input[type="radio"],
		.type-group input[type="checkbox"] {
			margin: 0;
			cursor: pointer;
		}
        
        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        
        .modal.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
		.modal-content {
			background-color: #333;
			border-radius: 8px;
			width: 350px; /* Reduced from 400px */
			max-width: 90vw;
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
			display: flex;
			flex-direction: column;
			border: 1px solid #444;
			overflow: hidden; /* Ensure content doesn't overflow */
		}
        
        .modal-header {
            padding: 15px;
            border-bottom: 1px solid #444;
            font-weight: 600;
            color: #fff;
        }
        
		.modal-body {
			padding: 15px;
			max-height: 70vh;
			overflow-y: auto;
			color: #ddd;
			box-sizing: border-box; /* Ensure padding is included in size calculation */
		}
        
        .modal-footer {
            padding: 15px;
            border-top: 1px solid #444;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        .btn {
            padding: 8px 16px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-weight: 500;
        }
        
        .btn-primary {
            background-color: #2d5e32;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #1a3c20;
        }
        
        .btn-secondary {
            background-color: #444;
            color: #fff;
        }
        
        .btn-secondary:hover {
            background-color: #555;
        }

		.btn-danger {
			background-color: #d32f2f;
			color: white;
		}

		.btn-danger:hover {
			background-color: #b71c1c;
		}
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #ccc;
        }
        
		.form-input {
			width: 100%;
			padding: 8px;
			border: 1px solid #555;
			background-color: #222;
			color: #fff;
			border-radius: 4px;
			box-sizing: border-box; /* Ensure padding is included in width */
			max-width: 100%; /* Ensure it doesn't exceed container */
		}
        
        .form-input:focus {
            border-color: #5d4a7e;
            outline: none;
        }
        
		.help-text {
			position: fixed;
			bottom: 10px;
			left: 310px;
			background-color: rgba(0, 0, 0, 0.7);
			color: #fff;
			padding: 10px 30px 10px 10px;
			border-radius: 4px;
			font-size: 12px;
			max-width: 300px;
			box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
			z-index: 50;
		}

		.help-text-close {
			position: absolute;
			right: 5px;
			top: 5px;
			width: 20px;
			height: 20px;
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			border-radius: 50%;
			background: rgba(255,255,255,0.2);
		}

		.help-text-close:hover {
			background: rgba(255,255,255,0.3);
		}
        
        /* Context menu */
        .context-menu {
            position: absolute;
            background-color: #333;
            border: 1px solid #444;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 100;
            min-width: 150px;
            display: none;
        }
        
        .context-menu.visible {
            display: block;
        }
        
        .menu-item {
            padding: 8px 12px;
            cursor: pointer;
            color: #ddd;
        }
        
        .menu-item:hover {
            background-color: #444;
        }
        
        .menu-divider {
            height: 1px;
            background-color: #444;
            margin: 4px 0;
        }
		
		/* Status styling */
		.breeding-node.status-planned { border-left: 3px solid #FFB74D; }
		.breeding-node.status-in-progress { border-left: 3px solid #42A5F5; }
		.breeding-node.status-completed { border-left: 3px solid #66BB6A; }

		.status-indicator {
			display: flex;
			align-items: center;
			margin-top: 8px;
			padding-top: 8px;
			border-top: 1px solid #444;
			font-size: 12px;
		}

		.status-dot {
			width: 8px;
			height: 8px;
			border-radius: 50%;
			margin-right: 6px;
		}

		.status-dot.planned { background-color: #FFB74D; }
		.status-dot.in-progress { background-color: #42A5F5; }
		.status-dot.completed { background-color: #66BB6A; }

		.status-toggle {
			margin-left: auto;
			cursor: pointer;
			color: #aaa;
			font-size: 11px;
			text-decoration: underline;
		}

		.status-toggle:hover {
			color: #fff;
		}

		#auto-save-indicator {
			opacity: 0;
			pointer-events: none;
		}

		.minimal-view .connector-female {
			stroke-dasharray: none;
		}

		.minimal-view .connector-male {
			stroke-dasharray: none;
		}

		.minimal-view .connector {
			stroke-width: 3px;
		}

		.minimal-view .breeding-node {
		  min-width: 120px;
		  min-height: 28px;
		  margin: 0;
		}

		.minimal-view .node-header {
		  padding: 4px 8px;
		  font-size: 11px;
		  line-height: 1.2;
		}

		.minimal-view .connection-points {
		  padding: 2px 0;
		  height: auto;
		  width: 100%;
		  position: relative;
		}

		.minimal-view .connection-point {
		  width: 10px;
		  height: 4px;
		  border-radius: 1px;
		}
		
    </style>
</head>
<body>
<header>
    <h2>StrainNavigator Breeding Planner</h2>
</header>

	<div class="main-container">
		<div class="sidebar">
			<div class="sidebar-header">
				<h3>Strain Collection</h3>
			</div>
			
			<div class="search-box">
				<input type="text" id="search-input" placeholder="Search strains...">
				<button id="search-btn">Search</button>
			</div>
			
			<div class="sheet-url-container" style="padding: 10px; border-bottom: 1px solid #444;">
				<div style="margin-bottom: 8px; font-weight: 500;">Google Sheet URL</div>
				<div style="display: flex; margin-bottom: 8px;">
					<input type="text" id="sheet-url-input" class="form-input" style="flex: 1;" 
						   placeholder="Enter Google Sheets URL...">
					<button id="load-sheet-btn" class="btn btn-primary" style="margin-left: 5px;">Load</button>
				</div>
				<div id="sheet-url-info" style="font-size: 12px; color: #aaa;">
					Required columns: STRAIN, REG / FEM, BREEDER, COUNT, PARENT1, PARENT2
				</div>
			</div>
			
			<div class="filter-tabs">
				<div class="filter-tab active" data-filter="all">ALL</div>
				<div class="filter-tab" data-filter="reg">REG</div>
				<div class="filter-tab" data-filter="fem">FEM</div>
				<div class="filter-tab" data-filter="auto">AUTO</div>
				<div class="filter-tab" data-filter="photo">PHOTO</div>
				<div class="filter-tab" data-filter="fast">FAST</div>
			</div>
			
			<div class="strain-list" id="strain-list">
				<!-- Strains will be loaded here -->
				<div class="strain-item">
					<div class="strain-info">
						<div class="strain-name">Loading strains...</div>
					</div>
				</div>
			</div>
		</div>
		
		<div class="canvas-container" id="canvas-container">
			<div class="canvas-tools">
				<button class="canvas-tool" id="new-diagram">New</button>
				<button class="canvas-tool" id="save-diagram">Save</button>
				<button class="canvas-tool" id="load-diagram">Load</button>
			</div>
			
			<div class="arrange-options">
				<button class="canvas-tool" id="arrange-tree">Arrange Tree</button>
				<button class="canvas-tool" id="center-view">Center View</button>
			</div>
			
			<div class="breeding-canvas" id="breeding-canvas">
				<!-- SVG for connections -->
				<svg class="connection-svg" id="connection-svg">
					<defs>
						<marker id="arrow-female" viewBox="0 0 10 10" refX="8" refY="5" 
								markerWidth="6" markerHeight="6" orient="auto-start-reverse">
							<path d="M 0 0 L 10 5 L 0 10 z" fill="#E91E63"/>
						</marker>
						<marker id="arrow-male" viewBox="0 0 10 10" refX="8" refY="5" 
								markerWidth="6" markerHeight="6" orient="auto-start-reverse">
							<path d="M 0 0 L 10 5 L 0 10 z" fill="#2196F3"/>
						</marker>
					</defs>
					<g id="connections-group"></g>
				</svg>
				<!-- Nodes will be added here -->
			</div>
			
			<div class="help-text">
				Click on strains to add them to the diagram. Connect strains by dragging from one connection point to another. Right-click nodes for more options.
				<div class="help-text-close">×</div>
			</div>
		</div>
	</div>

	<!-- Saved Sheets Modal -->
	<div class="modal" id="saved-sheets-modal">
		<div class="modal-content">
			<div class="modal-header">Manage Strain Collections</div>
			<div class="modal-body">
				<div id="saved-sheets-list">
					Loading saved strain collections...
				</div>
			</div>
			<div class="modal-footer">
				<button class="btn btn-danger" id="delete-sheet-btn">Delete</button>
				<button class="btn btn-secondary" id="cancel-sheets-btn">Cancel</button>
				<button class="btn btn-primary" id="load-sheet-from-list-btn">Load Collection</button>
			</div>
		</div>
	</div>

	<!-- Name Cross Modal -->
	<div class="modal" id="name-cross-modal">
		<div class="modal-content">
			<div class="modal-header">Name Your Cross</div>
			<div class="modal-body">
				<div class="form-group">
					<label class="form-label">Parents</label>
					<div id="cross-parents" style="color: #aaa;"></div>
				</div>
				<div class="form-group">
					<label class="form-label">Default Name</label>
					<div id="default-cross-name" style="color: #fff;"></div>
				</div>
				<div class="form-group">
					<label class="form-label">Custom Name (optional)</label>
					<input type="text" class="form-input" id="custom-cross-name" placeholder="Enter a custom name">
				</div>
				<div class="form-group" id="cross-type-container">
					<!-- Type selection will be inserted here -->
					<div class="type-selection">
						<div class="type-group">
							<label><strong>Growth Type:</strong></label>
							<div>
								<label><input type="radio" name="growth-type" value="AUTO"> AUTO</label>
								<label><input type="radio" name="growth-type" value="PHOTO" checked> PHOTO</label>
							</div>
						</div>
						
						<div class="type-group">
							<label><strong>Seed Type:</strong></label>
							<div>
								<label><input type="radio" name="seed-type" value="REG" checked> REG</label>
								<label><input type="radio" name="seed-type" value="FEM"> FEM</label>
							</div>
						</div>
						
						<div class="type-group">
							<label><strong>Flowering Type:</strong></label>
							<div>
								<label><input type="checkbox" name="flowering-type" value="FAST"> FAST</label>
							</div>
						</div>
						
						<!-- New status selection -->
						<div class="type-group">
							<label><strong>Status:</strong></label>
							<div>
								<label><input type="radio" name="cross-status" value="planned" checked> Planned</label>
								<label><input type="radio" name="cross-status" value="in-progress"> In Progress</label>
								<label><input type="radio" name="cross-status" value="completed"> Completed</label>
							</div>
						</div>
					</div>
				</div>
			</div>
			<div class="modal-footer">
				<button class="btn btn-secondary" id="cancel-cross-btn">Cancel</button>
				<button class="btn btn-primary" id="create-cross-btn">Create Cross</button>
			</div>
		</div>
	</div>

	<!-- Save/Load Modals -->
	<div class="modal" id="save-diagram-modal">
		<div class="modal-content">
			<div class="modal-header">Save Breeding Plan</div>
			<div class="modal-body">
				<div class="form-group">
					<label class="form-label">Plan Name</label>
					<input type="text" class="form-input" id="diagram-name" placeholder="Enter a name for this breeding plan">
				</div>
				<div class="form-group">
					<label class="form-label">Notes (optional)</label>
					<textarea class="form-input" id="diagram-notes" rows="4" placeholder="Enter any notes about this breeding plan"></textarea>
				</div>
			</div>
			<div class="modal-footer">
				<button class="btn btn-secondary" id="cancel-save-btn">Cancel</button>
				<button class="btn btn-primary" id="confirm-save-btn">Save Plan</button>
			</div>
		</div>
	</div>

	<!-- Load Diagram Modal -->
	<div class="modal" id="load-diagram-modal">
		<div class="modal-content">
			<div class="modal-header">Load Breeding Plan</div>
			<div class="modal-body">
				<div id="saved-diagrams-list">
					Loading saved plans...
				</div>
			</div>
			<div class="modal-footer">
				<button class="btn btn-danger" id="delete-plan-btn">Delete</button>
				<button class="btn btn-secondary" id="rename-plan-btn">Rename</button>
				<button class="btn btn-secondary" id="cancel-load-btn">Cancel</button>
				<button class="btn btn-primary" id="confirm-load-btn">Load Plan</button>
			</div>
		</div>
	</div>

	<!-- Delete Plan Confirmation Modal -->
	<div class="modal" id="delete-plan-modal">
		<div class="modal-content">
			<div class="modal-header">Delete Breeding Plan</div>
			<div class="modal-body">
				<div class="form-group">
					<label class="form-label">Are you sure you want to delete this breeding plan?</label>
					<div id="delete-plan-name" style="color: #fff; font-weight: bold;"></div>
				</div>
				<div class="form-group">
					<label class="form-label" style="color: #f44336;">This action cannot be undone.</label>
				</div>
			</div>
			<div class="modal-footer">
				<button class="btn btn-secondary" id="cancel-delete-btn">Cancel</button>
				<button class="btn btn-danger" id="confirm-delete-btn">Delete</button>
			</div>
		</div>
	</div>

	<!-- Rename Plan Modal -->
	<div class="modal" id="rename-plan-modal">
		<div class="modal-content">
			<div class="modal-header">Rename Breeding Plan</div>
			<div class="modal-body">
				<div class="form-group">
					<label class="form-label">Current Name</label>
					<div id="rename-plan-current-name" style="color: #aaa;"></div>
				</div>
				<div class="form-group">
					<label class="form-label">New Name</label>
					<input type="text" class="form-input" id="rename-plan-input" placeholder="Enter new name">
				</div>
			</div>
			<div class="modal-footer">
				<button class="btn btn-secondary" id="cancel-rename-btn">Cancel</button>
				<button class="btn btn-primary" id="confirm-rename-btn">Rename</button>
			</div>
		</div>
	</div>

	<!-- Context Menu -->
	<div class="context-menu" id="node-context-menu">
		<div class="menu-item" id="context-edit">Edit Node</div>
		<div class="menu-item" id="context-duplicate">Duplicate</div>
		<div class="menu-divider"></div>
		<div class="menu-item" id="context-remove">Remove Node</div>
	</div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Configuration
            const sheetId = '1A7kFjfw6cjmQQOwz-5liWVGgFK0K5lwS8AfIZ_Zthbg';
            const nodeSpacing = {
                horizontal: 250,
                vertical: 120
            };
            
            // DOM Elements
            const strainList = document.getElementById('strain-list');
            const searchInput = document.getElementById('search-input');
            const searchBtn = document.getElementById('search-btn');
            const filterTabs = document.querySelectorAll('.filter-tab');
            
            const canvasContainer = document.getElementById('canvas-container');
            const breedingCanvas = document.getElementById('breeding-canvas');
            const connectionsSvg = document.getElementById('connection-svg');
            const connectionsGroup = document.getElementById('connections-group');
            
            // Buttons
            const newDiagramBtn = document.getElementById('new-diagram');
            const saveDiagramBtn = document.getElementById('save-diagram');
            const loadDiagramBtn = document.getElementById('load-diagram');
            const arrangeTreeBtn = document.getElementById('arrange-tree');
            const centerViewBtn = document.getElementById('center-view');
            
            // Modals
            const nameCrossModal = document.getElementById('name-cross-modal');
            const crossParents = document.getElementById('cross-parents');
            const defaultCrossName = document.getElementById('default-cross-name');
            const customCrossName = document.getElementById('custom-cross-name');
            const crossType = document.getElementById('cross-type');
            const cancelCrossBtn = document.getElementById('cancel-cross-btn');
            const createCrossBtn = document.getElementById('create-cross-btn');
            
            const saveDiagramModal = document.getElementById('save-diagram-modal');
            const diagramName = document.getElementById('diagram-name');
            const diagramNotes = document.getElementById('diagram-notes');
            const cancelSaveBtn = document.getElementById('cancel-save-btn');
            const confirmSaveBtn = document.getElementById('confirm-save-btn');
            
            const loadDiagramModal = document.getElementById('load-diagram-modal');
            const savedDiagramsList = document.getElementById('saved-diagrams-list');
            const cancelLoadBtn = document.getElementById('cancel-load-btn');
            const confirmLoadBtn = document.getElementById('confirm-load-btn');
            const renamePlanModal = document.getElementById('rename-plan-modal');
			
            // Context Menu
            const nodeContextMenu = document.getElementById('node-context-menu');
            const contextEdit = document.getElementById('context-edit');
            const contextDuplicate = document.getElementById('context-duplicate');
            const contextRemove = document.getElementById('context-remove');
            
            // State
            let allStrains = [];
            let nodes = [];
            let connections = [];
            let nodeCounter = 0;
            let selectedNode = null;
            let connecting = false;
            let connectingSourceNode = null;
            let contextMenuTargetNode = null;
            let tempLine = null;
            let pendingCrossData = null;
            let selectedDiagramIndex = -1;
            
            // Pan & Zoom state
            let isPanning = false;
            let panStart = { x: 0, y: 0 };
            let canvasOffset = { x: 0, y: 0 };

			// Check for saved active sheet ID
			let activeSheetId = localStorage.getItem('breedingPlannerActiveSheetId') || sheetId;
			let savedSheets = []; // To store multiple sheets
			
            // Initialize
            initializeCanvas();
			initializeSheetManager();
            loadStrains();
            setupEventListeners();

			// Add minimal view toggle
			addMinimalViewToggle();

			// Initialize position storage objects
			if (!window.normalPositions) window.normalPositions = {};
			if (!window.minimalPositions) window.minimalPositions = {};
	
            // Functions
            function initializeCanvas() {
                // Set initial canvas position
                centerCanvas();
                
                // Update SVG size
                updateSvgSize();
            }
            
            function centerCanvas() {
                canvasOffset.x = (canvasContainer.clientWidth - breedingCanvas.clientWidth) / 2;
                canvasOffset.y = (canvasContainer.clientHeight - breedingCanvas.clientHeight) / 2;
                updateCanvasPosition();
            }
            
            function updateCanvasPosition() {
                breedingCanvas.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px)`;
            }
            
            function updateSvgSize() {
                connectionsSvg.setAttribute('width', breedingCanvas.clientWidth);
                connectionsSvg.setAttribute('height', breedingCanvas.clientHeight);
            }

			function initializeSheetManager() {
				// Load any saved sheets from localStorage
				savedSheets = JSON.parse(localStorage.getItem('breedingPlannerSheets') || '[]');
				
				// Add the default sheet if not already saved
				if (!savedSheets.some(sheet => sheet.id === sheetId)) {
					savedSheets.push({
						id: sheetId,
						name: 'Default Strain Collection',
						url: `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv`,
						isDefault: true
					});
					saveSheetsList();
				}
				
				// Setup UI elements
				const sheetUrlInput = document.getElementById('sheet-url-input');
				const loadSheetBtn = document.getElementById('load-sheet-btn');
				
				loadSheetBtn.addEventListener('click', function() {
					loadCustomSheet();
				});
				
				sheetUrlInput.addEventListener('keyup', function(e) {
					if (e.key === 'Enter') {
						loadCustomSheet();
					}
				});
			}

			function toggleMinimalView() {
			  isMinimalView = !isMinimalView;
			  document.getElementById('breeding-canvas').classList.toggle('minimal-view', isMinimalView);
			  updateToggleButton();
			  
			  // Add delay before arranging tree to allow class changes to take effect
			  setTimeout(() => {
				arrangeTreeLayout(); // Re-arrange the entire tree when toggling view
			  }, 100);
			}

			function loadCustomSheet() {
				const sheetUrlInput = document.getElementById('sheet-url-input');
				const url = sheetUrlInput.value.trim();
				
				if (!url) {
					alert('Please enter a valid Google Sheets URL');
					return;
				}
				
				// Extract sheet ID from URL
				let newSheetId = '';
				const regex = /\/d\/([a-zA-Z0-9-_]+)/;
				const match = url.match(regex);
				
				if (match && match[1]) {
					newSheetId = match[1];
				} else {
					alert('Invalid Google Sheets URL. Please use a sharing URL from Google Sheets.');
					return;
				}
				
				// Check if this sheet is already saved
				const existingSheet = savedSheets.find(sheet => sheet.id === newSheetId);
				
				if (!existingSheet) {
					// Add new sheet to saved sheets
					const sheetName = prompt('Enter a name for this strain collection:', 'My Strain Collection');
					if (!sheetName) return;
					
					savedSheets.push({
						id: newSheetId,
						name: sheetName,
						url: `https://docs.google.com/spreadsheets/d/${newSheetId}/export?format=csv`,
						isDefault: false
					});
					
					saveSheetsList();
				}
				
				// Set as active sheet and load strains
				activeSheetId = newSheetId;
				loadStrainsFromSheet(newSheetId);
				
				// Clear input
				sheetUrlInput.value = '';
			}

			function saveSheetsList() {
				localStorage.setItem('breedingPlannerSheets', JSON.stringify(savedSheets));
			}

			function loadStrainsFromSheet(sheetId) {
				strainList.innerHTML = '<div class="strain-item"><div class="strain-info"><div class="strain-name">Loading strains...</div></div></div>';
				
				const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv`;
				
				fetch(csvUrl)
					.then(response => {
						if (!response.ok) throw new Error('Network error');
						return response.text();
					})
					.then(csv => {
						allStrains = parseCSV(csv);
						renderStrainList(allStrains);
						updateExistingNodesWithParents();
						
						// Save active sheet ID to localStorage
						activeSheetId = sheetId;
						saveActiveSheetId();
					})
					.catch(error => {
						console.error('Error loading data:', error);
						strainList.innerHTML = '<div class="strain-item"><div class="strain-info"><div class="strain-name">Error loading strains</div></div></div>';
						alert('Error loading sheet. Please check that the Google Sheet is publicly shared with "Anyone with the link" and try again.');
					});
			}
            
			function loadStrains() {
				// Now just call the other function with the active sheet ID
				loadStrainsFromSheet(activeSheetId);
			}
            
			// First, add the missing parseCSVLine function
			function parseCSVLine(line) {
				let results = [];
				let currentValue = '';
				let inQuotes = false;
				
				for (let i = 0; i < line.length; i++) {
					const char = line[i];
					
					if (char === '"') {
						inQuotes = !inQuotes;
					} else if (char === ',' && !inQuotes) {
						results.push(currentValue);
						currentValue = '';
					} else {
						currentValue += char;
					}
				}
				
				results.push(currentValue);
				return results;
			}

			function addMinimalViewToggle() {
				// Check if the toggle already exists
				if (document.getElementById('toggle-minimal-view')) {
					return; // Don't create duplicates
				}
				
				const minimalViewBtn = document.createElement('button');
				minimalViewBtn.className = 'canvas-tool';
				minimalViewBtn.id = 'toggle-minimal-view';
				minimalViewBtn.innerHTML = 'Minimal View <span class="toggle-indicator">◻</span>';
				document.querySelector('.canvas-tools').appendChild(minimalViewBtn);
				
				// Track state
				let isMinimalView = false;
				
				// Toggle button style based on state
				function updateToggleButton() {
					const indicator = minimalViewBtn.querySelector('.toggle-indicator');
					if (isMinimalView) {
						indicator.textContent = '☑';
						minimalViewBtn.style.backgroundColor = '#5d4a7e';
					} else {
						indicator.textContent = '◻';
						minimalViewBtn.style.backgroundColor = '';
					}
				}
				
				// Add CSS for minimal view
				const styleElement = document.createElement('style');
				styleElement.id = 'minimal-view-styles';
				styleElement.textContent = `
				  .minimal-view .breeding-node .node-content {
					display: none;
				  }
				  
				  .minimal-view .breeding-node .connection-points {
					margin-top: 0;
				  }
				  
				  .minimal-view .breeding-node {
					min-width: 120px;
				  }
				  
				  /* New styles for cleaner connection points */
				  .minimal-view .connection-point {
					height: 4px;
					width: 12px;
					border-radius: 0;
				  }
				  
				  .minimal-view .connection-point-female {
					border-color: #e091b9;
				  }
				  
				  .minimal-view .connection-point-male {
					border-color: #91b7e0;
				  }
				  
				  .minimal-view .node-header {
					font-size: 12px;
					padding: 4px 8px;
				  }
				  
				  .minimal-view .connection-points {
					padding: 3px 0;
				  }
				  
				  /* Status indicators */
				  .minimal-view .status-completed::after { background-color: #66BB6A; }
				  .minimal-view .status-in-progress::after { background-color: #42A5F5; }
				  .minimal-view .status-planned::after { background-color: #FFB74D; }
				`;
				document.head.appendChild(styleElement);
				
				// Toggle event handler
				minimalViewBtn.addEventListener('click', function() {
					// Save current positions before switching
					if (isMinimalView) {
						saveCurrentPositions('minimal');
					} else {
						saveCurrentPositions('normal');
					}
					
					// Toggle view
					isMinimalView = !isMinimalView;
					document.getElementById('breeding-canvas').classList.toggle('minimal-view', isMinimalView);
					updateToggleButton();
					
					// Apply saved positions or calculate new ones
					if (isMinimalView) {
						if (hasStoredPositions('minimal')) {
							applyStoredPositions('minimal');
						} else {
							scaleNodesCloser(0.65);
						}
					} else {
						if (hasStoredPositions('normal')) {
							applyStoredPositions('normal');
						} else {
							resetNodePositions();
						}
					}
					
					updateAllConnections();
				});
			}

			function saveCurrentPositions(mode) {
				const positions = mode === 'minimal' ? window.minimalPositions : window.normalPositions;
				nodes.forEach(node => {
					const el = document.getElementById(node.id);
					if (el) {
						positions[node.id] = {
							left: parseInt(el.style.left),
							top: parseInt(el.style.top)
						};
					}
				});
			}

			function hasStoredPositions(mode) {
				const positions = mode === 'minimal' ? window.minimalPositions : window.normalPositions;
				return Object.keys(positions).length > 0;
			}

			function applyStoredPositions(mode) {
				const positions = mode === 'minimal' ? window.minimalPositions : window.normalPositions;
				nodes.forEach(node => {
					const el = document.getElementById(node.id);
					const pos = positions[node.id];
					if (el && pos) {
						el.style.left = pos.left + "px";
						el.style.top = pos.top + "px";
					}
				});
			}

			function scaleNodesCloser(scaleFactor) {
				// Store original positions if not already saved
				if (!window.originalPositions) {
					window.originalPositions = {};
					nodes.forEach(node => {
						const el = document.getElementById(node.id);
						if (el) {
							window.originalPositions[node.id] = {
								left: parseInt(el.style.left),
								top: parseInt(el.style.top)
							};
						}
					});
				}
				
				// Calculate center of all nodes
				let centerX = 0, centerY = 0, count = 0;
				nodes.forEach(node => {
					const pos = window.originalPositions[node.id];
					if (pos) {
						centerX += pos.left;
						centerY += pos.top;
						count++;
					}
				});
				centerX /= count;
				centerY /= count;
				
				// Scale positions toward center
				nodes.forEach(node => {
					const el = document.getElementById(node.id);
					const pos = window.originalPositions[node.id];
					if (el && pos) {
						const dx = pos.left - centerX;
						const dy = pos.top - centerY;
						el.style.left = Math.round(centerX + dx * scaleFactor) + "px";
						el.style.top = Math.round(centerY + dy * scaleFactor) + "px";
					}
				});
			}

			function resetNodePositions() {
				if (window.originalPositions) {
					nodes.forEach(node => {
						const el = document.getElementById(node.id);
						const pos = window.originalPositions[node.id];
						if (el && pos) {
							el.style.left = pos.left + "px";
							el.style.top = pos.top + "px";
						}
					});
				}
			}

			// Then, use our simplified parseCSV function
			function parseCSV(csv) {
				const lines = csv.split('\n');
				
				// Skip the header row - we'll assume a fixed column structure
				// Expected columns in order: STRAIN, REG/FEM, BREEDER, COUNT, PARENT1, PARENT2
				
				const result = [];
				// Start from line 1 (skipping header)
				for (let i = 1; i < lines.length; i++) {
					if (!lines[i].trim()) continue;
					
					// Handle quoted fields with commas
					const values = parseCSVLine(lines[i]);
					
					// Skip if first value is empty or matches header
					if (values.length < 2 || !values[0].trim()) continue;
					if (values[0].trim().toUpperCase() === 'STRAIN' || values[0].trim() === 'Unnamed Seed') continue;
					
					// Create entry with fixed column mapping regardless of headers
					const entry = {
						'STRAIN': values[0]?.trim() || '',
						'REG / FEM': values[1]?.trim() || '',
						'BREEDER': values[2]?.trim() || '',
						'COUNT': values[3]?.trim() || '',
						'PARENT1': values[4]?.trim() || '',
						'PARENT2': values[5]?.trim() || '',
						'id': `strain-${i}`
					};
					
					result.push(entry);
				}
				
				return result;
			}

			// Show delete plan confirmation modal
			function showDeletePlanModal() {
				const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
				
				if (selectedDiagramIndex < 0 || selectedDiagramIndex >= savedDiagrams.length) {
					alert('Please select a breeding plan to delete.');
					return;
				}
				
				const plan = savedDiagrams[selectedDiagramIndex];
				
				// Set up delete modal
				document.getElementById('delete-plan-name').textContent = plan.name;
				
				// Show delete modal
				hideModal(loadDiagramModal);
				showModal(document.getElementById('delete-plan-modal'));
			}

			// Confirm delete plan
			function confirmDeletePlan() {
				const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
				
				if (selectedDiagramIndex < 0 || selectedDiagramIndex >= savedDiagrams.length) {
					alert('Invalid selection.');
					return;
				}
				
				const deletedPlanName = savedDiagrams[selectedDiagramIndex].name;
				
				// Remove the plan from the array
				savedDiagrams.splice(selectedDiagramIndex, 1);
				
				// Save updated array
				localStorage.setItem('breedingDiagrams', JSON.stringify(savedDiagrams));
				
				// Hide delete modal and show confirmation
				hideModal(document.getElementById('delete-plan-modal'));
				alert(`Breeding plan "${deletedPlanName}" has been deleted.`);
				
				// Explicitly clear the canvas - more thorough cleanup
				// Clear all nodes from the DOM
				breedingCanvas.querySelectorAll('.breeding-node').forEach(node => node.remove());
				
				// Clear all connections
				connectionsGroup.innerHTML = '';
				
				// Reset state variables
				nodes = [];
				connections = [];
				nodeCounter = 0;
				selectedNode = null;
				
				// Refresh the load modal
				showLoadModal();
			}
            
            function renderStrainList(strains) {
                if (!strains.length) {
                    strainList.innerHTML = '<div class="strain-item"><div class="strain-info"><div class="strain-name">No strains found</div></div></div>';
                    return;
                }
                
                strainList.innerHTML = '';
                
                strains.forEach(strain => {
                    const strainName = strain.STRAIN || strain.Strain || strain.Name || 'Unnamed';
                    const count = strain.COUNT || strain.Count || '';
                    const type = strain['REG / FEM'] || strain.Type || '';
                    
                    // Create type tags
                    let tags = '';
                    if (type.toLowerCase().includes('reg')) tags += '<span class="strain-tag tag-reg">REG</span>';
                    if (type.toLowerCase().includes('fem')) tags += '<span class="strain-tag tag-fem">FEM</span>';
                    if (type.toLowerCase().includes('auto')) tags += '<span class="strain-tag tag-auto">AUTO</span>';
                    if (type.toLowerCase().includes('photo')) tags += '<span class="strain-tag tag-photo">PHOTO</span>';
                    if (type.toLowerCase().includes('fast')) tags += '<span class="strain-tag tag-fast">FAST</span>';
                    
                    const item = document.createElement('div');
                    item.className = 'strain-item';
                    item.dataset.id = strain.id;
                    
                    item.innerHTML = `
                        <div class="strain-info">
                            <div class="strain-name">${strainName}</div>
                            <div class="strain-type">${tags}</div>
                        </div>
                        <div class="strain-count">${count}</div>
                    `;
                    
                    item.addEventListener('click', () => addStrainToCanvas(strain));
                    
                    strainList.appendChild(item);
                });
            }
            
			function setupEventListeners() {
				const exportImageBtn = document.createElement('button');
				exportImageBtn.className = 'canvas-tool';
				exportImageBtn.id = 'save-image';
				exportImageBtn.innerText = 'Save Image';
				document.querySelector('.canvas-tools').appendChild(exportImageBtn);

				const copyImageBtn = document.createElement('button');
				copyImageBtn.className = 'canvas-tool';
				copyImageBtn.id = 'copy-image';
				copyImageBtn.innerText = 'Copy Image';
				document.querySelector('.canvas-tools').appendChild(copyImageBtn);

				exportImageBtn.addEventListener('click', saveCanvasAsImage);
				copyImageBtn.addEventListener('click', copyCanvasToClipboard);

				const cleanupBtn = document.createElement('button');
				cleanupBtn.className = 'canvas-tool';
				cleanupBtn.id = 'cleanup-nodes';
				cleanupBtn.innerText = 'Find Orphans';
				document.querySelector('.canvas-tools').appendChild(cleanupBtn);
				cleanupBtn.addEventListener('click', cleanupOrphanedNodes);

				// Add layout toggle button
				addLayoutToggle();

				const sidebarHeader = document.querySelector('.sidebar-header');
				const manageSheetBtn = document.createElement('button');
				manageSheetBtn.className = 'btn btn-secondary';
				manageSheetBtn.innerText = 'MANAGE';
				manageSheetBtn.addEventListener('click', showSavedSheetsModal);
				sidebarHeader.appendChild(manageSheetBtn);
				
				setupStatusToggle();
	
				document.getElementById('cancel-sheets-btn').addEventListener('click', function() {
					hideModal(document.getElementById('saved-sheets-modal'));
					// Do NOT do anything else after hiding the modal
					// Make sure no other modal is shown
					selectedSheetIndex = -1; // Reset the selection after canceling
				});

				document.getElementById('load-sheet-from-list-btn').addEventListener('click', function() {
					if (selectedSheetIndex >= 0 && selectedSheetIndex < savedSheets.length) {
						const selectedSheet = savedSheets[selectedSheetIndex];
						activeSheetId = selectedSheet.id;
						
						// Hide modal FIRST
						hideModal(document.getElementById('saved-sheets-modal'));
						
						// THEN load strains and update UI
						loadStrainsFromSheet(selectedSheet.id);
						
						// Update the active indicator in the list
						savedSheets.forEach((sheet, i) => {
							sheet.isActive = (i === selectedSheetIndex);
						});
						saveSheetsList();
					} else {
						alert('Please select a strain collection first.');
					}
				});

				document.getElementById('delete-sheet-btn').addEventListener('click', function() {
					if (selectedSheetIndex >= 0 && selectedSheetIndex < savedSheets.length) {
						const selectedSheet = savedSheets[selectedSheetIndex];
						
						// Don't allow deleting the default sheet
						if (selectedSheet.isDefault) {
							alert('Cannot delete the default strain collection.');
							return;
						}
						
						if (confirm(`Are you sure you want to delete the strain collection "${selectedSheet.name}"?`)) {
							// If deleting the active sheet, switch to default
							if (selectedSheet.id === activeSheetId) {
								const defaultSheet = savedSheets.find(s => s.isDefault);
								if (defaultSheet) {
									activeSheetId = defaultSheet.id;
									loadStrainsFromSheet(defaultSheet.id);
								}
							}
							
							// Remove from saved sheets
							savedSheets.splice(selectedSheetIndex, 1);
							saveSheetsList();
							
							// Hide modal after completion
							hideModal(document.getElementById('saved-sheets-modal'));
						}
					}
				});
			
				// Canvas pan events
				canvasContainer.addEventListener('mousedown', startPan);
				document.addEventListener('mousemove', doPan);
				document.addEventListener('mouseup', endPan);
				
				// General canvas events
				canvasContainer.addEventListener('click', handleCanvasClick);
				canvasContainer.addEventListener('contextmenu', handleContextMenu);
				document.addEventListener('click', hideContextMenu);
				
				// Help text close button
				const helpTextClose = document.querySelector('.help-text-close');
				if (helpTextClose) {
					helpTextClose.addEventListener('click', function() {
						document.querySelector('.help-text').style.display = 'none';
					});
				}
				
				// Search & filter
				searchBtn.addEventListener('click', performSearch);
				searchInput.addEventListener('keyup', e => {
					if (e.key === 'Enter') performSearch();
				});
				
				filterTabs.forEach(tab => {
					tab.addEventListener('click', function() {
						filterTabs.forEach(t => t.classList.remove('active'));
						this.classList.add('active');
						filterStrains(this.dataset.filter);
					});
				});
				
				// Action buttons
				newDiagramBtn.addEventListener('click', newDiagram);
				saveDiagramBtn.addEventListener('click', showSaveModal);
				loadDiagramBtn.addEventListener('click', function() {
					showLoadModal();
				});
				arrangeTreeBtn.addEventListener('click', arrangeTreeLayout);
				centerViewBtn.addEventListener('click', centerView);

				// Cross modal
				cancelCrossBtn.addEventListener('click', () => hideModal(nameCrossModal));
				createCrossBtn.addEventListener('click', createCross);
				
				// Save modal
				cancelSaveBtn.addEventListener('click', () => hideModal(saveDiagramModal));
				confirmSaveBtn.addEventListener('click', saveDiagram);
				
				// Load diagram modal buttons
				cancelLoadBtn.addEventListener('click', () => hideModal(loadDiagramModal));
				confirmLoadBtn.addEventListener('click', loadSelectedDiagram);
				
				document.getElementById('rename-plan-btn').addEventListener('click', function() {
					if (selectedSheetIndex < 0 || selectedSheetIndex >= savedSheets.length) {
						alert('Please select a strain collection to rename.');
						return;
					}
					
					const selectedSheet = savedSheets[selectedSheetIndex];
					
					// Set up rename modal
					document.getElementById('rename-plan-current-name').textContent = selectedSheet.name;
					document.getElementById('rename-plan-input').value = selectedSheet.name;
					
					// Hide sheets modal THEN show rename modal
					hideModal(document.getElementById('saved-sheets-modal'));
					showModal(document.getElementById('rename-plan-modal'));
				});
				
				// Rename plan modal
				document.getElementById('cancel-rename-btn').addEventListener('click', function() {
					hideModal(document.getElementById('rename-plan-modal'));
					// Don't show any other modal after canceling
				});
				
				document.getElementById('confirm-rename-btn').addEventListener('click', function() {
					const newName = document.getElementById('rename-plan-input').value.trim();
					
					if (!newName) {
						alert('Please enter a name for your strain collection.');
						return;
					}
					
					if (selectedSheetIndex < 0 || selectedSheetIndex >= savedSheets.length) {
						alert('Invalid selection.');
						return;
					}
					
					const oldName = savedSheets[selectedSheetIndex].name;
					
					// Update the name
					savedSheets[selectedSheetIndex].name = newName;
					
					// Save updated array
					saveSheetsList();
					
					// Hide rename modal
					hideModal(document.getElementById('rename-plan-modal'));
					
					// Show confirmation
					alert(`Strain collection renamed from "${oldName}" to "${newName}".`);
				});

				document.getElementById('delete-plan-btn').addEventListener('click', function() {
					const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
					
					if (selectedDiagramIndex < 0 || selectedDiagramIndex >= savedDiagrams.length) {
						alert('Please select a breeding plan to delete.');
						return;
					}
					
					const plan = savedDiagrams[selectedDiagramIndex];
					
					// Set up delete modal
					document.getElementById('delete-plan-name').textContent = plan.name;
					
					// Hide load modal then show delete modal
					hideModal(document.getElementById('load-diagram-modal'));
					showModal(document.getElementById('delete-plan-modal'));
				});

				document.getElementById('cancel-delete-btn').addEventListener('click', function() {
					hideModal(document.getElementById('delete-plan-modal'));
				});
				document.getElementById('confirm-delete-btn').addEventListener('click', confirmDeletePlan);
				
				// Context menu items
				contextEdit.addEventListener('click', () => {
					hideContextMenu();
				});
				
				contextDuplicate.addEventListener('click', () => {
					if (contextMenuTargetNode) {
						duplicateNode(contextMenuTargetNode);
					}
					hideContextMenu();
				});
				
				contextRemove.addEventListener('click', () => {
					if (contextMenuTargetNode) {
						removeNode(contextMenuTargetNode);
					}
					hideContextMenu();
				});
				
				// Window resize
				window.addEventListener('resize', updateSvgSize);
			}

			function setupStatusToggle() {
				// Use event delegation to handle dynamically created status toggles
				document.addEventListener('click', function(e) {
					if (!e.target.classList.contains('status-toggle')) return;
					
					e.preventDefault();
					e.stopPropagation();
					
					const nodeId = e.target.dataset.node;
					const node = document.getElementById(nodeId);
					const nodeData = nodes.find(n => n.id === nodeId);
					
					if (!node || !nodeData) return;
					
					// Get current status
					const currentStatus = nodeData.status || 'planned';
					
					// Define the status cycle
					const statusCycle = ['planned', 'in-progress', 'completed'];
					
					// Find the next status in the cycle
					const currentIndex = statusCycle.indexOf(currentStatus);
					const nextIndex = (currentIndex + 1) % statusCycle.length;
					const newStatus = statusCycle[nextIndex];
					
					// Update the node data
					nodeData.status = newStatus;
					
					// Update the node display
					node.dataset.status = newStatus;
					
					// Update the node class
					node.className = node.className.replace(/status-\w+/, `status-${newStatus}`);
					
					// Update the status indicator
					const statusDot = node.querySelector('.status-dot');
					if (statusDot) {
						statusDot.className = `status-dot ${newStatus}`;
					}
					
					// Update the status text
					const statusText = statusDot?.nextElementSibling;
					if (statusText) {
						statusText.textContent = `Status: ${newStatus.replace('-', ' ').charAt(0).toUpperCase() + newStatus.replace('-', ' ').slice(1)}`;
					}
				});
			}

			function showSavedSheetsModal() {
				const savedSheetsList = document.getElementById('saved-sheets-list');
				savedSheetsList.innerHTML = '';
				
				if (savedSheets.length === 0) {
					savedSheetsList.innerHTML = `<div style="padding: 10px; text-align: center; color: #999;">No saved strain collections found</div>`;
					document.getElementById('load-sheet-from-list-btn').disabled = true;
					document.getElementById('delete-sheet-btn').disabled = true;
				} else {
					let html = '';
					savedSheets.forEach((sheet, index) => {
						const isActive = sheet.id === activeSheetId;
						const isSelected = index === 0;
						
						html += `
							<div class="saved-sheet-item${isSelected ? ' selected-plan' : ''}" 
								 style="padding: 10px; border-bottom: 1px solid #444; cursor: pointer;" 
								 data-index="${index}">
								<div style="display: flex; justify-content: space-between; align-items: center;">
									<span style="font-weight: 500; cursor: pointer; flex: 1;">${sheet.name}</span>
									${isActive ? '<span style="font-size: 12px; color: #4CAF50;">[Active]</span>' : ''}
								</div>
								<div style="font-size: 12px; color: #aaa; margin-top: 5px;">
									ID: ${sheet.id.substring(0, 10)}...
									${sheet.isDefault ? ' (Default)' : ''}
								</div>
							</div>
						`;
					});
					
					savedSheetsList.innerHTML = html;
					document.getElementById('load-sheet-from-list-btn').disabled = false;
					document.getElementById('delete-sheet-btn').disabled = false;
				}
				
				// Show modal
				showModal(document.getElementById('saved-sheets-modal'));
				
				// Add click handlers for sheet items
				const sheetItems = document.querySelectorAll('.saved-sheet-item');
				sheetItems.forEach(item => {
					item.addEventListener('click', function(e) {
						e.preventDefault();
						e.stopPropagation();
						selectSavedSheet(parseInt(this.dataset.index));
					});
				});
			}

			let selectedSheetIndex = 0;

			function selectSavedSheet(index) {
				selectedSheetIndex = index;
				
				document.querySelectorAll('.saved-sheet-item').forEach(item => {
					if (parseInt(item.dataset.index) === selectedSheetIndex) {
						item.classList.add('selected-plan');
						item.style.backgroundColor = '#444';
					} else {
						item.classList.remove('selected-plan');
						item.style.backgroundColor = '';
					}
				});
			}

			// Add these separate modal functions for sheet management
			function showSheetDeleteConfirmation() {
				if (selectedSheetIndex < 0 || selectedSheetIndex >= savedSheets.length) {
					alert('Please select a strain collection to delete.');
					return;
				}
				
				const selectedSheet = savedSheets[selectedSheetIndex];
				
				// Don't allow deleting the default sheet
				if (selectedSheet.isDefault) {
					alert('Cannot delete the default strain collection.');
					return;
				}
				
				// Use a different modal for delete confirmation
				const deleteSheetModal = document.getElementById('delete-plan-modal');
				document.getElementById('delete-plan-name').textContent = selectedSheet.name;
				
				// Hide the sheets modal and show delete confirmation
				hideModal(document.getElementById('saved-sheets-modal'));
				showModal(deleteSheetModal);
			}

			function confirmDeleteSheet() {
				if (selectedSheetIndex < 0 || selectedSheetIndex >= savedSheets.length) {
					alert('Invalid selection.');
					return;
				}
				
				const selectedSheet = savedSheets[selectedSheetIndex];
				
				// If deleting the active sheet, switch to default
				if (selectedSheet.id === activeSheetId) {
					const defaultSheet = savedSheets.find(s => s.isDefault);
					if (defaultSheet) {
						activeSheetId = defaultSheet.id;
						loadStrainsFromSheet(defaultSheet.id);
					}
				}
				
				// Remove from saved sheets
				savedSheets.splice(selectedSheetIndex, 1);
				saveSheetsList();
				
				// Hide delete modal
				hideModal(document.getElementById('delete-plan-modal'));
				
				// Show success message
				alert(`Strain collection "${selectedSheet.name}" has been deleted.`);
			}

			function showSheetRenameModal() {
				if (selectedSheetIndex < 0 || selectedSheetIndex >= savedSheets.length) {
					alert('Please select a strain collection to rename.');
					return;
				}
				
				const selectedSheet = savedSheets[selectedSheetIndex];
				
				// Set up rename modal
				const renameModal = document.getElementById('rename-plan-modal');
				document.getElementById('rename-plan-current-name').textContent = selectedSheet.name;
				document.getElementById('rename-plan-input').value = selectedSheet.name;
				
				// Hide sheets modal and show rename modal
				hideModal(document.getElementById('saved-sheets-modal'));
				showModal(renameModal);
			}

			function confirmRenameSheet() {
				const newName = document.getElementById('rename-plan-input').value.trim();
				
				if (!newName) {
					alert('Please enter a name for your strain collection.');
					return;
				}
				
				if (selectedSheetIndex < 0 || selectedSheetIndex >= savedSheets.length) {
					alert('Invalid selection.');
					return;
				}
				
				const oldName = savedSheets[selectedSheetIndex].name;
				
				// Update the name
				savedSheets[selectedSheetIndex].name = newName;
				
				// Save updated array
				saveSheetsList();
				
				// Hide rename modal
				hideModal(document.getElementById('rename-plan-modal'));
				
				// Show confirmation
				alert(`Strain collection renamed from "${oldName}" to "${newName}".`);
			}
            
            // Canvas Pan/Zoom
            function startPan(e) {
                // Only pan with middle mouse button or when not on a node or connection point
                if (e.button !== 1 && (e.target.closest('.breeding-node') || e.target.closest('.connection-point'))) {
                    return;
                }
                
                e.preventDefault();
                isPanning = true;
                panStart = { x: e.clientX, y: e.clientY };
            }
            
            function doPan(e) {
                if (!isPanning) return;
                
                const dx = e.clientX - panStart.x;
                const dy = e.clientY - panStart.y;
                
                canvasOffset.x += dx;
                canvasOffset.y += dy;
                
                updateCanvasPosition();
                
                panStart = { x: e.clientX, y: e.clientY };
            }
            
            function endPan() {
                isPanning = false;
            }
            
			function centerView() {
				// If no nodes, just center canvas
				if (nodes.length === 0) {
					centerCanvas();
					return;
				}
				
				// Find bounding box of all nodes
				let minX = Infinity, minY = Infinity;
				let maxX = -Infinity, maxY = -Infinity;
				
				nodes.forEach(node => {
					const nodeEl = document.getElementById(node.id);
					if (nodeEl) {
						const left = parseInt(nodeEl.style.left || '0');
						const top = parseInt(nodeEl.style.top || '0');
						const width = nodeEl.offsetWidth || 200;
						const height = nodeEl.offsetHeight || 100;
						
						minX = Math.min(minX, left);
						minY = Math.min(minY, top);
						maxX = Math.max(maxX, left + width);
						maxY = Math.max(maxY, top + height);
					}
				});
				
				// Add padding
				minX -= 100;
				minY -= 100;
				maxX += 100;
				maxY += 100;
				
				// Calculate center of nodes
				const centerX = (minX + maxX) / 2;
				const centerY = (minY + maxY) / 2;
				
				// Calculate new canvas position to center the nodes
				canvasOffset.x = canvasContainer.clientWidth / 2 - centerX;
				canvasOffset.y = canvasContainer.clientHeight / 2 - centerY;
				
				updateCanvasPosition();
			}
            
            // Search and Filter
            function performSearch() {
                const searchTerm = searchInput.value.trim().toLowerCase();
                
                if (!searchTerm) {
                    renderStrainList(allStrains);
                    return;
                }
                
                const filteredStrains = allStrains.filter(strain => {
                    const name = (strain.STRAIN || strain.Strain || strain.Name || '').toLowerCase();
                    const breeder = (strain.BREEDER || strain.Breeder || '').toLowerCase();
                    const type = (strain['REG / FEM'] || strain.Type || '').toLowerCase();
                    const parent1 = (strain.PARENT1 || strain.parent1 || '').toLowerCase();
                    const parent2 = (strain.PARENT2 || strain.parent2 || '').toLowerCase();
                    
                    return name.includes(searchTerm) || 
                        breeder.includes(searchTerm) || 
                        type.includes(searchTerm) || 
                        parent1.includes(searchTerm) || 
                        parent2.includes(searchTerm);
                });
                
                renderStrainList(filteredStrains);
            }
            
            function filterStrains(filter) {
                if (filter === 'all') {
                    renderStrainList(allStrains);
                    return;
                }
                
                const filteredStrains = allStrains.filter(strain => {
                    const type = (strain['REG / FEM'] || strain.Type || '').toLowerCase();
                    return type.includes(filter.toLowerCase());
                });
                
                renderStrainList(filteredStrains);
            }
            
            // Node Operations
			function addStrainToCanvas(strain) {
				nodeCounter++;
				const nodeId = `node-${nodeCounter}`;
				
				// Get strain data
				const strainName = strain.STRAIN || strain.Strain || strain.Name || 'Unnamed';
				const type = strain['REG / FEM'] || strain.Type || '';
				
				// Parse traits
				const traits = {
					growthType: type.toLowerCase().includes('auto') ? 'AUTO' : 
							   type.toLowerCase().includes('photo') ? 'PHOTO' : '',
					sexType: type.toLowerCase().includes('reg') ? 'REG' : 
							type.toLowerCase().includes('fem') ? 'FEM' : '',
					floweringType: type.toLowerCase().includes('fast') ? 'FAST' : ''
				};
				
				// Create node element
				const node = document.createElement('div');
				node.id = nodeId;
				node.className = 'breeding-node strain-node';
				node.dataset.name = strainName;
				node.dataset.growthType = traits.growthType;
				node.dataset.sexType = traits.sexType;
				node.dataset.floweringType = traits.floweringType;
				
				// Calculate position - ensure nodes don't stack
				// Find a free spot on the canvas with a grid-like layout
				const gridSize = 250; // Space between grid points
				const existingPositions = nodes.map(n => {
					const el = document.getElementById(n.id);
					if (el) {
						return {
							x: parseInt(el.style.left || 0),
							y: parseInt(el.style.top || 0)
						};
					}
					return null;
				}).filter(p => p);
				
				// Start at the center view position
				const centerX = (canvasContainer.scrollLeft - canvasOffset.x) + canvasContainer.clientWidth / 2 - 100;
				const centerY = (canvasContainer.scrollTop - canvasOffset.y) + canvasContainer.clientHeight / 2 - 60;
				
				let posX = centerX;
				let posY = centerY;
				let attemptCount = 0;
				
				// Try to find an empty spot in a spiral pattern
				while (attemptCount < 20) {
					const isOccupied = existingPositions.some(p => 
						Math.abs(p.x - posX) < 200 && Math.abs(p.y - posY) < 100
					);
					
					if (!isOccupied) {
						break;
					}
					
					// Spiral outward
					const angle = attemptCount * 0.5;
					const distance = (attemptCount + 1) * 80;
					posX = centerX + Math.cos(angle) * distance;
					posY = centerY + Math.sin(angle) * distance;
					attemptCount++;
				}
				
				node.style.left = `${posX}px`;
				node.style.top = `${posY}px`;
				
				// Create trait tags HTML
				let traitsHTML = '';
				if (traits.growthType) traitsHTML += `<span class="strain-trait ${traits.growthType.toLowerCase()}">${traits.growthType}</span>`;
				if (traits.sexType) traitsHTML += `<span class="strain-trait ${traits.sexType.toLowerCase()}">${traits.sexType}</span>`;
				if (traits.floweringType) traitsHTML += `<span class="strain-trait ${traits.floweringType.toLowerCase()}">${traits.floweringType}</span>`;
				
				// Check if parent info exists in strain data
				const parent1 = strain.PARENT1 || strain.parent1 || '';
				const parent2 = strain.PARENT2 || strain.parent2 || '';
				
				// Create parent info HTML if parents exist
				let parentHTML = '';
				if (parent1 || parent2) {
					parentHTML = `
						<div class="node-parents">
							${parent1 ? `<div>♀: ${parent1}</div>` : ''}
							${parent2 ? `<div>♂: ${parent2}</div>` : ''}
						</div>
					`;
				}
				
				// Node content with parent information if available
				node.innerHTML = `
					<div class="node-header">
						<div class="node-name">${strainName}</div>
						<div class="node-controls">
							<div class="node-control" data-action="remove" title="Remove">×</div>
						</div>
					</div>
					<div class="node-content">
						<div class="node-traits">${traitsHTML}</div>
						${parentHTML}
					</div>
					<div class="connection-points">
						<div class="connection-point connection-point-female" data-node="${nodeId}" data-role="female" title="Use as Female (Mother)"></div>
						<div class="connection-point connection-point-male" data-node="${nodeId}" data-role="male" title="Use as Male (Father)"></div>
					</div>
				`;
				
				// Make node draggable
				node.addEventListener('mousedown', startDraggingNode);
				
				// Setup connection points
				node.querySelectorAll('.connection-point').forEach(point => {
					point.addEventListener('mousedown', startConnecting);
				});
				
				// Setup remove button
				const removeButton = node.querySelector('[data-action="remove"]');
				removeButton.addEventListener('click', e => {
					e.preventDefault();
					e.stopPropagation();
					removeNode(nodeId);
				});
				
				// Add to canvas
				breedingCanvas.appendChild(node);
				
				// Add to nodes array
				nodes.push({
					id: nodeId,
					name: strainName,
					growthType: traits.growthType,
					sexType: traits.sexType,
					floweringType: traits.floweringType,
					origin: 'strain',
					children: [],
					parents: []
				});
				
				selectNode(nodeId);
				return nodeId;
			}

			function updateExistingNodesWithParents() {
				// Find all strain nodes
				const strainNodes = nodes.filter(node => node.origin === 'strain');
				
				// For each strain node, update parent information
				strainNodes.forEach(nodeData => {
					// Get the node element
					const nodeElement = document.getElementById(nodeData.id);
					if (!nodeElement) return; // Skip if element doesn't exist
					
					// Check if node already has parent information displayed
					const existingParentInfo = nodeElement.querySelector('.node-parents');
					if (existingParentInfo) return; // Skip if already has parent info
					
					// Find strain data for this node by name
					const matchingStrain = allStrains.find(strain => 
						(strain.STRAIN || strain.Strain || strain.Name) === nodeData.name
					);
					
					if (!matchingStrain) return; // Skip if matching strain not found
					
					// Get parent information
					const parent1 = matchingStrain.PARENT1 || matchingStrain.parent1 || '';
					const parent2 = matchingStrain.PARENT2 || matchingStrain.parent2 || '';
					
					// Skip if no parent information
					if (!parent1 && !parent2) return;
					
					// Create parent info HTML
					const parentHTML = `
						<div class="node-parents">
							${parent1 ? `<div>♀: ${parent1}</div>` : ''}
							${parent2 ? `<div>♂: ${parent2}</div>` : ''}
						</div>
					`;
					
					// Find the node-content div to add parents to
					const nodeContent = nodeElement.querySelector('.node-content');
					if (nodeContent) {
						// Create temporary container for the HTML
						const tempContainer = document.createElement('div');
						tempContainer.innerHTML = parentHTML;
						
						// Append the parent information to node content
						while (tempContainer.firstChild) {
							nodeContent.appendChild(tempContainer.firstChild);
						}
					}
				});
				
				console.log('Updated existing nodes with parent information');
			}
            
			function createCross() {
				if (!pendingCrossData) return;
				
				// Get data from form
				const customName = customCrossName.value.trim();
				const finalName = customName || pendingCrossData.defaultName;
				
				// Get selected types from radio buttons and checkboxes
				const growthType = document.querySelector('input[name="growth-type"]:checked')?.value || 'PHOTO';
				const seedType = document.querySelector('input[name="seed-type"]:checked')?.value || 'REG';
				const floweringType = document.querySelector('input[name="flowering-type"]:checked') ? 'FAST' : '';
				
				// Get selected status - NEW
				const status = document.querySelector('input[name="cross-status"]:checked')?.value || 'planned';
				
				// Create cross data
				const crossData = {
					femaleId: pendingCrossData.femaleId,
					maleId: pendingCrossData.maleId,
					femaleName: pendingCrossData.femaleName,
					maleName: pendingCrossData.maleName,
					name: finalName,
					growthType: growthType,
					sexType: seedType,
					floweringType: floweringType,
					status: status  // NEW
				};
				
				// Add cross node to canvas
				const newNodeId = addCrossNodeToCanvas(crossData);
				
				// Hide modal and reset
				hideModal(nameCrossModal);
				customCrossName.value = '';
				pendingCrossData = null;
			}

			function addCrossNodeToCanvas(crossData) {
				nodeCounter++;
				const nodeId = `node-${nodeCounter}`;
				
				// Create node element
				const node = document.createElement('div');
				node.id = nodeId;
				node.className = `breeding-node cross-node status-${crossData.status || 'planned'}`;
				node.dataset.name = crossData.name;
				
				// Store all type information
				node.dataset.growthType = crossData.growthType || '';
				node.dataset.sexType = crossData.sexType || '';
				node.dataset.floweringType = crossData.floweringType || '';
				node.dataset.status = crossData.status || 'planned';  // NEW
				
				// Calculate position - below and between the parents with offset
				const femaleEl = document.getElementById(crossData.femaleId);
				const maleEl = document.getElementById(crossData.maleId);
				
				let posX = 300;
				let posY = 300;
				
				if (femaleEl && maleEl) {
					const femaleLeft = parseInt(femaleEl.style.left || 0);
					const femaleTop = parseInt(femaleEl.style.top || 0);
					const maleLeft = parseInt(maleEl.style.left || 0);
					const maleTop = parseInt(maleEl.style.top || 0);
					
					// Position in a triangle relationship instead of directly below
					posX = femaleLeft + (maleLeft - femaleLeft) * 0.5;
					posY = Math.max(femaleTop, maleTop) + 150;
					
					// Check if this position is already occupied
					const isPositionOccupied = nodes.some(n => {
						const el = document.getElementById(n.id);
						if (el && n.id !== nodeId) {
							const nodeLeft = parseInt(el.style.left || 0);
							const nodeTop = parseInt(el.style.top || 0);
							return Math.abs(nodeLeft - posX) < 100 && Math.abs(nodeTop - posY) < 100;
						}
						return false;
					});
					
					// If position is occupied, offset it
					if (isPositionOccupied) {
						posX += 120;
						posY += 50;
					}
				}
				
				node.style.left = `${posX}px`;
				node.style.top = `${posY}px`;
				
				// Create trait tags HTML
				let traitsHTML = '';
				if (crossData.growthType) {
					traitsHTML += `<span class="strain-trait ${crossData.growthType.toLowerCase()}">${crossData.growthType}</span>`;
				}
				if (crossData.sexType) {
					traitsHTML += `<span class="strain-trait ${crossData.sexType.toLowerCase()}">${crossData.sexType}</span>`;
				}
				if (crossData.floweringType) {
					traitsHTML += `<span class="strain-trait ${crossData.floweringType.toLowerCase()}">${crossData.floweringType}</span>`;
				}
				
				// Update node HTML to include status indicator
				node.innerHTML = `
					<div class="node-header">
						<div class="node-name">${crossData.name}</div>
						<div class="node-controls">
							<div class="node-control" data-action="remove" title="Remove">×</div>
						</div>
					</div>
					<div class="node-content">
						<div class="node-traits">${traitsHTML}</div>
						<div class="node-parents">
							<div>♀: ${crossData.femaleName}</div>
							<div>♂: ${crossData.maleName}</div>
						</div>
						<div class="status-indicator">
							<div class="status-dot ${crossData.status || 'planned'}"></div>
							<div>Status: ${(crossData.status || 'planned').replace('-', ' ').charAt(0).toUpperCase() + (crossData.status || 'planned').replace('-', ' ').slice(1)}</div>
							<div class="status-toggle" data-node="${nodeId}">Change</div>
						</div>
					</div>
					<div class="connection-points">
						<div class="connection-point connection-point-female" data-node="${nodeId}" data-role="female" title="Use as Female (Mother)"></div>
						<div class="connection-point connection-point-male" data-node="${nodeId}" data-role="male" title="Use as Male (Father)"></div>
					</div>
				`;
				
				// Make node draggable
				node.addEventListener('mousedown', startDraggingNode);
				
				// Setup connection points
				node.querySelectorAll('.connection-point').forEach(point => {
					point.addEventListener('mousedown', startConnecting);
				});
				
				// Setup remove button
				const removeButton = node.querySelector('[data-action="remove"]');
				if (removeButton) {
					removeButton.addEventListener('click', e => {
						e.preventDefault();
						e.stopPropagation();
						removeNode(nodeId);
					});
				}
				
				// Add to canvas
				breedingCanvas.appendChild(node);
				
				// Add to nodes array with status property
				const newNode = {
					id: nodeId,
					name: crossData.name,
					growthType: crossData.growthType,
					sexType: crossData.sexType,
					floweringType: crossData.floweringType,
					status: crossData.status || 'planned',  // NEW
					origin: 'cross',
					femaleParent: crossData.femaleId,
					maleParent: crossData.maleId,
					children: []
				};
				
				nodes.push(newNode);
				
				// Update parent nodes to have this as a child
				const femaleParent = nodes.find(n => n.id === crossData.femaleId);
				const maleParent = nodes.find(n => n.id === crossData.maleId);
				
				if (femaleParent) femaleParent.children.push(nodeId);
				if (maleParent) maleParent.children.push(nodeId);
				
				// Create connections with right-angle paths
				addConnection(crossData.femaleId, nodeId, 'female');
				addConnection(crossData.maleId, nodeId, 'male');
				
				selectNode(nodeId);
				return nodeId;
			}

			function setupStatusToggle() {
				// Use event delegation to handle dynamically created status toggles
				document.addEventListener('click', function(e) {
					if (!e.target.classList.contains('status-toggle')) return;
					
					e.preventDefault();
					e.stopPropagation();
					
					const nodeId = e.target.dataset.node;
					const node = document.getElementById(nodeId);
					const nodeData = nodes.find(n => n.id === nodeId);
					
					if (!node || !nodeData) return;
					
					// Get current status
					const currentStatus = nodeData.status || 'planned';
					
					// Define the status cycle
					const statusCycle = ['planned', 'in-progress', 'completed'];
					
					// Find the next status in the cycle
					const currentIndex = statusCycle.indexOf(currentStatus);
					const nextIndex = (currentIndex + 1) % statusCycle.length;
					const newStatus = statusCycle[nextIndex];
					
					// Update the node data
					nodeData.status = newStatus;
					
					// Update the node display
					node.dataset.status = newStatus;
					
					// Update the node class
					node.className = node.className.replace(/status-\w+/, `status-${newStatus}`);
					
					// Update the status indicator
					const statusDot = node.querySelector('.status-dot');
					if (statusDot) {
						statusDot.className = `status-dot ${newStatus}`;
					}
					
					// Update the status text
					const statusText = statusDot?.nextElementSibling;
					if (statusText) {
						statusText.textContent = `Status: ${newStatus.replace('-', ' ').charAt(0).toUpperCase() + newStatus.replace('-', ' ').slice(1)}`;
					}
					
					// Auto-save the breeding plan with updated status
					autoSaveBreedingPlan();
				});
			}

			function autoSaveBreedingPlan() {
				// If we don't have a current plan loaded, don't try to auto-save
				if (selectedDiagramIndex < 0) return;
				
				// Get existing saved diagrams
				const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
				
				// If there are no saved diagrams or the selected index is invalid, do nothing
				if (savedDiagrams.length === 0 || selectedDiagramIndex >= savedDiagrams.length) return;
				
				// Get the currently loaded diagram
				const currentDiagram = savedDiagrams[selectedDiagramIndex];
				
				// Make sure the diagram belongs to current collection
				if (currentDiagram.collectionId !== activeSheetId) return;
				
				// Capture position data for all nodes
				const nodePositions = {};
				nodes.forEach(node => {
					const nodeEl = document.getElementById(node.id);
					if (nodeEl) {
						nodePositions[node.id] = {
							left: nodeEl.style.left,
							top: nodeEl.style.top
						};
					}
				});
				
				// Update save data
				const saveData = {
					name: currentDiagram.name,
					notes: currentDiagram.notes || '',
					date: new Date().toISOString(),
					nodes: nodes,
					connections: connections,
					positions: nodePositions,
					collectionId: activeSheetId  // Ensure collection ID is maintained
				};
				
				// Update the diagram in the saved list
				savedDiagrams[selectedDiagramIndex] = saveData;
				
				// Save to localStorage
				localStorage.setItem('breedingDiagrams', JSON.stringify(savedDiagrams));
				
				// Optional - show a brief auto-save indicator
				showAutoSaveIndicator();
			}

			function showAutoSaveIndicator() {
				// Create or get the auto-save indicator element
				let indicator = document.getElementById('auto-save-indicator');
				
				if (!indicator) {
					indicator = document.createElement('div');
					indicator.id = 'auto-save-indicator';
					indicator.style.position = 'fixed';
					indicator.style.bottom = '10px';
					indicator.style.right = '10px';
					indicator.style.backgroundColor = 'rgba(45, 94, 50, 0.8)';
					indicator.style.color = 'white';
					indicator.style.padding = '8px 12px';
					indicator.style.borderRadius = '4px';
					indicator.style.fontSize = '12px';
					indicator.style.transition = 'opacity 0.5s';
					indicator.style.zIndex = '1000';
					document.body.appendChild(indicator);
				}
				
				// Show the indicator
				indicator.textContent = 'Changes saved';
				indicator.style.opacity = '1';
				
				// Hide after 2 seconds
				setTimeout(() => {
					indicator.style.opacity = '0';
				}, 2000);
			}
            
            function duplicateNode(nodeId) {
                const nodeData = nodes.find(node => node.id === nodeId);
                if (!nodeData) return;
                
                const nodeElement = document.getElementById(nodeId);
                if (!nodeElement) return;
                
                nodeCounter++;
                const newNodeId = `node-${nodeCounter}`;
                
                // Create a clone of the node with new ID
                const clone = nodeElement.cloneNode(true);
                clone.id = newNodeId;
                
                // Update connection point data
                const connectionPoint = clone.querySelector('.connection-point');
                connectionPoint.dataset.node = newNodeId;
                
                // Position slightly offset from original
                const originalLeft = parseInt(nodeElement.style.left);
                const originalTop = parseInt(nodeElement.style.top);
                
                clone.style.left = `${originalLeft + 30}px`;
                clone.style.top = `${originalTop + 30}px`;
                
                // Add event listeners to clone
                clone.addEventListener('mousedown', startDraggingNode);
                
                const cloneConnectionPoint = clone.querySelector('.connection-point');
                cloneConnectionPoint.addEventListener('mousedown', startConnecting);
                
                const removeButton = clone.querySelector('[data-action="remove"]');
                removeButton.addEventListener('click', e => {
                    e.preventDefault();
                    e.stopPropagation();
                    removeNode(newNodeId);
                });
                
                // Add to canvas
                breedingCanvas.appendChild(clone);
                
                // Add to nodes array
                const newNodeData = {
                    ...JSON.parse(JSON.stringify(nodeData)),
                    id: newNodeId,
                    name: `${nodeData.name} (Copy)`,
                    children: [],
                    parents: []
                };
                
                nodes.push(newNodeData);
                
                selectNode(newNodeId);
                return newNodeId;
            }
            
            function removeNode(nodeId) {
                // Remove connections to/from this node
                removeConnectionsForNode(nodeId);
                
                // Remove node element
                const nodeElement = document.getElementById(nodeId);
                if (nodeElement) nodeElement.remove();
                
                // Find node data
                const nodeIndex = nodes.findIndex(node => node.id === nodeId);
                if (nodeIndex === -1) return;
                
                const nodeData = nodes[nodeIndex];
                
                // Update parent nodes to remove this as a child
                nodeData.parents.forEach(parentId => {
                    const parentNode = nodes.find(n => n.id === parentId);
                    if (parentNode) {
                        parentNode.children = parentNode.children.filter(id => id !== nodeId);
                    }
                });
                
                // Update child nodes to remove this as a parent
                nodeData.children.forEach(childId => {
                    const childNode = nodes.find(n => n.id === childId);
                    if (childNode) {
                        childNode.parents = childNode.parents.filter(id => id !== nodeId);
                    }
                });
                
                // Remove from nodes array
                nodes.splice(nodeIndex, 1);
                
                if (selectedNode === nodeId) {
                    deselectAllNodes();
                }
            }
            
			function startDraggingNode(e) {
				// Don't drag if clicking connection point or control
				if (e.target.classList.contains('connection-point') || 
					e.target.classList.contains('node-control')) {
					return;
				}
				
				e.preventDefault();
				e.stopPropagation();
				
				// Find the node element (could be child of node)
				const nodeElement = e.target.closest('.breeding-node');
				if (!nodeElement) return;
				
				// Select this node
				selectNode(nodeElement.id);
				
				// Calculate offset within the node
				const rect = nodeElement.getBoundingClientRect();
				const offsetX = e.clientX - rect.left;
				const offsetY = e.clientY - rect.top;
				
				function moveNode(moveEvent) {
					const canvasRect = breedingCanvas.getBoundingClientRect();
					const newLeft = moveEvent.clientX - canvasRect.left - offsetX;
					const newTop = moveEvent.clientY - canvasRect.top - offsetY;
					
					nodeElement.style.left = `${newLeft}px`;
					nodeElement.style.top = `${newTop}px`;
					
					// Update connections - this updates all connections in real-time
					updateConnectionsForNode(nodeElement.id);
				}
				
				function endDrag() {
					document.removeEventListener('mousemove', moveNode);
					document.removeEventListener('mouseup', endDrag);
					
					// Make sure connections are updated one final time
					updateConnectionsForNode(nodeElement.id);
				}
				
				document.addEventListener('mousemove', moveNode);
				document.addEventListener('mouseup', endDrag);
			}
            
            function selectNode(nodeId) {
                // Deselect any currently selected node
                deselectAllNodes();
                
                // Select the new node
                const nodeElement = document.getElementById(nodeId);
                if (nodeElement) {
                    nodeElement.classList.add('selected');
                    selectedNode = nodeId;
                }
            }
            
            function deselectAllNodes() {
                document.querySelectorAll('.breeding-node.selected').forEach(node => {
                    node.classList.remove('selected');
                });
                selectedNode = null;
            }
            
            // Connection Operations
			function startConnecting(e) {
				e.preventDefault();
				e.stopPropagation();
				
				const connectionPoint = e.target;
				const nodeId = connectionPoint.dataset.node;
				const role = connectionPoint.dataset.role; // 'female' or 'male'
				
				connecting = true;
				connectingSourceNode = nodeId;
				connectingRole = role;
				
				// Create temporary SVG line with right angles
				tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
				tempLine.setAttribute('stroke', role === 'female' ? '#e091b9' : '#91b7e0');
				tempLine.setAttribute('stroke-width', '2');
				tempLine.setAttribute('fill', 'none');
				tempLine.setAttribute('stroke-dasharray', '5,5'); // make it dashed while dragging
				tempLine.setAttribute('marker-end', `url(#arrow-${role})`);
				
				connectionsGroup.appendChild(tempLine);
				
				// Add mouse move and up handlers
				document.addEventListener('mousemove', updateTempConnection);
				document.addEventListener('mouseup', finishConnection);
			}

			function updateTempConnection(e) {
				if (!connecting || !connectingSourceNode) return;
				
				const canvasRect = breedingCanvas.getBoundingClientRect();
				const sourceNode = document.getElementById(connectingSourceNode);
				if (!sourceNode) return;
				
				const sourceRect = sourceNode.getBoundingClientRect();
				
				// Source center
				const startX = sourceRect.left + sourceRect.width/2 - canvasRect.left;
				const startY = sourceRect.top + sourceRect.height/2 - canvasRect.top;
				
				// Mouse position
				const endX = e.clientX - canvasRect.left;
				const endY = e.clientY - canvasRect.top;
				
				// Create a right-angled path
				let pathD;
				
				// Determine direction based on cursor position relative to source
				if (Math.abs(endX - startX) > Math.abs(endY - startY)) {
					// More horizontal movement
					const midX = (startX + endX) / 2;
					pathD = `M ${startX} ${startY} L ${midX} ${startY} L ${midX} ${endY} L ${endX} ${endY}`;
				} else {
					// More vertical movement
					const midY = (startY + endY) / 2;
					pathD = `M ${startX} ${startY} L ${startX} ${midY} L ${endX} ${midY} L ${endX} ${endY}`;
				}
				
				tempLine.setAttribute('d', pathD);
			}

			function finishConnection(e) {
				if (!connecting || !connectingSourceNode) return;
				
				document.removeEventListener('mousemove', updateTempConnection);
				document.removeEventListener('mouseup', finishConnection);
				
				// Remove temp line
				if (tempLine) {
					tempLine.remove();
					tempLine = null;
				}
				
				// Check if mouse is over a connection point
				const element = document.elementFromPoint(e.clientX, e.clientY);
				if (element && element.classList.contains('connection-point')) {
					const targetNodeId = element.dataset.node;
					const targetRole = element.dataset.role;
					
					// Don't connect to self
					if (targetNodeId !== connectingSourceNode) {
						// Don't connect same roles (female to female or male to male)
						if (connectingRole !== targetRole) {
							// Show cross creation modal
							showNameCrossModal(connectingSourceNode, targetNodeId, connectingRole, targetRole);
						} else {
							alert('Cannot connect same types. Connect female to male or male to female.');
						}
					}
				}
				
				connecting = false;
				connectingSourceNode = null;
				connectingRole = null;
			}

			function showNameCrossModal(sourceId, targetId, sourceRole, targetRole) {
				// Determine which is female and which is male
				let femaleId, maleId;
				
				if (sourceRole === 'female') {
					femaleId = sourceId;
					maleId = targetId;
				} else {
					femaleId = targetId;
					maleId = sourceId;
				}
				
				// Get parent nodes
				const femaleNode = nodes.find(n => n.id === femaleId);
				const maleNode = nodes.find(n => n.id === maleId);
				
				if (!femaleNode || !maleNode) return;
				
				// Setup cross parent information
				crossParents.innerHTML = `
					<div>
						<span style="color: #e091b9;">♀ ${femaleNode.name}</span> × 
						<span style="color: #91b7e0;">♂ ${maleNode.name}</span>
					</div>
				`;
				
				// Set default name - female × male format
				const defaultName = `${femaleNode.name} × ${maleNode.name}`;
				defaultCrossName.textContent = defaultName;
				
				// Replace the single dropdown with properly categorized trait selections
				const typeSelectionHTML = `
					<div class="type-selection">
						<div class="type-group">
							<label><strong>Growth Type:</strong></label>
							<div>
								<label><input type="radio" name="growth-type" value="AUTO" ${femaleNode.growthType === 'AUTO' || maleNode.growthType === 'AUTO' ? 'checked' : ''}> AUTO</label>
								<label><input type="radio" name="growth-type" value="PHOTO" ${(femaleNode.growthType === 'PHOTO' || !femaleNode.growthType) && (maleNode.growthType === 'PHOTO' || !maleNode.growthType) ? 'checked' : ''}> PHOTO</label>
							</div>
						</div>
						
						<div class="type-group">
							<label><strong>Seed Type:</strong></label>
							<div>
								<label><input type="radio" name="seed-type" value="REG" ${!(femaleNode.sexType === 'FEM' || maleNode.sexType === 'FEM') ? 'checked' : ''}> REG</label>
								<label><input type="radio" name="seed-type" value="FEM" ${femaleNode.sexType === 'FEM' || maleNode.sexType === 'FEM' ? 'checked' : ''}> FEM</label>
							</div>
						</div>
						
						<div class="type-group">
							<label><strong>Flowering Type:</strong></label>
							<div>
								<label><input type="checkbox" name="flowering-type" value="FAST" ${femaleNode.floweringType === 'FAST' || maleNode.floweringType === 'FAST' ? 'checked' : ''}> FAST</label>
							</div>
						</div>
					</div>
				`;
				
				// Replace the dropdown with our new interface
				const typeSelectContainer = document.getElementById('cross-type-container');
				if (!typeSelectContainer) {
					// If the container doesn't exist yet, create a hidden element to replace
					const crossTypeInput = document.getElementById('cross-type');
					const parentElement = crossTypeInput.parentElement;
					parentElement.innerHTML = typeSelectionHTML;
				} else {
					typeSelectContainer.innerHTML = typeSelectionHTML;
				}
				
				// Store data for cross creation
				pendingCrossData = {
					femaleId: femaleId,
					maleId: maleId,
					femaleName: femaleNode.name,
					maleName: maleNode.name,
					defaultName: defaultName
				};
				
				// Show modal
				showModal(nameCrossModal);
				customCrossName.focus();
			}
            
			function addConnection(sourceId, targetId, role) {
				// Create connection id with role information
				const connectionId = `connection-${sourceId}-${targetId}-${role}`;
				
				// Check if connection already exists
				if (connections.some(c => c.id === connectionId)) {
					return;
				}
				
				// Set color based on role
				const connectionColor = role === 'female' ? '#e091b9' : '#91b7e0';
				
				// Create SVG path for connection - we'll use a right-angled path
				const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
				path.id = connectionId;
				path.classList.add('connector');
				path.setAttribute('stroke', connectionColor);
				path.setAttribute('stroke-width', '2');
				path.setAttribute('fill', 'none');
				path.setAttribute('marker-end', 'url(#arrow-' + role + ')');
				path.setAttribute('data-source', sourceId);
				path.setAttribute('data-target', targetId);
				path.setAttribute('data-role', role);
				
				// Add to SVG
				connectionsGroup.appendChild(path);
				
				// Add to connections array
				connections.push({
					id: connectionId,
					source: sourceId,
					target: targetId,
					role: role,
					color: connectionColor
				});
				
				// Update connection immediately
				updateConnection(connectionId);
			}

			// Modified updateConnection function to correctly handle connection points
			function updateConnection(connectionId) {
				const connection = typeof connectionId === 'string' 
					? connections.find(c => c.id === connectionId)
					: connectionId;
					
				if (!connection) return;
				
				const path = document.getElementById(connection.id);
				if (!path) return;
				
				const sourceNode = document.getElementById(connection.source);
				const targetNode = document.getElementById(connection.target);
				
				if (!sourceNode || !targetNode) {
					removeConnection(connection.id);
					return;
				}
				
				// Get the source and target rectangles
				const sourceRect = sourceNode.getBoundingClientRect();
				const targetRect = targetNode.getBoundingClientRect();
				const canvasRect = breedingCanvas.getBoundingClientRect();
				
				// Find the specific connection points
				let sourcePoint = null;
				let targetPoint = null;
				
				// Find source connection point (female or male)
				const sourcePoints = sourceNode.querySelectorAll('.connection-point');
				for (const point of sourcePoints) {
					if (point.dataset.role === connection.role) {
						const pointRect = point.getBoundingClientRect();
						sourcePoint = {
							x: pointRect.left + pointRect.width/2 - canvasRect.left,
							y: pointRect.top + pointRect.height/2 - canvasRect.top
						};
						break;
					}
				}
				
				// Find target input point (always at the top middle)
				const targetPoints = targetNode.querySelectorAll('.connection-point');
				for (const point of targetPoints) {
					// We want the opposite connection type for the target
					const oppositeRole = connection.role === 'female' ? 'male' : 'female';
					if (point.dataset.role === oppositeRole) {
						const pointRect = point.getBoundingClientRect();
						targetPoint = {
							x: pointRect.left + pointRect.width/2 - canvasRect.left,
							y: pointRect.top + pointRect.height/2 - canvasRect.top
						};
						break;
					}
				}
				
				// Fallbacks if specific points weren't found
				if (!sourcePoint) {
					sourcePoint = {
						x: sourceRect.left + sourceRect.width/2 - canvasRect.left,
						y: sourceRect.bottom - canvasRect.top
					};
				}
				
				if (!targetPoint) {
					targetPoint = {
						x: targetRect.left + targetRect.width/2 - canvasRect.left,
						y: targetRect.top - canvasRect.top
					};
				}
				
				// Create a path with clean right-angled connections
				let pathD = '';
				
				// Determine if we're going down or up
				const isGoingDown = sourcePoint.y < targetPoint.y;
				const verticalDistance = Math.abs(targetPoint.y - sourcePoint.y);
				const horizontalDistance = Math.abs(targetPoint.x - sourcePoint.x);
				
				if (isGoingDown) {
					// Standard case: source is above target
					const midY = sourcePoint.y + verticalDistance * 0.5;
					pathD = `M ${sourcePoint.x} ${sourcePoint.y} L ${sourcePoint.x} ${midY} L ${targetPoint.x} ${midY} L ${targetPoint.x} ${targetPoint.y}`;
				} else if (verticalDistance < 20 && horizontalDistance > 20) {
					// Nearly horizontal case: use horizontal line with small vertical segments
					pathD = `M ${sourcePoint.x} ${sourcePoint.y} L ${sourcePoint.x} ${sourcePoint.y-15} L ${targetPoint.x} ${targetPoint.y-15} L ${targetPoint.x} ${targetPoint.y}`;
				} else {
					// Going up case (reverse breeding): make a bigger arc
					const controlX = (sourcePoint.x + targetPoint.x) / 2;
					const controlY = Math.min(sourcePoint.y, targetPoint.y) - 50;
					pathD = `M ${sourcePoint.x} ${sourcePoint.y} L ${sourcePoint.x} ${sourcePoint.y-20} L ${controlX} ${controlY} L ${targetPoint.x} ${targetPoint.y-20} L ${targetPoint.x} ${targetPoint.y}`;
				}
				
				path.setAttribute('d', pathD);
				
				// Add connection role-specific styling
				if (connection.role === 'female') {
					path.classList.add('connector-female');
					path.classList.remove('connector-male');
				} else {
					path.classList.add('connector-male');
					path.classList.remove('connector-female');
				}
			}

			function addLayoutToggle() {
				// Create the toggle button
				const layoutToggleBtn = document.createElement('button');
				layoutToggleBtn.className = 'canvas-tool';
				layoutToggleBtn.id = 'toggle-layout-mode';
				layoutToggleBtn.innerHTML = 'Auto Layout <span class="toggle-indicator">◻</span>';
				document.querySelector('.canvas-tools').appendChild(layoutToggleBtn);
				
				// Track state
				let isAutoLayout = false;
				
				// Update button appearance based on state
				function updateToggleButton() {
					const indicator = layoutToggleBtn.querySelector('.toggle-indicator');
					if (isAutoLayout) {
						indicator.textContent = '☑';
						layoutToggleBtn.style.backgroundColor = '#5d4a7e';
					} else {
						indicator.textContent = '◻';
						layoutToggleBtn.style.backgroundColor = '';
					}
				}
				
				// Toggle event handler
				layoutToggleBtn.addEventListener('click', function() {
					isAutoLayout = !isAutoLayout;
					updateToggleButton();
					
					if (isAutoLayout) {
						// Apply automatic layout
						arrangeTreeLayout();
						
						// Make nodes non-draggable in auto layout mode
						document.querySelectorAll('.breeding-node').forEach(node => {
							node.classList.add('auto-layout-node');
						});
					} else {
						// Make nodes draggable again
						document.querySelectorAll('.breeding-node').forEach(node => {
							node.classList.remove('auto-layout-node');
						});
					}
				});
				
				// Add CSS for auto layout nodes
				const styleElement = document.createElement('style');
				styleElement.id = 'auto-layout-styles';
				styleElement.textContent = `
					.auto-layout-node {
						transition: left 0.5s ease, top 0.5s ease;
					}
					
					/* Prevent dragging in auto layout mode */
					.auto-layout-node .node-header {
						cursor: default;
					}
				`;
				document.head.appendChild(styleElement);
				
				// Store the original dragging function
				window.originalStartDragging = startDraggingNode;
				
				// Override the dragging function
				startDraggingNode = function(e) {
					// Don't drag if clicking connection point or control
					if (e.target.classList.contains('connection-point') || 
						e.target.classList.contains('node-control')) {
						return;
					}
					
					// Find the node element (could be child of node)
					const nodeElement = e.target.closest('.breeding-node');
					if (!nodeElement) return;
					
					// Don't allow dragging in auto layout mode
					if (nodeElement.classList.contains('auto-layout-node')) {
						return;
					}
					
					// Call the original function for normal dragging behavior
					return window.originalStartDragging.call(this, e);
				};
			}

			function updateAllConnections() {
				connections.forEach(connection => {
					updateConnection(connection);
				});
			}
            
			function updateConnectionsForNode(nodeId) {
				// Update all connections involving this node
				connections.forEach(conn => {
					if (conn.source === nodeId || conn.target === nodeId) {
						updateConnection(conn);
					}
				});
			}
            
            function removeConnectionsForNode(nodeId) {
                // Find all connections involving this node
                const nodeConnections = connections.filter(conn => 
                    conn.source === nodeId || conn.target === nodeId
                );
                
                // Remove each connection
                nodeConnections.forEach(conn => {
                    removeConnection(conn.id);
                });
            }

			function loadLatestDiagram() {
				const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
				if (savedDiagrams.length === 0) {
					alert('No saved breeding plans found');
					return;
				}
				loadDiagram(savedDiagrams[savedDiagrams.length - 1]);
			}

			function showRenameSelector() {
				const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
				if (savedDiagrams.length === 0) {
					alert('No saved breeding plans found');
					return;
				}
				
				const selector = document.createElement('div');
				selector.className = 'plan-selector';
				selector.style = 'position: absolute; top: 50px; left: 10px; background: #333; padding: 10px; border-radius: 4px; z-index: 1000; box-shadow: 0 2px 10px rgba(0,0,0,0.5);';
				
				savedDiagrams.forEach((plan, index) => {
					const item = document.createElement('div');
					item.innerText = plan.name;
					item.style = 'padding: 8px; cursor: pointer; border-bottom: 1px solid #444;';
					
					item.onclick = function() {
						const newName = prompt('Enter new name:', plan.name);
						if (newName && newName.trim()) {
							savedDiagrams[index].name = newName.trim();
							localStorage.setItem('breedingDiagrams', JSON.stringify(savedDiagrams));
							selector.remove();
						}
					};
					
					selector.appendChild(item);
				});
				
				const closeBtn = document.createElement('div');
				closeBtn.innerText = 'Cancel';
				closeBtn.style = 'padding: 8px; text-align: center; cursor: pointer; border-top: 1px solid #444;';
				closeBtn.onclick = () => selector.remove();
				selector.appendChild(closeBtn);
				
				document.body.appendChild(selector);
				
				document.addEventListener('mousedown', function closeSelector(e) {
					if (!selector.contains(e.target)) {
						selector.remove();
						document.removeEventListener('mousedown', closeSelector);
					}
				});
			}
            
            function removeConnection(connectionId) {
                // Remove connection element
                const connectionElement = document.getElementById(connectionId);
                if (connectionElement) connectionElement.remove();
                
                // Remove from connections array
                connections = connections.filter(conn => conn.id !== connectionId);
            }
            
            // Layout Arrangement
			function arrangeTreeLayout() {
				if (nodes.length === 0) return;
				
				try {
					// Check if dagre is available
					if (typeof dagre === 'undefined') {
						console.error('Dagre library not found. Using fallback layout.');
						arrangeTreeLayoutFallback();
						return;
					}
					
					// Create a new directed graph
					const g = new dagre.graphlib.Graph();
					
					// Determine if we're in minimal view
					const isMinimalView = document.getElementById('breeding-canvas').classList.contains('minimal-view');
					
					// Set graph options - adjust for minimal view
					g.setGraph({
						rankdir: 'TB',
						nodesep: isMinimalView ? 50 : 80,
						ranksep: isMinimalView ? 80 : 120,
						marginx: 20,
						marginy: 20,
						edgesep: isMinimalView ? 8 : 15,
						ranker: 'network-simplex'
					});
					
					// Default node label
					g.setDefaultNodeLabel(() => ({}));
					g.setDefaultEdgeLabel(() => ({}));
					
					// Reset node relationships
					nodes.forEach(node => {
						node.children = [];
						node.parents = [];
					});
					
					// Build parent-child relationships from connections
					connections.forEach(conn => {
						const sourceNode = nodes.find(n => n.id === conn.source);
						const targetNode = nodes.find(n => n.id === conn.target);
						
						if (sourceNode && targetNode) {
							if (!sourceNode.children.includes(conn.target)) {
								sourceNode.children.push(conn.target);
							}
							
							if (!targetNode.parents.includes(conn.source)) {
								targetNode.parents.push(conn.source);
							}
						}
					});
					
					// Add nodes to the graph with their actual dimensions
					nodes.forEach(node => {
						const nodeEl = document.getElementById(node.id);
						if (nodeEl) {
							// Use actual node dimensions
							const width = nodeEl.offsetWidth || 160;
							const height = nodeEl.offsetHeight || 100;
							
							g.setNode(node.id, { 
								width: width + 20, // Add padding
								height: height + 20,
								label: node.name
							});
						}
					});
					
					// Add weighted edges to the graph
					connections.forEach(conn => {
						g.setEdge(conn.source, conn.target, { 
							weight: conn.role === 'female' ? 2 : 1, // Prioritize female connections
							minlen: 1 // Minimum rank distance
						});
					});
					
					// Calculate layout
					dagre.layout(g);
					
					// Apply positions to nodes with transition for smooth animation
					g.nodes().forEach(nodeId => {
						const nodeData = g.node(nodeId);
						const nodeEl = document.getElementById(nodeId);
						
						if (nodeEl && nodeData) {
							// Position from center point
							nodeEl.style.left = `${Math.round(nodeData.x - nodeData.width / 2)}px`;
							nodeEl.style.top = `${Math.round(nodeData.y - nodeData.height / 2)}px`;
							
							// Add transition class temporarily for smooth movement
							nodeEl.classList.add('node-transitioning');
							setTimeout(() => {
								nodeEl.classList.remove('node-transitioning');
							}, 500);
						}
					});
					
					// Update all connections after the nodes have been positioned
					setTimeout(() => {
						updateAllConnections();
					}, 100);
					
					// Re-center view
					setTimeout(centerView, 200);
				} catch (error) {
					console.error('Error in Dagre layout:', error);
					alert('Error applying automatic layout. Reverting to manual positioning.');
					arrangeTreeLayoutFallback();
				}
			}

			function arrangeTreeLayoutFallback() {
				if (nodes.length === 0) return;
				
				// Reset relationships
				nodes.forEach(node => {
					node.children = [];
					node.parents = [];
				});
				
				// Rebuild relationships from connections
				connections.forEach(conn => {
					const sourceNode = nodes.find(n => n.id === conn.source);
					const targetNode = nodes.find(n => n.id === conn.target);
					
					if (sourceNode && targetNode) {
						if (!sourceNode.children.includes(conn.target)) {
							sourceNode.children.push(conn.target);
						}
						
						if (!targetNode.parents.includes(conn.source)) {
							targetNode.parents.push(conn.source);
						}
					}
				});
				
				// Find root nodes (no parents)
				const rootNodes = nodes.filter(node => node.parents.length === 0);
				
				if (rootNodes.length === 0 && nodes.length > 0) {
					// If no root nodes found but we have nodes, use first node as root
					const startX = 100;
					const startY = 100;
					const placedNodes = {};
					positionNode(nodes[0], startX, startY, placedNodes, 0);
				} else if (rootNodes.length > 0) {
					// Arrange from each root node
					const rootSpacing = Math.max(300, 800 / Math.max(1, rootNodes.length));
					let startX = 100;
					const placedNodes = {};
					
					rootNodes.forEach(root => {
						positionNode(root, startX, 100, placedNodes, 0);
						startX += rootSpacing;
					});
				}
				
				// Force update all connections
				setTimeout(() => {
					updateAllConnections();
				}, 100);
				
				// Center view
				setTimeout(centerView, 200);
			}

			function positionNode(node, x, y, placedNodes, level) {
				console.log(`Positioning node ${node.id} at (${x}, ${y}), level ${level}`);
				
				// Skip if already placed at a deeper level
				if (placedNodes[node.id] && placedNodes[node.id].level >= level) {
					return;
				}
				
				// Mark this node as placed
				placedNodes[node.id] = { x, y, level };
				
				// Position this node
				const nodeElement = document.getElementById(node.id);
				if (nodeElement) {
					nodeElement.style.left = `${x}px`;
					nodeElement.style.top = `${y}px`;
				}
				
				// If no children, we're done with this branch
				if (!node.children || node.children.length === 0) {
					return;
				}
				
				// Calculate horizontal space for children
				const childSpacing = 250; // Space between child nodes
				const totalWidth = (node.children.length - 1) * childSpacing;
				let childX = x - totalWidth / 2;
				const childY = y + 150; // Fixed vertical spacing
				
				// Position each child
				node.children.forEach(childId => {
					const childNode = nodes.find(n => n.id === childId);
					if (childNode) {
						positionNode(childNode, childX, childY, placedNodes, level + 1);
						childX += childSpacing;
					}
				});
			}
            
            // UI Handlers
            function handleCanvasClick(e) {
                // If clicking on canvas background, deselect nodes
                if (e.target === breedingCanvas || e.target === canvasContainer) {
                    deselectAllNodes();
                }
            }
            
            function handleContextMenu(e) {
                e.preventDefault();
                
                // Hide existing context menu
                hideContextMenu();
                
                // Check if clicking on a node
                const nodeElement = e.target.closest('.breeding-node');
                if (nodeElement) {
                    // Set target node
                    contextMenuTargetNode = nodeElement.id;
                    
                    // Show context menu at mouse position
                    nodeContextMenu.style.left = `${e.clientX}px`;
                    nodeContextMenu.style.top = `${e.clientY}px`;
                    nodeContextMenu.classList.add('visible');
                }
            }
            
            function hideContextMenu() {
                nodeContextMenu.classList.remove('visible');
                contextMenuTargetNode = null;
            }
            
			function showModal(modal) {
				modal.classList.add('visible');
				
				// Ensure all buttons in the modal are clickable
				setTimeout(() => {
					const buttons = modal.querySelectorAll('button');
					buttons.forEach(button => {
						button.style.pointerEvents = "auto";
					});
				}, 10);
			}
            
            function hideModal(modal) {
                modal.classList.remove('visible');
            }
            
            // Diagram Management
            function newDiagram() {
                if (nodes.length > 0) {
                    if (!confirm('Are you sure you want to create a new diagram? This will clear all current nodes.')) {
                        return;
                    }
                }
                
                // Clear canvas
                breedingCanvas.querySelectorAll('.breeding-node').forEach(node => node.remove());
                connectionsGroup.innerHTML = '';
                
                // Reset state
                nodes = [];
                connections = [];
                nodeCounter = 0;
                selectedNode = null;
                
                // Reset canvas position
                centerCanvas();
            }
            
			function showSaveModal() {
				if (nodes.length === 0) {
					alert('Nothing to save. Add some strains to your diagram first.');
					return;
				}
				
				// Get saved diagrams
				const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
				let currentDiagramName = '';
				let currentDiagramNotes = '';
				
				// First check: if a diagram was loaded, remember its name
				// We can do this by checking if selectedDiagramIndex is set and valid
				if (selectedDiagramIndex >= 0 && selectedDiagramIndex < savedDiagrams.length) {
					currentDiagramName = savedDiagrams[selectedDiagramIndex].name;
					currentDiagramNotes = savedDiagrams[selectedDiagramIndex].notes || '';
				} 
				// Fallback: look for a match based on nodes if no diagram was explicitly loaded
				else if (savedDiagrams.length > 0) {
					// This is the old matching logic as a fallback
					const currentStrainNames = nodes
						.filter(n => n.origin === 'strain')
						.map(n => n.name)
						.sort()
						.join(',');
					
					for (const diagram of savedDiagrams) {
						if (diagram.nodes) {
							const savedStrainNames = diagram.nodes
								.filter(n => n.origin === 'strain')
								.map(n => n.name)
								.sort()
								.join(',');
							
							// If most of the strains match (allowing for small changes)
							if (currentStrainNames === savedStrainNames) {
								currentDiagramName = diagram.name;
								currentDiagramNotes = diagram.notes || '';
								break;
							}
						}
					}
				}
				
				// Populate the form with current diagram name and notes if found
				diagramName.value = currentDiagramName;
				diagramNotes.value = currentDiagramNotes;
				
				// Show the modal
				showModal(saveDiagramModal);
				diagramName.focus();
				
				// If we found a matching diagram, highlight the text field so user can easily change it
				if (currentDiagramName) {
					diagramName.select();
				}
			}

			function saveActiveSheetId() {
				localStorage.setItem('breedingPlannerActiveSheetId', activeSheetId);
			}
            
			function saveDiagram() {
				const name = diagramName.value.trim();
				const notes = diagramNotes.value.trim();
				
				if (!name) {
					alert('Please enter a name for your breeding plan.');
					return;
				}
				
				// Capture position data for all nodes
				const nodePositions = {};
				
				// Remove any orphaned nodes before saving
				const connectedNodeIds = new Set();
				connections.forEach(conn => {
					connectedNodeIds.add(conn.source);
					connectedNodeIds.add(conn.target);
				});
				
				// Filter out any nodes with no connections (orphaned nodes)
				// Except if it's the only node in the diagram
				const nodesToSave = nodes.length === 1 ? 
					nodes : 
					nodes.filter(node => connectedNodeIds.has(node.id));
				
				nodesToSave.forEach(node => {
					const nodeEl = document.getElementById(node.id);
					if (nodeEl) {
						nodePositions[node.id] = {
							left: nodeEl.style.left,
							top: nodeEl.style.top
						};
						
						// Save parent information for strain nodes
						if (node.origin === 'strain') {
							// Find matching strain in allStrains
							const matchingStrain = allStrains.find(strain => 
								(strain.STRAIN || strain.Strain || strain.Name) === node.name
							);
							
							if (matchingStrain) {
								node.parent1 = matchingStrain.PARENT1 || matchingStrain.parent1 || '';
								node.parent2 = matchingStrain.PARENT2 || matchingStrain.parent2 || '';
							}
						}
					}
				});
				
				// Ensure cross nodes have parent name information
				nodesToSave.forEach(node => {
					if (node.origin === 'cross') {
						if (node.femaleParent) {
							const femaleNode = nodesToSave.find(n => n.id === node.femaleParent);
							if (femaleNode) node.femaleName = femaleNode.name;
						}
						if (node.maleParent) {
							const maleNode = nodesToSave.find(n => n.id === node.maleParent);
							if (maleNode) node.maleName = maleNode.name;
						}
					}
				});
				
				// Create save data with collection ID and layout mode
				const saveData = {
					name: name,
					notes: notes,
					date: new Date().toISOString(),
					nodes: nodesToSave,
					connections: connections,
					positions: nodePositions,
					collectionId: activeSheetId,
					isAutoLayout: document.getElementById('toggle-layout-mode')?.querySelector('.toggle-indicator')?.textContent === '☑' || false
				};
				
				// Get existing saved diagrams
				let savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
				
				// Check if diagram with this name already exists IN THIS COLLECTION
				const existingIndex = savedDiagrams.findIndex(d => 
					d.name === name && d.collectionId === activeSheetId
				);
				
				if (existingIndex >= 0) {
					// Only ask for confirmation if it's not the currently loaded diagram
					const isCurrentDiagram = savedDiagrams[existingIndex].nodes.length === nodes.length;
					if (!isCurrentDiagram && !confirm(`A breeding plan named "${name}" already exists in this collection. Overwrite it?`)) {
						return;
					}
					savedDiagrams[existingIndex] = saveData;
					selectedDiagramIndex = existingIndex;
				} else {
					savedDiagrams.push(saveData);
					selectedDiagramIndex = savedDiagrams.length - 1;
				}
				
				// Save to localStorage
				localStorage.setItem('breedingDiagrams', JSON.stringify(savedDiagrams));
				
				// Hide modal and reset
				hideModal(saveDiagramModal);
				diagramName.value = '';
				diagramNotes.value = '';
				
				alert(`Breeding plan "${name}" saved successfully!`);
			}

			// Function to export the canvas as an image
			function renderCanvasImage(callback) {
				// Find the bounding box of all nodes
				let minX = Infinity, minY = Infinity;
				let maxX = -Infinity, maxY = -Infinity;
				
				nodes.forEach(node => {
					const nodeEl = document.getElementById(node.id);
					if (nodeEl) {
						const left = parseInt(nodeEl.style.left || '0');
						const top = parseInt(nodeEl.style.top || '0');
						const width = nodeEl.offsetWidth || 200;
						const height = nodeEl.offsetHeight || 100;
						
						minX = Math.min(minX, left);
						minY = Math.min(minY, top);
						maxX = Math.max(maxX, left + width);
						maxY = Math.max(maxY, top + height);
					}
				});
				
				// Add padding
				const padding = 30;
				minX -= padding;
				minY -= padding;
				maxX += padding;
				maxY += padding;
				
				// Calculate width and height
				const width = maxX - minX;
				const height = maxY - minY;
				
				// Create a temporary container to hold the content
				const tempContainer = document.createElement('div');
				tempContainer.style.position = 'absolute';
				tempContainer.style.left = '0';
				tempContainer.style.top = '0';
				tempContainer.style.width = `${width}px`;
				tempContainer.style.height = `${height}px`;
				tempContainer.style.overflow = 'hidden';
				tempContainer.style.pointerEvents = 'none';
				tempContainer.style.zIndex = '-1000';
				document.body.appendChild(tempContainer);
				
				// Clone the breeding canvas
				const clonedCanvas = breedingCanvas.cloneNode(true);
				clonedCanvas.style.transform = `translate(${-minX}px, ${-minY}px)`;
				clonedCanvas.style.position = 'absolute';
				
				// Remove all UI elements from the clone that shouldn't be in the image
				clonedCanvas.querySelectorAll('.canvas-tools, .arrange-options, .help-text').forEach(el => {
					el.remove();
				});
				
				tempContainer.appendChild(clonedCanvas);
				
				// Use html2canvas library to capture the content
				html2canvas(tempContainer, {
					backgroundColor: '#2d2d2d',
					allowTaint: true,
					useCORS: true,
					scale: 2 // Higher resolution
				}).then(renderedCanvas => {
					// Call the callback function with the rendered canvas
					callback(renderedCanvas);
					
					// Clean up
					document.body.removeChild(tempContainer);
				}).catch(error => {
					console.error('Error generating image:', error);
					alert('Error generating image. Please try again.');
					document.body.removeChild(tempContainer);
				});
			}

			// Function to save canvas as image file
			function saveCanvasAsImage() {
				renderCanvasImage(function(renderedCanvas) {
					// Save to file
					const imageUrl = renderedCanvas.toDataURL('image/png');
					
					// Create download link for automatic download
					const downloadLink = document.createElement('a');
					downloadLink.href = imageUrl;
					downloadLink.download = 'breeding-plan.png';
					document.body.appendChild(downloadLink);
					downloadLink.click();
					document.body.removeChild(downloadLink);
					
					alert('Image saved to file!');
				});
			}

			// Function to copy canvas to clipboard
			function copyCanvasToClipboard() {
				renderCanvasImage(function(renderedCanvas) {
					// Copy to clipboard
					renderedCanvas.toBlob(function(blob) {
						try {
							// Modern clipboard API
							if (navigator.clipboard && navigator.clipboard.write) {
								const item = new ClipboardItem({ 'image/png': blob });
								navigator.clipboard.write([item]).then(
									() => {
										alert('Image copied to clipboard!');
									},
									(error) => {
										console.error('Could not copy to clipboard: ', error);
										alert('Clipboard copy not supported in this browser. Try the Save Image button instead.');
									}
								);
							} else {
								alert('Clipboard copy not supported in this browser. Try the Save Image button instead.');
							}
						} catch (error) {
							console.error('Error copying to clipboard: ', error);
							alert('Clipboard copy not supported in this browser. Try the Save Image button instead.');
						}
					});
				});
			}

			function cleanupOrphanedNodes() {
				// Find nodes that aren't connected to anything
				const orphanedNodes = nodes.filter(node => {
					// Check if node has no connections
					return !connections.some(conn => 
						conn.source === node.id || conn.target === node.id
					);
				});
				
				if (orphanedNodes.length > 0) {
					if (confirm(`Found ${orphanedNodes.length} disconnected node(s). Would you like to center view on them?`)) {
						// Find the position of the first orphaned node
						const orphanNode = document.getElementById(orphanedNodes[0].id);
						if (orphanNode) {
							const left = parseInt(orphanNode.style.left || '0');
							const top = parseInt(orphanNode.style.top || '0');
							
							// Center the view on this node
							canvasOffset.x = canvasContainer.clientWidth / 2 - left - 100;
							canvasOffset.y = canvasContainer.clientHeight / 2 - top - 60;
							updateCanvasPosition();
						}
					}
				} else {
					alert('No disconnected nodes found.');
				}
			}

			function loadDiagram(diagram) {
				// Clear existing diagram first
				breedingCanvas.querySelectorAll('.breeding-node').forEach(node => node.remove());
				connectionsGroup.innerHTML = '';
				nodes = [];
				connections = [];
				
				// Set the node counter to prevent ID conflicts
				if (diagram.nodes.length > 0) {
					const nodeIds = diagram.nodes.map(n => {
						const match = n.id.match(/node-(\d+)/);
						return match ? parseInt(match[1]) : 0;
					});
					nodeCounter = Math.max(...nodeIds, 0);
				}
				
				// Find all valid connected nodes
				const connectedNodeIds = new Set();
				if (diagram.connections) {
					diagram.connections.forEach(conn => {
						connectedNodeIds.add(conn.source);
						connectedNodeIds.add(conn.target);
					});
				}
				
				// If there's only one node, it won't have connections but we should still load it
				const shouldFilterOrphans = diagram.nodes.length > 1 && diagram.connections && diagram.connections.length > 0;
				
				// Only load nodes that have connections, unless it's the only node
				const nodesToLoad = shouldFilterOrphans ? 
					diagram.nodes.filter(node => connectedNodeIds.has(node.id)) : 
					diagram.nodes;
				
				// Create all nodes first
				nodesToLoad.forEach(nodeData => {
					// Create node element
					const node = document.createElement('div');
					node.id = nodeData.id;
					
					// Add status class if it exists (NEW CODE)
					if (nodeData.origin === 'strain') {
						node.className = 'breeding-node strain-node';
					} else {
						// For cross nodes, include status in class
						node.className = `breeding-node cross-node status-${nodeData.status || 'planned'}`;
					}
					
					node.dataset.name = nodeData.name;
					node.dataset.growthType = nodeData.growthType || '';
					node.dataset.sexType = nodeData.sexType || '';
					node.dataset.floweringType = nodeData.floweringType || '';
					node.dataset.status = nodeData.status || 'planned'; // NEW CODE
					
					// Set position
					if (diagram.positions && diagram.positions[nodeData.id]) {
						node.style.left = diagram.positions[nodeData.id].left;
						node.style.top = diagram.positions[nodeData.id].top;
					} else {
						node.style.left = '200px';
						node.style.top = '200px';
					}
					
					// Create trait tags HTML
					let traitsHTML = '';
					if (nodeData.growthType) traitsHTML += `<span class="strain-trait ${nodeData.growthType.toLowerCase()}">${nodeData.growthType}</span>`;
					if (nodeData.sexType) traitsHTML += `<span class="strain-trait ${nodeData.sexType.toLowerCase()}">${nodeData.sexType}</span>`;
					if (nodeData.floweringType) traitsHTML += `<span class="strain-trait ${nodeData.floweringType.toLowerCase()}">${nodeData.floweringType}</span>`;
					
					// Generate node HTML based on type
					if (nodeData.origin === 'cross') {
						// Add status indicator for cross nodes
						node.innerHTML = `
							<div class="node-header">
							<div class="node-name">${nodeData.name}</div>
							<div class="node-controls">
								<div class="node-control" data-action="remove" title="Remove">×</div>
							</div>
							</div>
							<div class="node-content">
							<div class="node-traits">${traitsHTML}</div>
							<div class="node-parents">
								<div>♀: ${nodeData.femaleName || ''}</div>
								<div>♂: ${nodeData.maleName || ''}</div>
							</div>
							<div class="status-indicator">
								<div class="status-dot ${nodeData.status || 'planned'}"></div>
								<div>Status: ${(nodeData.status || 'planned').replace('-', ' ').charAt(0).toUpperCase() + (nodeData.status || 'planned').replace('-', ' ').slice(1)}</div>
								<div class="status-toggle" data-node="${nodeData.id}">Change</div>
							</div>
							</div>
							<div class="connection-points">
							<div class="connection-point connection-point-female" data-node="${nodeData.id}" data-role="female" title="Use as Female (Mother)"></div>
							<div class="connection-point connection-point-male" data-node="${nodeData.id}" data-role="male" title="Use as Male (Father)"></div>
							</div>
						`;
					} else {
						// Create parent info HTML if parent data exists in the saved node
						let parentHTML = '';
						if (nodeData.parent1 || nodeData.parent2) {
							parentHTML = `
							<div class="node-parents">
								${nodeData.parent1 ? `<div>♀: ${nodeData.parent1}</div>` : ''}
								${nodeData.parent2 ? `<div>♂: ${nodeData.parent2}</div>` : ''}
							</div>
							`;
						}
						
						node.innerHTML = `
							<div class="node-header">
							<div class="node-name">${nodeData.name}</div>
							<div class="node-controls">
								<div class="node-control" data-action="remove" title="Remove">×</div>
							</div>
							</div>
							<div class="node-content">
							<div class="node-traits">${traitsHTML}</div>
							${parentHTML}
							</div>
							<div class="connection-points">
							<div class="connection-point connection-point-female" data-node="${nodeData.id}" data-role="female" title="Use as Female (Mother)"></div>
							<div class="connection-point connection-point-male" data-node="${nodeData.id}" data-role="male" title="Use as Male (Father)"></div>
							</div>
						`;
					}
					
					// Add event listeners
					node.addEventListener('mousedown', startDraggingNode);
					
					node.querySelectorAll('.connection-point').forEach(point => {
						point.addEventListener('mousedown', startConnecting);
					});
					
					const removeButton = node.querySelector('[data-action="remove"]');
					if (removeButton) {
						removeButton.addEventListener('click', e => {
							e.preventDefault();
							e.stopPropagation();
							removeNode(nodeData.id);
						});
					}
					
					// Add to canvas
					breedingCanvas.appendChild(node);
				});
				
				// Add nodes to state array with all properties preserved
				nodes = nodesToLoad.map(n => ({...n}));
				
				// Recreate all connections
				connections = [];
				if (diagram.connections) {
					diagram.connections.forEach(conn => {
						// Only create connections if both nodes exist
						if (nodes.some(n => n.id === conn.source) && nodes.some(n => n.id === conn.target)) {
							addConnection(conn.source, conn.target, conn.role);
						}
					});
				}

				// Update parent information for strain nodes
				updateExistingNodesWithParents();
				
				// Restore layout mode if it was saved
				if (diagram.isAutoLayout) {
					const layoutToggleBtn = document.getElementById('toggle-layout-mode');
					if (layoutToggleBtn) {
						const indicator = layoutToggleBtn.querySelector('.toggle-indicator');
						indicator.textContent = '☑';
						layoutToggleBtn.style.backgroundColor = '#5d4a7e';
						
						// Apply auto layout and make nodes non-draggable
						setTimeout(() => {
							arrangeTreeLayout();
							document.querySelectorAll('.breeding-node').forEach(node => {
								node.classList.add('auto-layout-node');
							});
						}, 300);
					}
				}
				
				// Center view
				centerView();
			}
            
			function showLoadModal() {
				console.log("Opening load modal");
				
				// Reset selection index to ensure we have a fresh start
				selectedDiagramIndex = 0;
				
				// Get saved diagrams
				const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
				
				// Filter diagrams for current collection only
				const collectionDiagrams = savedDiagrams.filter(diagram => 
					diagram.collectionId === activeSheetId
				);
				
				if (collectionDiagrams.length === 0) {
					savedDiagramsList.innerHTML = `<div style="padding: 10px; text-align: center; color: #999;">No saved breeding plans found for this collection</div>`;
					confirmLoadBtn.disabled = true;
					document.getElementById('rename-plan-btn').disabled = true;
					document.getElementById('delete-plan-btn').disabled = true;
				} else {
					// Create list of saved diagrams for this collection
					let html = '';
					collectionDiagrams.forEach((diagram, index) => {
						const date = new Date(diagram.date).toLocaleDateString();
						const nodeCount = diagram.nodes.length;
						
						// Add a CSS class to highlight the selected item
						const isSelected = index === 0 ? ' selected-plan' : '';
						
						html += `
							<div class="saved-plan-item${isSelected}" 
								 style="padding: 10px; border-bottom: 1px solid #444; cursor: pointer;" 
								 data-index="${savedDiagrams.indexOf(diagram)}">
								<div style="display: flex; justify-content: space-between; align-items: center;">
									<span style="font-weight: 500; cursor: pointer; flex: 1;">${diagram.name}</span>
									<span style="font-size: 12px; color: #999;">${date}</span>
								</div>
								<div style="font-size: 12px; color: #aaa; margin-top: 5px;">
									${nodeCount} strain${nodeCount !== 1 ? 's' : ''} 
									${diagram.notes ? `<div style="margin-top: 5px; color: #888;">${diagram.notes}</div>` : ''}
								</div>
							</div>
						`;
					});
					
					savedDiagramsList.innerHTML = html;
					confirmLoadBtn.disabled = false;
					document.getElementById('rename-plan-btn').disabled = false;
					document.getElementById('delete-plan-btn').disabled = false;
				}
				
				showModal(loadDiagramModal);
				
				// Add click handlers for plan items - AFTER the modal is shown 
				// to ensure elements exist in the DOM
				const planItems = document.querySelectorAll('.saved-plan-item');
				planItems.forEach(item => {
					item.addEventListener('click', function(e) {
						e.preventDefault();
						e.stopPropagation();
						selectedDiagramIndex = parseInt(this.dataset.index);
						console.log("Selected plan index:", selectedDiagramIndex);
						highlightSelectedPlan();
					});
				});
			}

			function selectPlan(index) {
				selectedDiagramIndex = index;
				highlightSelectedPlan();
			}

			function highlightSelectedPlan() {
				console.log("Highlighting plan with index:", selectedDiagramIndex);
				document.querySelectorAll('.saved-plan-item').forEach(item => {
					if (parseInt(item.dataset.index) === selectedDiagramIndex) {
						item.classList.add('selected-plan');
						item.style.backgroundColor = '#444';
					} else {
						item.classList.remove('selected-plan');
						item.style.backgroundColor = '';
					}
				});
			}

			function loadSelectedDiagram() {
				const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
				
				if (selectedDiagramIndex < 0 || selectedDiagramIndex >= savedDiagrams.length) {
					alert('Please select a breeding plan to load.');
					return;
				}
				
				console.log(`Loading diagram at index ${selectedDiagramIndex}`);
				
				// Load the selected diagram
				loadDiagram(savedDiagrams[selectedDiagramIndex]);
				
				// Hide modal
				hideModal(loadDiagramModal);
			}

			function showRenamePlanModal() {
				const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
				
				if (selectedDiagramIndex < 0 || selectedDiagramIndex >= savedDiagrams.length) {
					alert('Please select a breeding plan to rename.');
					return;
				}
				
				const plan = savedDiagrams[selectedDiagramIndex];
				
				// Set up rename modal
				document.getElementById('rename-plan-current-name').textContent = plan.name;
				document.getElementById('rename-plan-input').value = plan.name;
				
				// Show rename modal
				hideModal(loadDiagramModal);
				showModal(renamePlanModal);
				document.getElementById('rename-plan-input').focus();
			}

			function confirmRenamePlan() {
				const newName = document.getElementById('rename-plan-input').value.trim();
				
				if (!newName) {
					alert('Please enter a name for your breeding plan.');
					return;
				}
				
				const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
				
				if (selectedDiagramIndex < 0 || selectedDiagramIndex >= savedDiagrams.length) {
					alert('Invalid selection.');
					return;
				}
				
				const oldName = savedDiagrams[selectedDiagramIndex].name;
				
				// Check for name collision (except with itself)
				const nameExists = savedDiagrams.some((plan, idx) => idx !== selectedDiagramIndex && plan.name === newName);
				if (nameExists) {
					if (!confirm(`A breeding plan named "${newName}" already exists. Do you want to use this name anyway?`)) {
						return;
					}
				}
				
				// Update the name
				savedDiagrams[selectedDiagramIndex].name = newName;
				
				// Save updated array
				localStorage.setItem('breedingDiagrams', JSON.stringify(savedDiagrams));
				
				// Hide rename modal and show confirmation
				hideModal(renamePlanModal);
				alert(`Breeding plan renamed from "${oldName}" to "${newName}".`);
				
				// Refresh the load modal
				showModal(loadDiagramModal);
				showLoadModal();
			}
            
						
        });
    </script>
</body>
</html>
