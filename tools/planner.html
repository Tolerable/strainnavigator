<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strain Breeding Planner</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #2d2d2d;
            color: #fff;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #1a3c20, #2d5e32);
            color: white;
            padding: 10px 20px;
            text-align: center;
        }
        
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .sidebar {
            width: 300px;
            background-color: #333;
            border-right: 1px solid #444;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .sidebar-header {
            padding: 10px;
            border-bottom: 1px solid #444;
            background-color: #282828;
        }
        
        .search-box {
            display: flex;
            padding: 10px;
            border-bottom: 1px solid #444;
        }
        
        .search-box input {
            flex: 1;
            padding: 8px;
            border: 1px solid #555;
            background-color: #222;
            color: #fff;
            border-radius: 4px 0 0 4px;
        }
        
        .search-box button {
            padding: 8px 15px;
            background-color: #2d5e32;
            color: white;
            border: none;
            border-radius: 0 4px 4px 0;
            cursor: pointer;
        }
        
        .filter-tabs {
            display: flex;
            overflow-x: auto;
            border-bottom: 1px solid #444;
            background-color: #282828;
        }
        
        .filter-tab {
            padding: 8px 12px;
            cursor: pointer;
            white-space: nowrap;
            font-size: 12px;
            font-weight: 500;
        }
        
        .filter-tab.active {
            background-color: #5d4a7e;
            color: white;
        }
        
        .strain-list {
            flex: 1;
            overflow-y: auto;
            background-color: #333;
        }
        
        .strain-item {
            padding: 10px 15px;
            border-bottom: 1px solid #444;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .strain-item:hover {
            background-color: #444;
        }
        
        .strain-info {
            display: flex;
            flex-direction: column;
        }
        
        .strain-name {
            font-weight: 500;
            color: #fff;
        }
        
        .strain-type {
            font-size: 12px;
            margin-top: 2px;
            display: flex;
            gap: 5px;
        }
        
        .strain-tag {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            color: white;
            font-weight: 600;
        }
        
        .tag-reg { background-color: #9575cd; }
        .tag-fem { background-color: #f06292; }
        .tag-auto { background-color: #ffb74d; }
        .tag-photo { background-color: #4db6ac; }
        .tag-fast { background-color: #4fc3f7; }
        
        .strain-count {
            background-color: rgba(93, 74, 126, 0.3);
            color: #b39ddb;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
        }

		.node-traits {
			display: flex;
			flex-wrap: wrap;
			gap: 4px;
			margin-bottom: 6px;
		}

		.strain-trait {
			padding: 2px 6px;
			border-radius: 3px;
			font-size: 11px;
			font-weight: 500;
			color: white;
		}

		.strain-trait.photo {
			background-color: #4db6ac;
		}

		.strain-trait.auto {
			background-color: #ffb74d;
		}

		.strain-trait.reg {
			background-color: #9575cd;
		}

		.strain-trait.fem {
			background-color: #f06292;
		}

		.strain-trait.fast {
			background-color: #4fc3f7;
		}
        
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: auto;
            background-color: #2d2d2d;
        }
        
        .canvas-tools {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            display: flex;
            gap: 5px;
            background-color: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 4px;
        }
        
        .canvas-tool {
            background-color: #333;
            border: 1px solid #444;
            color: #fff;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
        }
        
        .canvas-tool:hover {
            background-color: #444;
        }
        
        .arrange-options {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            gap: 5px;
            background-color: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 4px;
        }
        
        /* Strain nodes and connections */
        .breeding-canvas {
            position: relative;
            width: 3000px;
            height: 2000px;
        }
        
        .breeding-node {
            position: absolute;
            border-radius: 6px;
            min-width: 160px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            cursor: grab;
            user-select: none;
            z-index: 10;
            background-color: #f8f8f8;
            color: #333;
            transition: transform 0.3s ease;
        }
        
        .breeding-node.selected {
            box-shadow: 0 0 0 3px #ffeb3b;
        }
        
        .node-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: #e0e0e0;
            border-radius: 6px 6px 0 0;
            position: relative;
        }
        
        .node-name {
            font-weight: 600;
            word-break: break-word;
        }
        
        .node-controls {
            display: flex;
            gap: 5px;
        }
        
        .node-control {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            cursor: pointer;
            background-color: rgba(0, 0, 0, 0.1);
            color: #333;
        }
        
        .node-control:hover {
            background-color: rgba(0, 0, 0, 0.2);
        }
        
        .node-content {
            padding: 10px;
        }
        
        .node-type {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .node-type span {
            background-color: #eee;
            padding: 2px 6px;
            border-radius: 3px;
            margin-right: 3px;
        }
        
		.connection-points {
			display: flex;
			justify-content: space-between;
			padding: 5px 10px;
			background-color: #f0f0f0;
			border-radius: 0 0 6px 6px;
		}

		.connection-point {
			width: 12px;
			height: 12px;
			border-radius: 50%;
			cursor: pointer;
			border: 2px solid white;
		}

		.connection-point-female {
			background-color: #e091b9; /* Pink for female */
		}

		.connection-point-male {
			background-color: #91b7e0; /* Blue for male */
		}

		.connection-point:hover {
			transform: scale(1.2);
			box-shadow: 0 0 3px rgba(0,0,0,0.3);
		}
        
        /* Node types */
        .breeding-node.reg {
            border-top: 4px solid #9575cd;
        }
        
        .breeding-node.fem {
            border-top: 4px solid #f06292;
        }
        
        .breeding-node.auto {
            border-top: 4px solid #ffb74d;
        }
        
        .breeding-node.photo {
            border-top: 4px solid #4db6ac;
        }
        
        .breeding-node.fast {
            border-top: 4px solid #4fc3f7;
        }
        
        .breeding-node.cross {
            border-top: 4px solid #673ab7;
            background-color: rgba(237, 231, 246, 0.9);
        }
        
        /* SVG Connector styling */
        .connection-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        
        .connector {
            stroke: #b39ddb;
            stroke-width: 2;
            fill: none;
            stroke-dasharray: none;
            marker-end: url(#arrowhead);
        }
        
        .connector-highlight {
            stroke: #673ab7;
            stroke-width: 3;
        }

		.type-selection {
			display: flex;
			flex-direction: column;
			gap: 12px;
		}

		.type-group {
			display: flex;
			flex-direction: column;
			gap: 5px;
		}

		.type-group > div {
			display: flex;
			gap: 15px;
		}

		.type-group label {
			display: flex;
			align-items: center;
			gap: 5px;
			cursor: pointer;
			color: #ddd;
		}

		.type-group input[type="radio"],
		.type-group input[type="checkbox"] {
			margin: 0;
			cursor: pointer;
		}
        
        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        
        .modal.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
		.modal-content {
			background-color: #333;
			border-radius: 8px;
			width: 350px; /* Reduced from 400px */
			max-width: 90vw;
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
			display: flex;
			flex-direction: column;
			border: 1px solid #444;
			overflow: hidden; /* Ensure content doesn't overflow */
		}
        
        .modal-header {
            padding: 15px;
            border-bottom: 1px solid #444;
            font-weight: 600;
            color: #fff;
        }
        
		.modal-body {
			padding: 15px;
			max-height: 70vh;
			overflow-y: auto;
			color: #ddd;
			box-sizing: border-box; /* Ensure padding is included in size calculation */
		}
        
        .modal-footer {
            padding: 15px;
            border-top: 1px solid #444;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        .btn {
            padding: 8px 16px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-weight: 500;
        }
        
        .btn-primary {
            background-color: #2d5e32;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #1a3c20;
        }
        
        .btn-secondary {
            background-color: #444;
            color: #fff;
        }
        
        .btn-secondary:hover {
            background-color: #555;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #ccc;
        }
        
		.form-input {
			width: 100%;
			padding: 8px;
			border: 1px solid #555;
			background-color: #222;
			color: #fff;
			border-radius: 4px;
			box-sizing: border-box; /* Ensure padding is included in width */
			max-width: 100%; /* Ensure it doesn't exceed container */
		}
        
        .form-input:focus {
            border-color: #5d4a7e;
            outline: none;
        }
        
        .help-text {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 300px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            z-index: 50;
        }
        
        /* Context menu */
        .context-menu {
            position: absolute;
            background-color: #333;
            border: 1px solid #444;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 100;
            min-width: 150px;
            display: none;
        }
        
        .context-menu.visible {
            display: block;
        }
        
        .menu-item {
            padding: 8px 12px;
            cursor: pointer;
            color: #ddd;
        }
        
        .menu-item:hover {
            background-color: #444;
        }
        
        .menu-divider {
            height: 1px;
            background-color: #444;
            margin: 4px 0;
        }
    </style>
</head>
<body>
    <header>
        <h2>Strain Breeding Planner</h2>
    </header>
    
    <div class="main-container">
        <div class="sidebar">
            <div class="sidebar-header">
                <h3>Strain Collection</h3>
            </div>
            
            <div class="search-box">
                <input type="text" id="search-input" placeholder="Search strains...">
                <button id="search-btn">Search</button>
            </div>
            
            <div class="filter-tabs">
                <div class="filter-tab active" data-filter="all">ALL</div>
                <div class="filter-tab" data-filter="reg">REG</div>
                <div class="filter-tab" data-filter="fem">FEM</div>
                <div class="filter-tab" data-filter="auto">AUTO</div>
                <div class="filter-tab" data-filter="photo">PHOTO</div>
                <div class="filter-tab" data-filter="fast">FAST</div>
            </div>
            
            <div class="strain-list" id="strain-list">
                <!-- Strains will be loaded here -->
                <div class="strain-item">
                    <div class="strain-info">
                        <div class="strain-name">Loading strains...</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="canvas-container" id="canvas-container">
            <div class="canvas-tools">
                <button class="canvas-tool" id="new-diagram">New</button>
                <button class="canvas-tool" id="save-diagram">Save</button>
                <button class="canvas-tool" id="load-diagram">Load</button>
            </div>
            
            <div class="arrange-options">
                <button class="canvas-tool" id="arrange-tree">Arrange Tree</button>
                <button class="canvas-tool" id="center-view">Center View</button>
            </div>
            
            <div class="breeding-canvas" id="breeding-canvas">
                <!-- SVG for connections -->
                <svg class="connection-svg" id="connection-svg">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                            refX="10" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#b39ddb" />
                        </marker>
                    </defs>
                    <g id="connections-group"></g>
                </svg>
                <!-- Nodes will be added here -->
            </div>
            
            <div class="help-text">
                Click on strains to add them to the diagram. Connect strains by dragging from one connection point to another. Right-click nodes for more options.
            </div>
        </div>
    </div>
    
	<!-- Name Cross Modal -->
	<div class="modal" id="name-cross-modal">
		<div class="modal-content">
			<div class="modal-header">Name Your Cross</div>
			<div class="modal-body">
				<div class="form-group">
					<label class="form-label">Parents</label>
					<div id="cross-parents" style="color: #aaa;"></div>
				</div>
				<div class="form-group">
					<label class="form-label">Default Name</label>
					<div id="default-cross-name" style="color: #fff;"></div>
				</div>
				<div class="form-group">
					<label class="form-label">Custom Name (optional)</label>
					<input type="text" class="form-input" id="custom-cross-name" placeholder="Enter a custom name">
				</div>
				<div class="form-group" id="cross-type-container">
					<!-- Type selection will be inserted here -->
				</div>
			</div>
			<div class="modal-footer">
				<button class="btn btn-secondary" id="cancel-cross-btn">Cancel</button>
				<button class="btn btn-primary" id="create-cross-btn">Create Cross</button>
			</div>
		</div>
	</div>
    
    <!-- Save/Load Modals -->
    <div class="modal" id="save-diagram-modal">
        <div class="modal-content">
            <div class="modal-header">Save Breeding Plan</div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Plan Name</label>
                    <input type="text" class="form-input" id="diagram-name" placeholder="Enter a name for this breeding plan">
                </div>
                <div class="form-group">
                    <label class="form-label">Notes (optional)</label>
                    <textarea class="form-input" id="diagram-notes" rows="4" placeholder="Enter any notes about this breeding plan"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="cancel-save-btn">Cancel</button>
                <button class="btn btn-primary" id="confirm-save-btn">Save Plan</button>
            </div>
        </div>
    </div>
    
    <div class="modal" id="load-diagram-modal">
        <div class="modal-content">
            <div class="modal-header">Load Breeding Plan</div>
            <div class="modal-body">
                <div id="saved-diagrams-list">
                    Loading saved plans...
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="cancel-load-btn">Cancel</button>
                <button class="btn btn-primary" id="confirm-load-btn">Load Plan</button>
            </div>
        </div>
    </div>
    
    <!-- Context Menu -->
    <div class="context-menu" id="node-context-menu">
        <div class="menu-item" id="context-edit">Edit Node</div>
        <div class="menu-item" id="context-duplicate">Duplicate</div>
        <div class="menu-divider"></div>
        <div class="menu-item" id="context-remove">Remove Node</div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Configuration
            const sheetId = '1A7kFjfw6cjmQQOwz-5liWVGgFK0K5lwS8AfIZ_Zthbg';
            const nodeSpacing = {
                horizontal: 250,
                vertical: 120
            };
            
            // DOM Elements
            const strainList = document.getElementById('strain-list');
            const searchInput = document.getElementById('search-input');
            const searchBtn = document.getElementById('search-btn');
            const filterTabs = document.querySelectorAll('.filter-tab');
            
            const canvasContainer = document.getElementById('canvas-container');
            const breedingCanvas = document.getElementById('breeding-canvas');
            const connectionsSvg = document.getElementById('connection-svg');
            const connectionsGroup = document.getElementById('connections-group');
            
            // Buttons
            const newDiagramBtn = document.getElementById('new-diagram');
            const saveDiagramBtn = document.getElementById('save-diagram');
            const loadDiagramBtn = document.getElementById('load-diagram');
            const arrangeTreeBtn = document.getElementById('arrange-tree');
            const centerViewBtn = document.getElementById('center-view');
            
            // Modals
            const nameCrossModal = document.getElementById('name-cross-modal');
            const crossParents = document.getElementById('cross-parents');
            const defaultCrossName = document.getElementById('default-cross-name');
            const customCrossName = document.getElementById('custom-cross-name');
            const crossType = document.getElementById('cross-type');
            const cancelCrossBtn = document.getElementById('cancel-cross-btn');
            const createCrossBtn = document.getElementById('create-cross-btn');
            
            const saveDiagramModal = document.getElementById('save-diagram-modal');
            const diagramName = document.getElementById('diagram-name');
            const diagramNotes = document.getElementById('diagram-notes');
            const cancelSaveBtn = document.getElementById('cancel-save-btn');
            const confirmSaveBtn = document.getElementById('confirm-save-btn');
            
            const loadDiagramModal = document.getElementById('load-diagram-modal');
            const savedDiagramsList = document.getElementById('saved-diagrams-list');
            const cancelLoadBtn = document.getElementById('cancel-load-btn');
            const confirmLoadBtn = document.getElementById('confirm-load-btn');
            
            // Context Menu
            const nodeContextMenu = document.getElementById('node-context-menu');
            const contextEdit = document.getElementById('context-edit');
            const contextDuplicate = document.getElementById('context-duplicate');
            const contextRemove = document.getElementById('context-remove');
            
            // State
            let allStrains = [];
            let nodes = [];
            let connections = [];
            let nodeCounter = 0;
            let selectedNode = null;
            let connecting = false;
            let connectingSourceNode = null;
            let contextMenuTargetNode = null;
            let tempLine = null;
            let pendingCrossData = null;
            let selectedDiagramIndex = -1;
            
            // Pan & Zoom state
            let isPanning = false;
            let panStart = { x: 0, y: 0 };
            let canvasOffset = { x: 0, y: 0 };
            
            // Initialize
            initializeCanvas();
            loadStrains();
            setupEventListeners();
            
            // Functions
            function initializeCanvas() {
                // Set initial canvas position
                centerCanvas();
                
                // Update SVG size
                updateSvgSize();
            }
            
            function centerCanvas() {
                canvasOffset.x = (canvasContainer.clientWidth - breedingCanvas.clientWidth) / 2;
                canvasOffset.y = (canvasContainer.clientHeight - breedingCanvas.clientHeight) / 2;
                updateCanvasPosition();
            }
            
            function updateCanvasPosition() {
                breedingCanvas.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px)`;
            }
            
            function updateSvgSize() {
                connectionsSvg.setAttribute('width', breedingCanvas.clientWidth);
                connectionsSvg.setAttribute('height', breedingCanvas.clientHeight);
            }
            
            function loadStrains() {
                strainList.innerHTML = '<div class="strain-item"><div class="strain-info"><div class="strain-name">Loading strains...</div></div></div>';
                
                const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv`;
                
                fetch(csvUrl)
                    .then(response => {
                        if (!response.ok) throw new Error('Network error');
                        return response.text();
                    })
                    .then(csv => {
                        allStrains = parseCSV(csv);
                        renderStrainList(allStrains);
                    })
                    .catch(error => {
                        console.error('Error loading data:', error);
                        strainList.innerHTML = '<div class="strain-item"><div class="strain-info"><div class="strain-name">Error loading strains</div></div></div>';
                    });
            }
            
            function parseCSV(csv) {
                const lines = csv.split('\n');
                const headers = lines[0].split(',').map(header => header.trim());
                
                const result = [];
                for (let i = 1; i < lines.length; i++) {
                    if (!lines[i].trim()) continue;
                    
                    // Handle quoted fields with commas
                    const values = parseCSVLine(lines[i]);
                    
                    if (values.length < 2 || !values[0].trim()) continue;
                    if (values[0].trim().toUpperCase() === 'STRAIN' || values[0].trim() === 'Unnamed Seed') continue;
                    
                    const entry = {};
                    for (let j = 0; j < headers.length; j++) {
                        entry[headers[j]] = j < values.length ? values[j].trim() : '';
                    }
                    
                    // Generate unique ID
                    entry.id = `strain-${i}`;
                    result.push(entry);
                }
                
                return result;
            }
            
            function parseCSVLine(line) {
                let results = [];
                let currentValue = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        results.push(currentValue);
                        currentValue = '';
                    } else {
                        currentValue += char;
                    }
                }
                
                results.push(currentValue);
                return results;
            }
            
            function renderStrainList(strains) {
                if (!strains.length) {
                    strainList.innerHTML = '<div class="strain-item"><div class="strain-info"><div class="strain-name">No strains found</div></div></div>';
                    return;
                }
                
                strainList.innerHTML = '';
                
                strains.forEach(strain => {
                    const strainName = strain.STRAIN || strain.Strain || strain.Name || 'Unnamed';
                    const count = strain.COUNT || strain.Count || '';
                    const type = strain['REG / FEM'] || strain.Type || '';
                    
                    // Create type tags
                    let tags = '';
                    if (type.toLowerCase().includes('reg')) tags += '<span class="strain-tag tag-reg">REG</span>';
                    if (type.toLowerCase().includes('fem')) tags += '<span class="strain-tag tag-fem">FEM</span>';
                    if (type.toLowerCase().includes('auto')) tags += '<span class="strain-tag tag-auto">AUTO</span>';
                    if (type.toLowerCase().includes('photo')) tags += '<span class="strain-tag tag-photo">PHOTO</span>';
                    if (type.toLowerCase().includes('fast')) tags += '<span class="strain-tag tag-fast">FAST</span>';
                    
                    const item = document.createElement('div');
                    item.className = 'strain-item';
                    item.dataset.id = strain.id;
                    
                    item.innerHTML = `
                        <div class="strain-info">
                            <div class="strain-name">${strainName}</div>
                            <div class="strain-type">${tags}</div>
                        </div>
                        <div class="strain-count">${count}</div>
                    `;
                    
                    item.addEventListener('click', () => addStrainToCanvas(strain));
                    
                    strainList.appendChild(item);
                });
            }
            
            function setupEventListeners() {
                // Canvas pan events
                canvasContainer.addEventListener('mousedown', startPan);
                document.addEventListener('mousemove', doPan);
                document.addEventListener('mouseup', endPan);
                
                // General canvas events
                canvasContainer.addEventListener('click', handleCanvasClick);
                canvasContainer.addEventListener('contextmenu', handleContextMenu);
                document.addEventListener('click', hideContextMenu);
                
                // Search & filter
                searchBtn.addEventListener('click', performSearch);
                searchInput.addEventListener('keyup', e => {
                    if (e.key === 'Enter') performSearch();
                });
                
                filterTabs.forEach(tab => {
                    tab.addEventListener('click', function() {
                        filterTabs.forEach(t => t.classList.remove('active'));
                        this.classList.add('active');
                        filterStrains(this.dataset.filter);
                    });
                });
                
                // Action buttons
                newDiagramBtn.addEventListener('click', newDiagram);
                saveDiagramBtn.addEventListener('click', showSaveModal);
                loadDiagramBtn.addEventListener('click', showLoadModal);
                arrangeTreeBtn.addEventListener('click', arrangeTreeLayout);
                centerViewBtn.addEventListener('click', centerView);
                
                // Cross modal
                cancelCrossBtn.addEventListener('click', () => hideModal(nameCrossModal));
                createCrossBtn.addEventListener('click', createCross);
                
                // Save modal
                cancelSaveBtn.addEventListener('click', () => hideModal(saveDiagramModal));
                confirmSaveBtn.addEventListener('click', saveDiagram);
                
                // Load modal
                cancelLoadBtn.addEventListener('click', () => hideModal(loadDiagramModal));
                confirmLoadBtn.addEventListener('click', loadSelectedDiagram);
                
                // Context menu items
                contextEdit.addEventListener('click', () => {
                    // Future feature: edit node properties
                    hideContextMenu();
                });
                
                contextDuplicate.addEventListener('click', () => {
                    if (contextMenuTargetNode) {
                        duplicateNode(contextMenuTargetNode);
                    }
                    hideContextMenu();
                });
                
                contextRemove.addEventListener('click', () => {
                    if (contextMenuTargetNode) {
                        removeNode(contextMenuTargetNode);
                    }
                    hideContextMenu();
                });
                
                // Window resize
                window.addEventListener('resize', updateSvgSize);
            }
            
            // Canvas Pan/Zoom
            function startPan(e) {
                // Only pan with middle mouse button or when not on a node or connection point
                if (e.button !== 1 && (e.target.closest('.breeding-node') || e.target.closest('.connection-point'))) {
                    return;
                }
                
                e.preventDefault();
                isPanning = true;
                panStart = { x: e.clientX, y: e.clientY };
            }
            
            function doPan(e) {
                if (!isPanning) return;
                
                const dx = e.clientX - panStart.x;
                const dy = e.clientY - panStart.y;
                
                canvasOffset.x += dx;
                canvasOffset.y += dy;
                
                updateCanvasPosition();
                
                panStart = { x: e.clientX, y: e.clientY };
            }
            
            function endPan() {
                isPanning = false;
            }
            
			function centerView() {
				// If no nodes, just center canvas
				if (nodes.length === 0) {
					centerCanvas();
					return;
				}
				
				// Find bounding box of all nodes
				let minX = Infinity, minY = Infinity;
				let maxX = -Infinity, maxY = -Infinity;
				
				nodes.forEach(node => {
					const nodeEl = document.getElementById(node.id);
					if (nodeEl) {
						const left = parseInt(nodeEl.style.left || '0');
						const top = parseInt(nodeEl.style.top || '0');
						const width = nodeEl.offsetWidth || 200;
						const height = nodeEl.offsetHeight || 100;
						
						minX = Math.min(minX, left);
						minY = Math.min(minY, top);
						maxX = Math.max(maxX, left + width);
						maxY = Math.max(maxY, top + height);
					}
				});
				
				// Add padding
				minX -= 100;
				minY -= 100;
				maxX += 100;
				maxY += 100;
				
				// Calculate center of nodes
				const centerX = (minX + maxX) / 2;
				const centerY = (minY + maxY) / 2;
				
				// Calculate new canvas position to center the nodes
				canvasOffset.x = canvasContainer.clientWidth / 2 - centerX;
				canvasOffset.y = canvasContainer.clientHeight / 2 - centerY;
				
				updateCanvasPosition();
			}
            
            // Search and Filter
            function performSearch() {
                const searchTerm = searchInput.value.trim().toLowerCase();
                
                if (!searchTerm) {
                    renderStrainList(allStrains);
                    return;
                }
                
                const filteredStrains = allStrains.filter(strain => {
                    const name = (strain.STRAIN || strain.Strain || strain.Name || '').toLowerCase();
                    const breeder = (strain.BREEDER || strain.Breeder || '').toLowerCase();
                    const type = (strain['REG / FEM'] || strain.Type || '').toLowerCase();
                    const parent1 = (strain.PARENT1 || strain.parent1 || '').toLowerCase();
                    const parent2 = (strain.PARENT2 || strain.parent2 || '').toLowerCase();
                    
                    return name.includes(searchTerm) || 
                        breeder.includes(searchTerm) || 
                        type.includes(searchTerm) || 
                        parent1.includes(searchTerm) || 
                        parent2.includes(searchTerm);
                });
                
                renderStrainList(filteredStrains);
            }
            
            function filterStrains(filter) {
                if (filter === 'all') {
                    renderStrainList(allStrains);
                    return;
                }
                
                const filteredStrains = allStrains.filter(strain => {
                    const type = (strain['REG / FEM'] || strain.Type || '').toLowerCase();
                    return type.includes(filter.toLowerCase());
                });
                
                renderStrainList(filteredStrains);
            }
            
            // Node Operations
			function addStrainToCanvas(strain) {
				nodeCounter++;
				const nodeId = `node-${nodeCounter}`;
				
				// Get data from strain
				const strainName = strain.STRAIN || strain.Strain || strain.Name || 'Unnamed';
				const type = strain['REG / FEM'] || strain.Type || '';
				const breeder = strain.BREEDER || strain.Breeder || '';
				const parent1 = strain.PARENT1 || strain.parent1 || '';
				const parent2 = strain.PARENT2 || strain.parent2 || '';
				
				// Parse traits - a strain can have multiple traits
				const traits = {
					growthType: type.toLowerCase().includes('auto') ? 'AUTO' : 
								type.toLowerCase().includes('photo') ? 'PHOTO' : '',
					sexType: type.toLowerCase().includes('reg') ? 'REG' : 
							type.toLowerCase().includes('fem') ? 'FEM' : '',
					floweringType: type.toLowerCase().includes('fast') ? 'FAST' : ''
				};
				
				// Determine node class
				let nodeClass = 'breeding-node';
				
				// Create node element
				const node = document.createElement('div');
				node.id = nodeId;
				node.className = nodeClass;
				node.dataset.name = strainName;
				node.dataset.type = type;
				node.dataset.growthType = traits.growthType;
				node.dataset.sexType = traits.sexType;
				node.dataset.floweringType = traits.floweringType;
				
				// Set the starting position
				const x = (canvasContainer.scrollLeft - canvasOffset.x) + canvasContainer.clientWidth / 2 - 80;
				const y = (canvasContainer.scrollTop - canvasOffset.y) + canvasContainer.clientHeight / 2 - 60;
				
				node.style.left = `${x}px`;
				node.style.top = `${y}px`;
				
				// Create trait tags HTML
				let traitsHTML = '';
				if (traits.growthType) traitsHTML += `<span class="strain-trait ${traits.growthType.toLowerCase()}">${traits.growthType}</span>`;
				if (traits.sexType) traitsHTML += `<span class="strain-trait ${traits.sexType.toLowerCase()}">${traits.sexType}</span>`;
				if (traits.floweringType) traitsHTML += `<span class="strain-trait ${traits.floweringType.toLowerCase()}">${traits.floweringType}</span>`;
				
				node.innerHTML = `
					<div class="node-header">
						<div class="node-name">${strainName}</div>
						<div class="node-controls">
							<div class="node-control" data-action="remove" title="Remove">×</div>
						</div>
					</div>
					<div class="node-content">
						<div class="node-traits">${traitsHTML}</div>
						${breeder ? `<div class="node-breeder">Breeder: ${breeder}</div>` : ''}
						${parent1 || parent2 ? `
							<div class="node-parents">
								${parent1 ? `<div>Parent 1: ${parent1}</div>` : ''}
								${parent2 ? `<div>Parent 2: ${parent2}</div>` : ''}
							</div>
						` : ''}
					</div>
					<div class="connection-points">
						<div class="connection-point connection-point-female" data-node="${nodeId}" data-role="female" title="Connect as Female (Mother)"></div>
						<div class="connection-point connection-point-male" data-node="${nodeId}" data-role="male" title="Connect as Male (Father)"></div>
					</div>
				`;
				
				// Make node draggable
				node.addEventListener('mousedown', startDraggingNode);
				
				// Setup connection points
				node.querySelectorAll('.connection-point').forEach(point => {
					point.addEventListener('mousedown', startConnecting);
				});
				
				// Setup remove button
				const removeButton = node.querySelector('[data-action="remove"]');
				removeButton.addEventListener('click', e => {
					e.preventDefault();
					e.stopPropagation();
					removeNode(nodeId);
				});
				
				// Add to canvas
				breedingCanvas.appendChild(node);
				
				// Add to nodes array
				nodes.push({
					id: nodeId,
					name: strainName,
					type: type,
					growthType: traits.growthType,
					sexType: traits.sexType,
					floweringType: traits.floweringType,
					origin: 'strain',
					parent1: parent1,
					parent2: parent2,
					breeder: breeder,
					children: [],
					parents: []
				});
				
				selectNode(nodeId);
				return nodeId;
			}
            
			function createCross() {
				if (!pendingCrossData) return;
				
				// Get data from form
				const customName = customCrossName.value.trim();
				const finalName = customName || pendingCrossData.defaultName;
				
				// Get selected types from radio buttons and checkboxes
				const growthType = document.querySelector('input[name="growth-type"]:checked')?.value || 'PHOTO';
				const seedType = document.querySelector('input[name="seed-type"]:checked')?.value || 'REG';
				const floweringType = document.querySelector('input[name="flowering-type"]:checked') ? 'FAST' : '';
				
				// Create cross data
				const crossData = {
					parent1: pendingCrossData.femaleId,
					parent2: pendingCrossData.maleId,
					parent1Name: pendingCrossData.femaleName,
					parent2Name: pendingCrossData.maleName,
					name: finalName,
					growthType: growthType,
					sexType: seedType,
					floweringType: floweringType
				};
				
				// Add cross node to canvas
				const newNodeId = addCrossNodeToCanvas(crossData);
				
				// Hide modal and reset
				hideModal(nameCrossModal);
				customCrossName.value = '';
				pendingCrossData = null;
				
				// Force update all connections to ensure visibility
				setTimeout(() => {
					connections.forEach(conn => {
						updateConnection(conn.source, conn.target);
					});
				}, 100);
			}

			function addCrossNodeToCanvas(crossData) {
				nodeCounter++;
				const nodeId = `node-${nodeCounter}`;
				
				// Create node element with proper highlighting for cross
				const node = document.createElement('div');
				node.id = nodeId;
				node.className = 'breeding-node cross';
				node.dataset.name = crossData.name;
				node.dataset.type = crossData.type;
				node.dataset.growthType = crossData.growthType;
				node.dataset.sexType = crossData.sexType;
				node.dataset.floweringType = crossData.floweringType;
				
				// Calculate position between parents but below
				const parent1El = document.getElementById(crossData.parent1);
				const parent2El = document.getElementById(crossData.parent2);
				
				if (parent1El && parent2El) {
					const p1Rect = parent1El.getBoundingClientRect();
					const p2Rect = parent2El.getBoundingClientRect();
					
					const p1Left = parseInt(parent1El.style.left);
					const p1Top = parseInt(parent1El.style.top);
					const p2Left = parseInt(parent2El.style.left);
					const p2Top = parseInt(parent2El.style.top);
					
					const newLeft = Math.min(p1Left, p2Left) + Math.abs(p1Left - p2Left) / 2;
					const newTop = Math.max(p1Top, p2Top) + 150;
					
					node.style.left = `${newLeft}px`;
					node.style.top = `${newTop}px`;
				} else {
					// Fallback position
					node.style.left = '500px';
					node.style.top = '300px';
				}
				
				// Create trait tags HTML
				let traitsHTML = '';
				if (crossData.growthType) {
					traitsHTML += `<span class="strain-trait ${crossData.growthType.toLowerCase()}">${crossData.growthType}</span>`;
				}
				if (crossData.sexType) {
					traitsHTML += `<span class="strain-trait ${crossData.sexType.toLowerCase()}">${crossData.sexType}</span>`;
				}
				if (crossData.floweringType) {
					traitsHTML += `<span class="strain-trait ${crossData.floweringType.toLowerCase()}">${crossData.floweringType}</span>`;
				}
				
				node.innerHTML = `
					<div class="node-header">
						<div class="node-name">${crossData.name}</div>
						<div class="node-controls">
							<div class="node-control" data-action="remove" title="Remove">×</div>
						</div>
					</div>
					<div class="node-content">
						<div class="node-traits">${traitsHTML}</div>
						<div class="node-parents">
							<div>Parent 1: ${crossData.parent1Name}</div>
							<div>Parent 2: ${crossData.parent2Name}</div>
						</div>
					</div>
					<div class="connection-points">
						<div class="connection-point connection-point-female" data-node="${nodeId}" data-role="female" title="Connect as Female (Mother)"></div>
						<div class="connection-point connection-point-male" data-node="${nodeId}" data-role="male" title="Connect as Male (Father)"></div>
					</div>
				`;
				
				// Make node draggable
				node.addEventListener('mousedown', startDraggingNode);
				
				// Setup connection points
				node.querySelectorAll('.connection-point').forEach(point => {
					point.addEventListener('mousedown', startConnecting);
				});
				
				// Setup remove button
				const removeButton = node.querySelector('[data-action="remove"]');
				removeButton.addEventListener('click', e => {
					e.preventDefault();
					e.stopPropagation();
					removeNode(nodeId);
				});
				
				// Add to canvas
				breedingCanvas.appendChild(node);
				
				// Add to nodes array
				const newNode = {
					id: nodeId,
					name: crossData.name,
					type: crossData.type,
					growthType: crossData.growthType,
					sexType: crossData.sexType,
					floweringType: crossData.floweringType,
					origin: 'cross',
					parent1: crossData.parent1Name,
					parent2: crossData.parent2Name,
					children: [],
					parents: [crossData.parent1, crossData.parent2]
				};
				
				nodes.push(newNode);
				
				// Update parent nodes to have this as a child
				const parent1Node = nodes.find(n => n.id === crossData.parent1);
				const parent2Node = nodes.find(n => n.id === crossData.parent2);
				
				if (parent1Node) parent1Node.children.push(nodeId);
				if (parent2Node) parent2Node.children.push(nodeId);
				
				// Create connections
				addConnection(crossData.parent1, nodeId);
				addConnection(crossData.parent2, nodeId);
				
				// Make sure connections are visible
				setTimeout(() => {
					updateConnection(crossData.parent1, nodeId);
					updateConnection(crossData.parent2, nodeId);
				}, 50);
				
				selectNode(nodeId);
				return nodeId;
			}
            
            function duplicateNode(nodeId) {
                const nodeData = nodes.find(node => node.id === nodeId);
                if (!nodeData) return;
                
                const nodeElement = document.getElementById(nodeId);
                if (!nodeElement) return;
                
                nodeCounter++;
                const newNodeId = `node-${nodeCounter}`;
                
                // Create a clone of the node with new ID
                const clone = nodeElement.cloneNode(true);
                clone.id = newNodeId;
                
                // Update connection point data
                const connectionPoint = clone.querySelector('.connection-point');
                connectionPoint.dataset.node = newNodeId;
                
                // Position slightly offset from original
                const originalLeft = parseInt(nodeElement.style.left);
                const originalTop = parseInt(nodeElement.style.top);
                
                clone.style.left = `${originalLeft + 30}px`;
                clone.style.top = `${originalTop + 30}px`;
                
                // Add event listeners to clone
                clone.addEventListener('mousedown', startDraggingNode);
                
                const cloneConnectionPoint = clone.querySelector('.connection-point');
                cloneConnectionPoint.addEventListener('mousedown', startConnecting);
                
                const removeButton = clone.querySelector('[data-action="remove"]');
                removeButton.addEventListener('click', e => {
                    e.preventDefault();
                    e.stopPropagation();
                    removeNode(newNodeId);
                });
                
                // Add to canvas
                breedingCanvas.appendChild(clone);
                
                // Add to nodes array
                const newNodeData = {
                    ...JSON.parse(JSON.stringify(nodeData)),
                    id: newNodeId,
                    name: `${nodeData.name} (Copy)`,
                    children: [],
                    parents: []
                };
                
                nodes.push(newNodeData);
                
                selectNode(newNodeId);
                return newNodeId;
            }
            
            function removeNode(nodeId) {
                // Remove connections to/from this node
                removeConnectionsForNode(nodeId);
                
                // Remove node element
                const nodeElement = document.getElementById(nodeId);
                if (nodeElement) nodeElement.remove();
                
                // Find node data
                const nodeIndex = nodes.findIndex(node => node.id === nodeId);
                if (nodeIndex === -1) return;
                
                const nodeData = nodes[nodeIndex];
                
                // Update parent nodes to remove this as a child
                nodeData.parents.forEach(parentId => {
                    const parentNode = nodes.find(n => n.id === parentId);
                    if (parentNode) {
                        parentNode.children = parentNode.children.filter(id => id !== nodeId);
                    }
                });
                
                // Update child nodes to remove this as a parent
                nodeData.children.forEach(childId => {
                    const childNode = nodes.find(n => n.id === childId);
                    if (childNode) {
                        childNode.parents = childNode.parents.filter(id => id !== nodeId);
                    }
                });
                
                // Remove from nodes array
                nodes.splice(nodeIndex, 1);
                
                if (selectedNode === nodeId) {
                    deselectAllNodes();
                }
            }
            
            function startDraggingNode(e) {
                // Don't drag if clicking connection point or control
                if (e.target.classList.contains('connection-point') || 
                    e.target.classList.contains('node-control')) {
                    return;
                }
                
                e.preventDefault();
                e.stopPropagation();
                
                // Find the node element (could be child of node)
                const nodeElement = e.target.closest('.breeding-node');
                if (!nodeElement) return;
                
                // Select this node
                selectNode(nodeElement.id);
                
                // Calculate offset within the node
                const rect = nodeElement.getBoundingClientRect();
                const offsetX = e.clientX - rect.left;
                const offsetY = e.clientY - rect.top;
                
                function moveNode(moveEvent) {
                    const canvasRect = breedingCanvas.getBoundingClientRect();
                    const newLeft = moveEvent.clientX - canvasRect.left - offsetX;
                    const newTop = moveEvent.clientY - canvasRect.top - offsetY;
                    
                    nodeElement.style.left = `${newLeft}px`;
                    nodeElement.style.top = `${newTop}px`;
                    
                    // Update connections
                    updateConnectionsForNode(nodeElement.id);
                }
                
                function endDrag() {
                    document.removeEventListener('mousemove', moveNode);
                    document.removeEventListener('mouseup', endDrag);
                }
                
                document.addEventListener('mousemove', moveNode);
                document.addEventListener('mouseup', endDrag);
            }
            
            function selectNode(nodeId) {
                // Deselect any currently selected node
                deselectAllNodes();
                
                // Select the new node
                const nodeElement = document.getElementById(nodeId);
                if (nodeElement) {
                    nodeElement.classList.add('selected');
                    selectedNode = nodeId;
                }
            }
            
            function deselectAllNodes() {
                document.querySelectorAll('.breeding-node.selected').forEach(node => {
                    node.classList.remove('selected');
                });
                selectedNode = null;
            }
            
            // Connection Operations
			function startConnecting(e) {
				e.preventDefault();
				e.stopPropagation();
				
				const connectionPoint = e.target;
				const nodeId = connectionPoint.dataset.node;
				const role = connectionPoint.dataset.role; // 'female' or 'male'
				
				connecting = true;
				connectingSourceNode = nodeId;
				connectingRole = role;
				
				// Create temporary SVG line
				tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
				tempLine.setAttribute('stroke', role === 'female' ? '#e091b9' : '#91b7e0');
				tempLine.setAttribute('stroke-width', '2');
				tempLine.setAttribute('fill', 'none');
				tempLine.setAttribute('marker-end', 'url(#arrowhead)');
				
				connectionsGroup.appendChild(tempLine);
				
				// Add mouse move and up handlers
				document.addEventListener('mousemove', updateTempConnection);
				document.addEventListener('mouseup', finishConnection);
			}

			function updateTempConnection(e) {
				if (!connecting || !connectingSourceNode) return;
				
				const canvasRect = breedingCanvas.getBoundingClientRect();
				const sourceNode = document.getElementById(connectingSourceNode);
				if (!sourceNode) return;
				
				const sourcePoint = sourceNode.querySelector(`.connection-point-${connectingRole}`);
				const sourceRect = sourcePoint.getBoundingClientRect();
				
				const startX = sourceRect.left + sourceRect.width / 2 - canvasRect.left;
				const startY = sourceRect.top + sourceRect.height / 2 - canvasRect.top;
				
				const endX = e.clientX - canvasRect.left;
				const endY = e.clientY - canvasRect.top;
				
				// Create a curved path
				const controlPointX = (startX + endX) / 2;
				const controlPointY = (startY + endY + 50) / 2;
				
				const path = `M ${startX} ${startY} Q ${controlPointX} ${controlPointY}, ${endX} ${endY}`;
				tempLine.setAttribute('d', path);
			}

			function finishConnection(e) {
				if (!connecting || !connectingSourceNode) return;
				
				document.removeEventListener('mousemove', updateTempConnection);
				document.removeEventListener('mouseup', finishConnection);
				
				// Remove temp line
				if (tempLine) {
					tempLine.remove();
					tempLine = null;
				}
				
				// Check if mouse is over a connection point
				const element = document.elementFromPoint(e.clientX, e.clientY);
				if (element && element.classList.contains('connection-point')) {
					const targetNodeId = element.dataset.node;
					const targetRole = element.dataset.role;
					
					// Don't connect to self
					if (targetNodeId !== connectingSourceNode) {
						// Don't connect same roles (female to female or male to male)
						if (connectingRole !== targetRole) {
							// Show cross creation modal
							showNameCrossModal(connectingSourceNode, targetNodeId, connectingRole, targetRole);
						} else {
							alert('Cannot connect same types. Connect female to male or male to female.');
						}
					}
				}
				
				connecting = false;
				connectingSourceNode = null;
				connectingRole = null;
			}

			function showNameCrossModal(sourceId, targetId, sourceRole, targetRole) {
				// Determine which is female and which is male
				let femaleId, maleId;
				
				if (sourceRole === 'female') {
					femaleId = sourceId;
					maleId = targetId;
				} else {
					femaleId = targetId;
					maleId = sourceId;
				}
				
				// Get parent nodes
				const femaleNode = nodes.find(n => n.id === femaleId);
				const maleNode = nodes.find(n => n.id === maleId);
				
				if (!femaleNode || !maleNode) return;
				
				// Setup cross parent information
				crossParents.innerHTML = `
					<div>
						<span style="color: #e091b9;">♀ ${femaleNode.name}</span> × 
						<span style="color: #91b7e0;">♂ ${maleNode.name}</span>
					</div>
				`;
				
				// Set default name - female × male format
				const defaultName = `${femaleNode.name} × ${maleNode.name}`;
				defaultCrossName.textContent = defaultName;
				
				// Replace the single dropdown with properly categorized trait selections
				const typeSelectionHTML = `
					<div class="type-selection">
						<div class="type-group">
							<label><strong>Growth Type:</strong></label>
							<div>
								<label><input type="radio" name="growth-type" value="AUTO" ${femaleNode.growthType === 'AUTO' || maleNode.growthType === 'AUTO' ? 'checked' : ''}> AUTO</label>
								<label><input type="radio" name="growth-type" value="PHOTO" ${(femaleNode.growthType === 'PHOTO' || !femaleNode.growthType) && (maleNode.growthType === 'PHOTO' || !maleNode.growthType) ? 'checked' : ''}> PHOTO</label>
							</div>
						</div>
						
						<div class="type-group">
							<label><strong>Seed Type:</strong></label>
							<div>
								<label><input type="radio" name="seed-type" value="REG" ${!(femaleNode.sexType === 'FEM' || maleNode.sexType === 'FEM') ? 'checked' : ''}> REG</label>
								<label><input type="radio" name="seed-type" value="FEM" ${femaleNode.sexType === 'FEM' || maleNode.sexType === 'FEM' ? 'checked' : ''}> FEM</label>
							</div>
						</div>
						
						<div class="type-group">
							<label><strong>Flowering Type:</strong></label>
							<div>
								<label><input type="checkbox" name="flowering-type" value="FAST" ${femaleNode.floweringType === 'FAST' || maleNode.floweringType === 'FAST' ? 'checked' : ''}> FAST</label>
							</div>
						</div>
					</div>
				`;
				
				// Replace the dropdown with our new interface
				const typeSelectContainer = document.getElementById('cross-type-container');
				if (!typeSelectContainer) {
					// If the container doesn't exist yet, create a hidden element to replace
					const crossTypeInput = document.getElementById('cross-type');
					const parentElement = crossTypeInput.parentElement;
					parentElement.innerHTML = typeSelectionHTML;
				} else {
					typeSelectContainer.innerHTML = typeSelectionHTML;
				}
				
				// Store data for cross creation
				pendingCrossData = {
					femaleId: femaleId,
					maleId: maleId,
					femaleName: femaleNode.name,
					maleName: maleNode.name,
					defaultName: defaultName
				};
				
				// Show modal
				showModal(nameCrossModal);
				customCrossName.focus();
			}
            
			function addConnection(sourceId, targetId) {
				// Create connection id
				const connectionId = `connection-${sourceId}-${targetId}`;
				
				// Check if connection already exists
				if (connections.some(c => c.id === connectionId)) {
					return;
				}
				
				// Determine roles - let's say source is female parent by default
				const sourceRole = 'female';
				const targetRole = 'male';
				
				// Determine color based on roles
				const connectionColor = sourceRole === 'female' ? '#e091b9' : '#91b7e0';
				
				// Create SVG path for connection
				const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
				path.id = connectionId;
				path.classList.add('connector');
				path.setAttribute('stroke', connectionColor);
				path.setAttribute('stroke-width', '2');
				path.setAttribute('fill', 'none');
				path.setAttribute('data-source', sourceId);
				path.setAttribute('data-target', targetId);
				path.setAttribute('pointer-events', 'none'); // Make sure it doesn't interfere with clicks
				
				// Add to SVG
				connectionsGroup.appendChild(path);
				
				// Add to connections array
				connections.push({
					id: connectionId,
					source: sourceId,
					target: targetId,
					sourceRole: sourceRole,
					targetRole: targetRole,
					color: connectionColor
				});
				
				// Immediately update connection path
				setTimeout(() => updateConnection(sourceId, targetId), 50);
			}

			function updateConnection(sourceId, targetId) {
				const connectionId = `connection-${sourceId}-${targetId}`;
				const path = document.getElementById(connectionId);
				
				if (!path) return;
				
				const sourceNode = document.getElementById(sourceId);
				const targetNode = document.getElementById(targetId);
				
				if (!sourceNode || !targetNode) {
					// Remove connection if nodes don't exist
					removeConnection(connectionId);
					return;
				}
				
				// Find connection in array to get role info
				const connection = connections.find(c => c.id === connectionId);
				if (!connection) return;
				
				// Get appropriate connection points
				const sourcePoint = sourceNode.querySelector(`.connection-point-${connection.sourceRole || 'female'}`);
				const targetPoint = targetNode.querySelector(`.connection-point-${connection.targetRole || 'male'}`);
				
				if (!sourcePoint || !targetPoint) return;
				
				// Calculate positions
				const sourceRect = sourcePoint.getBoundingClientRect();
				const targetRect = targetPoint.getBoundingClientRect();
				const canvasRect = breedingCanvas.getBoundingClientRect();
				
				const startX = sourceRect.left + sourceRect.width / 2 - canvasRect.left;
				const startY = sourceRect.top + sourceRect.height / 2 - canvasRect.top;
				
				const endX = targetRect.left + targetRect.width / 2 - canvasRect.left;
				const endY = targetRect.top + targetRect.height / 2 - canvasRect.top;
				
				// Calculate distance and bend of curve
				const dx = endX - startX;
				const dy = endY - startY;
				const distance = Math.sqrt(dx * dx + dy * dy);
				
				// Use a straight line for very short distances
				if (distance < 30) {
					const pathD = `M ${startX} ${startY} L ${endX} ${endY}`;
					path.setAttribute('d', pathD);
					return;
				}
				
				// Create a curved path - for better visibility, especially when nodes overlap
				// Use cubic bezier curve for better control of path shape
				const curvature = 0.4; // Higher value means more curved
				const midX = (startX + endX) / 2;
				const midY = (startY + endY) / 2;
				
				// Perpendicular offset to create curve
				const offsetX = -dy * curvature;
				const offsetY = dx * curvature;
				
				const pathD = `M ${startX} ${startY} Q ${midX + offsetX} ${midY + offsetY}, ${endX} ${endY}`;
				path.setAttribute('d', pathD);
				
				// Set color based on role
				path.setAttribute('stroke', connection.color || '#b39ddb');
				
				// Add an arrowhead marker
				path.setAttribute('marker-end', 'url(#arrowhead)');
			}
            
            function updateConnectionsForNode(nodeId) {
                // Update all connections involving this node
                connections.forEach(conn => {
                    if (conn.source === nodeId || conn.target === nodeId) {
                        updateConnection(conn.source, conn.target);
                    }
                });
            }
            
            function removeConnectionsForNode(nodeId) {
                // Find all connections involving this node
                const nodeConnections = connections.filter(conn => 
                    conn.source === nodeId || conn.target === nodeId
                );
                
                // Remove each connection
                nodeConnections.forEach(conn => {
                    removeConnection(conn.id);
                });
            }
            
            function removeConnection(connectionId) {
                // Remove connection element
                const connectionElement = document.getElementById(connectionId);
                if (connectionElement) connectionElement.remove();
                
                // Remove from connections array
                connections = connections.filter(conn => conn.id !== connectionId);
            }
            
            // Layout Arrangement
			function arrangeTreeLayout() {
				if (nodes.length === 0) return;
				
				// Reset all potential parent-child relationships
				nodes.forEach(node => {
					node.children = [];
					node.parents = [];
				});
				
				// Rebuild relationships from connections
				connections.forEach(conn => {
					const sourceNode = nodes.find(n => n.id === conn.source);
					const targetNode = nodes.find(n => n.id === conn.target);
					
					if (sourceNode && targetNode) {
						// Source is parent of target
						if (!sourceNode.children.includes(conn.target)) {
							sourceNode.children.push(conn.target);
						}
						
						// Target is child of source
						if (!targetNode.parents.includes(conn.source)) {
							targetNode.parents.push(conn.source);
						}
					}
				});
				
				// Find root nodes (no parents)
				const rootNodes = nodes.filter(node => node.parents.length === 0);
				
				if (rootNodes.length === 0 && nodes.length > 0) {
					// If no root nodes found but we have nodes, use first node as root
					console.log("No root nodes found, using first node");
					const startX = 100;
					const startY = 100;
					positionNode(nodes[0], startX, startY, {}, 0);
				} else if (rootNodes.length > 0) {
					// Arrange from each root node
					console.log(`Found ${rootNodes.length} root nodes`);
					
					// Calculate spacing between root nodes
					const rootSpacing = Math.max(300, 800 / Math.max(1, rootNodes.length));
					let startX = 100;
					
					rootNodes.forEach(root => {
						positionNode(root, startX, 100, {}, 0);
						startX += rootSpacing;
					});
				}
				
				// Force update all connections with a slight delay
				setTimeout(() => {
					connections.forEach(conn => {
						updateConnection(conn.source, conn.target);
					});
				}, 100);
				
				// Center view with a delay
				setTimeout(centerView, 200);
			}

			function positionNode(node, x, y, placedNodes, level) {
				console.log(`Positioning node ${node.id} at (${x}, ${y}), level ${level}`);
				
				// Skip if already placed at a deeper level
				if (placedNodes[node.id] && placedNodes[node.id].level >= level) {
					return;
				}
				
				// Mark this node as placed
				placedNodes[node.id] = { x, y, level };
				
				// Position this node
				const nodeElement = document.getElementById(node.id);
				if (nodeElement) {
					nodeElement.style.left = `${x}px`;
					nodeElement.style.top = `${y}px`;
				}
				
				// If no children, we're done with this branch
				if (!node.children || node.children.length === 0) {
					return;
				}
				
				// Calculate horizontal space for children
				const childSpacing = 250; // Space between child nodes
				const totalWidth = (node.children.length - 1) * childSpacing;
				let childX = x - totalWidth / 2;
				const childY = y + 150; // Fixed vertical spacing
				
				// Position each child
				node.children.forEach(childId => {
					const childNode = nodes.find(n => n.id === childId);
					if (childNode) {
						positionNode(childNode, childX, childY, placedNodes, level + 1);
						childX += childSpacing;
					}
				});
			}

			function arrangeFromNode(node, x, y, placedNodes, level) {
				// Mark this node as placed
				placedNodes[node.id] = { x, y, level };
				
				// Position this node
				const nodeElement = document.getElementById(node.id);
				if (nodeElement) {
					nodeElement.style.left = `${x}px`;
					nodeElement.style.top = `${y}px`;
				}
				
				// If no children, we're done with this branch
				if (!node.children || node.children.length === 0) return;
				
				// Calculate space needed for children
				const childrenWidth = Math.max(300, node.children.length * nodeSpacing.horizontal);
				let startX = x - childrenWidth / 2 + nodeSpacing.horizontal / 2;
				
				// Position each child
				node.children.forEach(childId => {
					const childNode = nodes.find(n => n.id === childId);
					if (childNode && !placedNodes[childId]) {
						const childX = startX;
						const childY = y + nodeSpacing.vertical;
						
						arrangeFromNode(childNode, childX, childY, placedNodes, level + 1);
						startX += nodeSpacing.horizontal;
					} else if (childNode && placedNodes[childId]) {
						// If already placed, check if we need to move it lower
						if (placedNodes[childId].level < level + 1) {
							placedNodes[childId].level = level + 1;
							
							const childElement = document.getElementById(childId);
							if (childElement) {
								childElement.style.top = `${y + nodeSpacing.vertical}px`;
							}
						}
					}
				});
			}
            
            // UI Handlers
            function handleCanvasClick(e) {
                // If clicking on canvas background, deselect nodes
                if (e.target === breedingCanvas || e.target === canvasContainer) {
                    deselectAllNodes();
                }
            }
            
            function handleContextMenu(e) {
                e.preventDefault();
                
                // Hide existing context menu
                hideContextMenu();
                
                // Check if clicking on a node
                const nodeElement = e.target.closest('.breeding-node');
                if (nodeElement) {
                    // Set target node
                    contextMenuTargetNode = nodeElement.id;
                    
                    // Show context menu at mouse position
                    nodeContextMenu.style.left = `${e.clientX}px`;
                    nodeContextMenu.style.top = `${e.clientY}px`;
                    nodeContextMenu.classList.add('visible');
                }
            }
            
            function hideContextMenu() {
                nodeContextMenu.classList.remove('visible');
                contextMenuTargetNode = null;
            }
            
            function showModal(modal) {
                modal.classList.add('visible');
            }
            
            function hideModal(modal) {
                modal.classList.remove('visible');
            }
            
            // Diagram Management
            function newDiagram() {
                if (nodes.length > 0) {
                    if (!confirm('Are you sure you want to create a new diagram? This will clear all current nodes.')) {
                        return;
                    }
                }
                
                // Clear canvas
                breedingCanvas.querySelectorAll('.breeding-node').forEach(node => node.remove());
                connectionsGroup.innerHTML = '';
                
                // Reset state
                nodes = [];
                connections = [];
                nodeCounter = 0;
                selectedNode = null;
                
                // Reset canvas position
                centerCanvas();
            }
            
            function showSaveModal() {
                if (nodes.length === 0) {
                    alert('Nothing to save. Add some strains to your diagram first.');
                    return;
                }
                
                showModal(saveDiagramModal);
                diagramName.focus();
            }
            
            function saveDiagram() {
                const name = diagramName.value.trim();
                const notes = diagramNotes.value.trim();
                
                if (!name) {
                    alert('Please enter a name for your breeding plan.');
                    return;
                }
                
                // Capture position data for all nodes
                const nodePositions = {};
                nodes.forEach(node => {
                    const nodeEl = document.getElementById(node.id);
                    if (nodeEl) {
                        nodePositions[node.id] = {
                            left: nodeEl.style.left,
                            top: nodeEl.style.top
                        };
                    }
                });
                
                // Create save data
                const saveData = {
                    name: name,
                    notes: notes,
                    date: new Date().toISOString(),
                    nodes: nodes,
                    connections: connections,
                    positions: nodePositions
                };
                
                // Get existing saved diagrams
                let savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
                
                // Check if diagram with this name already exists
                const existingIndex = savedDiagrams.findIndex(d => d.name === name);
                if (existingIndex >= 0) {
                    if (confirm(`A breeding plan named "${name}" already exists. Overwrite it?`)) {
                        savedDiagrams[existingIndex] = saveData;
                    } else {
                        return;
                    }
                } else {
                    savedDiagrams.push(saveData);
                }
                
                // Save to localStorage
                localStorage.setItem('breedingDiagrams', JSON.stringify(savedDiagrams));
                
                // Hide modal and reset
                hideModal(saveDiagramModal);
                diagramName.value = '';
                diagramNotes.value = '';
                
                alert(`Breeding plan "${name}" saved successfully!`);
            }
            
            function showLoadModal() {
                // Get saved diagrams
                const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
                
                if (savedDiagrams.length === 0) {
                    savedDiagramsList.innerHTML = `
                        <div style="padding: 10px; text-align: center; color: #999;">
                            No saved breeding plans found
                        </div>
                    `;
                    confirmLoadBtn.disabled = true;
                } else {
                    // Create list of saved diagrams
                    let html = '<div class="saved-plans-list">';
                    
                    savedDiagrams.forEach((diagram, index) => {
                        const date = new Date(diagram.date).toLocaleDateString();
                        const nodeCount = diagram.nodes.length;
                        
                        html += `
                            <div class="saved-plan-item" style="padding: 10px; border-bottom: 1px solid #444; cursor: pointer;" 
                                data-index="${index}">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <label style="font-weight: 500; cursor: pointer;">
                                        <input type="radio" name="saved-diagram" value="${index}" 
                                            ${index === 0 ? 'checked' : ''}>
                                        ${diagram.name}
                                    </label>
                                    <span style="font-size: 12px; color: #999;">${date}</span>
                                </div>
                                <div style="font-size: 12px; color: #aaa; margin-top: 5px;">
                                    ${nodeCount} strain${nodeCount !== 1 ? 's' : ''}
                                    ${diagram.notes ? `<div style="margin-top: 5px; color: #888;">${diagram.notes}</div>` : ''}
                                </div>
                            </div>
                        `;
                    });
                    
                    html += '</div>';
                    savedDiagramsList.innerHTML = html;
                    confirmLoadBtn.disabled = false;
                    
                    // Add click handler for selection
                    document.querySelectorAll('.saved-plan-item').forEach(item => {
                        item.addEventListener('click', function() {
                            const radio = this.querySelector('input[type="radio"]');
                            radio.checked = true;
                            selectedDiagramIndex = parseInt(radio.value);
                        });
                    });
                    
                    // Set initial selection
                    selectedDiagramIndex = 0;
                }
                
                showModal(loadDiagramModal);
            }
            
            function loadSelectedDiagram() {
                // Get selected diagram
                const selectedRadio = document.querySelector('input[name="saved-diagram"]:checked');
                if (!selectedRadio) {
                    alert('Please select a breeding plan to load.');
                    return;
                }
                
                const index = parseInt(selectedRadio.value);
                const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
                
                if (index < 0 || index >= savedDiagrams.length) {
                    alert('Invalid selection.');
                    return;
                }
                
                // Check if current diagram should be cleared
                if (nodes.length > 0) {
                    if (!confirm('Loading a new diagram will replace the current one. Continue?')) {
                        return;
                    }
                }
                
                // Load the selected diagram
                const diagram = savedDiagrams[index];
                loadDiagram(diagram);
                
                // Hide modal
                hideModal(loadDiagramModal);
            }
            
            function loadDiagram(diagram) {
                // Clear existing diagram
                newDiagram();
                
                // Set the node counter to prevent ID conflicts
                if (diagram.nodes.length > 0) {
                    const nodeIds = diagram.nodes.map(n => {
                        const match = n.id.match(/node-(\d+)/);
                        return match ? parseInt(match[1]) : 0;
                    });
                    nodeCounter = Math.max(...nodeIds);
                }
                
                // Create all nodes first
                diagram.nodes.forEach(nodeData => {
                    // Create node element
                    const node = document.createElement('div');
                    node.id = nodeData.id;
                    
                    // Determine node class
                    let nodeClass = 'breeding-node';
                    if (nodeData.origin === 'cross') nodeClass += ' cross';
                    if ((nodeData.type || '').toLowerCase().includes('reg')) nodeClass += ' reg';
                    if ((nodeData.type || '').toLowerCase().includes('fem')) nodeClass += ' fem';
                    if ((nodeData.type || '').toLowerCase().includes('auto')) nodeClass += ' auto';
                    if ((nodeData.type || '').toLowerCase().includes('photo')) nodeClass += ' photo';
                    if ((nodeData.type || '').toLowerCase().includes('fast')) nodeClass += ' fast';
                    
                    node.className = nodeClass;
                    node.dataset.name = nodeData.name;
                    node.dataset.type = nodeData.type || '';
                    
                    // Type indicators
                    let typeSpans = '';
                    if ((nodeData.type || '').toLowerCase().includes('reg')) typeSpans += '<span>REG</span>';
                    if ((nodeData.type || '').toLowerCase().includes('fem')) typeSpans += '<span>FEM</span>';
                    if ((nodeData.type || '').toLowerCase().includes('auto')) typeSpans += '<span>AUTO</span>';
                    if ((nodeData.type || '').toLowerCase().includes('photo')) typeSpans += '<span>PHOTO</span>';
                    if ((nodeData.type || '').toLowerCase().includes('fast')) typeSpans += '<span>FAST</span>';
                    
                    // Set position
                    if (diagram.positions && diagram.positions[nodeData.id]) {
                        node.style.left = diagram.positions[nodeData.id].left;
                        node.style.top = diagram.positions[nodeData.id].top;
                    } else {
                        // Default position
                        node.style.left = '200px';
                        node.style.top = '200px';
                    }
                    
                    node.innerHTML = `
                        <div class="node-header">
                            <div class="node-name">${nodeData.name}</div>
                            <div class="node-controls">
                                <div class="node-control" data-action="remove" title="Remove">×</div>
                            </div>
                        </div>
                        <div class="node-content">
                            <div class="node-type">${typeSpans}</div>
                            ${nodeData.breeder ? `<div class="node-breeder">Breeder: ${nodeData.breeder}</div>` : ''}
                            ${nodeData.parent1 || nodeData.parent2 ? `
                                <div class="node-parents">
                                    ${nodeData.parent1 ? `<div>Parent 1: ${nodeData.parent1}</div>` : ''}
                                    ${nodeData.parent2 ? `<div>Parent 2: ${nodeData.parent2}</div>` : ''}
                                </div>
                            ` : ''}
                        </div>
                        <div class="connection-points">
                            <div class="connection-point" data-node="${nodeData.id}"></div>
                        </div>
                    `;
                    
                    // Make node draggable
                    node.addEventListener('mousedown', startDraggingNode);
                    
                    // Setup connection point
                    const connectionPoint = node.querySelector('.connection-point');
                    connectionPoint.addEventListener('mousedown', startConnecting);
                    
                    // Setup remove button
                    const removeButton = node.querySelector('[data-action="remove"]');
                    removeButton.addEventListener('click', e => {
                        e.preventDefault();
                        e.stopPropagation();
                        removeNode(nodeData.id);
                    });
                    
                    // Add to canvas
                    breedingCanvas.appendChild(node);
                });
                
                // Add all nodes to the state
                nodes = JSON.parse(JSON.stringify(diagram.nodes));
                
                // Create connections
                diagram.connections.forEach(conn => {
                    addConnection(conn.source, conn.target);
                });
                
                // Center the view
                centerView();
            }
        });
    </script>
</body>
</html>
