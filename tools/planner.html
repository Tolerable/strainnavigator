<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strain Breeding Planner</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #2d2d2d;
            color: #fff;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #1a3c20, #2d5e32);
            color: white;
            padding: 10px 20px;
            text-align: center;
        }
        
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .sidebar {
            width: 300px;
            background-color: #333;
            border-right: 1px solid #444;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .sidebar-header {
            padding: 10px;
            border-bottom: 1px solid #444;
            background-color: #282828;
        }
        
        .search-box {
            display: flex;
            padding: 10px;
            border-bottom: 1px solid #444;
        }
        
        .search-box input {
            flex: 1;
            padding: 8px;
            border: 1px solid #555;
            background-color: #222;
            color: #fff;
            border-radius: 4px 0 0 4px;
        }
        
        .search-box button {
            padding: 8px 15px;
            background-color: #2d5e32;
            color: white;
            border: none;
            border-radius: 0 4px 4px 0;
            cursor: pointer;
        }
        
        .filter-tabs {
            display: flex;
            overflow-x: auto;
            border-bottom: 1px solid #444;
            background-color: #282828;
        }
        
        .filter-tab {
            padding: 8px 12px;
            cursor: pointer;
            white-space: nowrap;
            font-size: 12px;
            font-weight: 500;
        }
        
        .filter-tab.active {
            background-color: #5d4a7e;
            color: white;
        }
        
        .strain-list {
            flex: 1;
            overflow-y: auto;
            background-color: #333;
        }
        
        .strain-item {
            padding: 10px 15px;
            border-bottom: 1px solid #444;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .strain-item:hover {
            background-color: #444;
        }
        
        .strain-info {
            display: flex;
            flex-direction: column;
        }
        
        .strain-name {
            font-weight: 500;
            color: #fff;
        }
        
        .strain-type {
            font-size: 12px;
            margin-top: 2px;
            display: flex;
            gap: 5px;
        }
        
        .strain-tag {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            color: white;
            font-weight: 600;
        }
        
        .tag-reg { background-color: #9575cd; }
        .tag-fem { background-color: #f06292; }
        .tag-auto { background-color: #ffb74d; }
        .tag-photo { background-color: #4db6ac; }
        .tag-fast { background-color: #4fc3f7; }
        
        .strain-count {
            background-color: rgba(93, 74, 126, 0.3);
            color: #b39ddb;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
        }

		.strain-trait.photo {
			background-color: #4db6ac;
		}

		.strain-trait.auto {
			background-color: #ffb74d;
		}

		.strain-trait.reg {
			background-color: #9575cd;
		}

		.strain-trait.fem {
			background-color: #f06292;
		}

		.strain-trait.fast {
			background-color: #4fc3f7;
		}
        
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: auto;
            background-color: #2d2d2d;
        }
        
        .canvas-tools {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            display: flex;
            gap: 5px;
            background-color: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 4px;
        }
        
        .canvas-tool {
            background-color: #333;
            border: 1px solid #444;
            color: #fff;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
        }
        
        .canvas-tool:hover {
            background-color: #444;
        }
        
        .arrange-options {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            gap: 5px;
            background-color: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 4px;
        }
        
        /* Strain nodes and connections */
        .breeding-canvas {
            position: relative;
            width: 3000px;
            height: 2000px;
        }
        
		/* Node styling for ComfyUI-like appearance */
		.breeding-node {
			background-color: #333333;
			border-radius: 6px;
			min-width: 160px;
			box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
			user-select: none;
			position: absolute;
			z-index: 10;
			border: 1px solid #444;
			color: #fff;
		}

		.strain-node {
			border-left: 3px solid #FFB74D;
		}

		.cross-node {
			border-left: 3px solid #9C27B0;
		}

		.node-header {
			background-color: #222;
			border-bottom: 1px solid #444;
			padding: 8px 10px;
			font-weight: 600;
			border-radius: 6px 6px 0 0;
			display: flex;
			justify-content: space-between;
		}

		.node-content {
			padding: 10px;
		}

		.node-traits {
			display: flex;
			flex-wrap: wrap;
			gap: 5px;
			margin-bottom: 8px;
		}

		.strain-trait {
			padding: 2px 6px;
			border-radius: 3px;
			font-size: 11px;
			font-weight: 500;
			color: white;
		}

        
        .breeding-node.selected {
            box-shadow: 0 0 0 3px #ffeb3b;
        }
        
        .node-name {
            font-weight: 600;
            word-break: break-word;
        }
        
        .node-controls {
            display: flex;
            gap: 5px;
        }
        
        .node-control {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            cursor: pointer;
            background-color: rgba(0, 0, 0, 0.1);
            color: #333;
        }
        
        .node-control:hover {
            background-color: rgba(0, 0, 0, 0.2);
        }
        
        .node-type {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .node-type span {
            background-color: #eee;
            padding: 2px 6px;
            border-radius: 3px;
            margin-right: 3px;
        }
        
		.connection-points {
			display: flex;
			justify-content: space-around;
			padding: 8px 0;
			margin-top: 5px;
		}

		/* Connection ports styling */
		.connection-input {
			display: flex;
			justify-content: center;
			position: absolute;
			width: 100%;
			top: -10px;
		}

		.connection-outputs {
			display: flex;
			justify-content: space-around;
			padding: 5px 0;
			margin-top: 5px;
			border-top: 1px solid #444;
		}

		.connection-output {
			display: flex;
			flex-direction: column;
			align-items: center;
			padding: 0 10px;
		}

		.connection-label {
			font-size: 12px;
			margin-bottom: 3px;
			color: #bbb;
		}

		.connection-point {
			width: 12px;
			height: 12px;
			border-radius: 50%;
			cursor: pointer;
			border: 2px solid #fff;
		}

		.connection-point-female {
			background-color: #e091b9;
		}

		.connection-point-male {
			background-color: #91b7e0;
		}

		.connection-point:hover {
			transform: scale(1.2);
			box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
		}

		.connection-point-input {
			background-color: #4CAF50;
			top: -5px;
		}

		/* Connection line styling */
		.connector {
			stroke-linecap: round;
			filter: drop-shadow(0 0 3px rgba(0, 0, 0, 0.3));
		}
        
        /* Node types */
        .breeding-node.reg {
            border-top: 4px solid #9575cd;
        }
        
        .breeding-node.fem {
            border-top: 4px solid #f06292;
        }
        
        .breeding-node.auto {
            border-top: 4px solid #ffb74d;
        }
        
        .breeding-node.photo {
            border-top: 4px solid #4db6ac;
        }
        
        .breeding-node.fast {
            border-top: 4px solid #4fc3f7;
        }
        
        .breeding-node.cross {
            border-top: 4px solid #673ab7;
            background-color: rgba(237, 231, 246, 0.9);
        }
        
        /* SVG Connector styling */
        .connection-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        
		.connector {
			stroke-linecap: round;
			stroke-linejoin: round;
			filter: drop-shadow(0 0 3px rgba(0, 0, 0, 0.3));
		}

		.connector-female {
			stroke: #e091b9;
		}

		.connector-male {
			stroke: #91b7e0;
		}
        
        .connector-highlight {
            stroke: #673ab7;
            stroke-width: 3;
        }

		.type-selection {
			display: flex;
			flex-direction: column;
			gap: 12px;
		}

		.type-group {
			display: flex;
			flex-direction: column;
			gap: 5px;
		}

		.type-group > div {
			display: flex;
			gap: 15px;
		}

		.type-group label {
			display: flex;
			align-items: center;
			gap: 5px;
			cursor: pointer;
			color: #ddd;
		}

		.type-group input[type="radio"],
		.type-group input[type="checkbox"] {
			margin: 0;
			cursor: pointer;
		}
        
        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        
        .modal.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
		.modal-content {
			background-color: #333;
			border-radius: 8px;
			width: 350px; /* Reduced from 400px */
			max-width: 90vw;
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
			display: flex;
			flex-direction: column;
			border: 1px solid #444;
			overflow: hidden; /* Ensure content doesn't overflow */
		}
        
        .modal-header {
            padding: 15px;
            border-bottom: 1px solid #444;
            font-weight: 600;
            color: #fff;
        }
        
		.modal-body {
			padding: 15px;
			max-height: 70vh;
			overflow-y: auto;
			color: #ddd;
			box-sizing: border-box; /* Ensure padding is included in size calculation */
		}
        
        .modal-footer {
            padding: 15px;
            border-top: 1px solid #444;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        .btn {
            padding: 8px 16px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-weight: 500;
        }
        
        .btn-primary {
            background-color: #2d5e32;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #1a3c20;
        }
        
        .btn-secondary {
            background-color: #444;
            color: #fff;
        }
        
        .btn-secondary:hover {
            background-color: #555;
        }

		.btn-danger {
			background-color: #d32f2f;
			color: white;
		}

		.btn-danger:hover {
			background-color: #b71c1c;
		}
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #ccc;
        }
        
		.form-input {
			width: 100%;
			padding: 8px;
			border: 1px solid #555;
			background-color: #222;
			color: #fff;
			border-radius: 4px;
			box-sizing: border-box; /* Ensure padding is included in width */
			max-width: 100%; /* Ensure it doesn't exceed container */
		}
        
        .form-input:focus {
            border-color: #5d4a7e;
            outline: none;
        }
        
		.help-text {
			position: fixed;
			bottom: 10px;
			left: 310px;
			background-color: rgba(0, 0, 0, 0.7);
			color: #fff;
			padding: 10px 30px 10px 10px;
			border-radius: 4px;
			font-size: 12px;
			max-width: 300px;
			box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
			z-index: 50;
		}

		.help-text-close {
			position: absolute;
			right: 5px;
			top: 5px;
			width: 20px;
			height: 20px;
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			border-radius: 50%;
			background: rgba(255,255,255,0.2);
		}

		.help-text-close:hover {
			background: rgba(255,255,255,0.3);
		}
        
        /* Context menu */
        .context-menu {
            position: absolute;
            background-color: #333;
            border: 1px solid #444;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 100;
            min-width: 150px;
            display: none;
        }
        
        .context-menu.visible {
            display: block;
        }
        
        .menu-item {
            padding: 8px 12px;
            cursor: pointer;
            color: #ddd;
        }
        
        .menu-item:hover {
            background-color: #444;
        }
        
        .menu-divider {
            height: 1px;
            background-color: #444;
            margin: 4px 0;
        }
    </style>
</head>
<body>
    <header>
        <h2>Strain Breeding Planner</h2>
    </header>
    
    <div class="main-container">
        <div class="sidebar">
            <div class="sidebar-header">
                <h3>Strain Collection</h3>
            </div>
            
            <div class="search-box">
                <input type="text" id="search-input" placeholder="Search strains...">
                <button id="search-btn">Search</button>
            </div>
            
            <div class="filter-tabs">
                <div class="filter-tab active" data-filter="all">ALL</div>
                <div class="filter-tab" data-filter="reg">REG</div>
                <div class="filter-tab" data-filter="fem">FEM</div>
                <div class="filter-tab" data-filter="auto">AUTO</div>
                <div class="filter-tab" data-filter="photo">PHOTO</div>
                <div class="filter-tab" data-filter="fast">FAST</div>
            </div>
            
            <div class="strain-list" id="strain-list">
                <!-- Strains will be loaded here -->
                <div class="strain-item">
                    <div class="strain-info">
                        <div class="strain-name">Loading strains...</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="canvas-container" id="canvas-container">
            <div class="canvas-tools">
                <button class="canvas-tool" id="new-diagram">New</button>
                <button class="canvas-tool" id="save-diagram">Save</button>
                <button class="canvas-tool" id="load-diagram">Load</button>
            </div>
            
            <div class="arrange-options">
                <button class="canvas-tool" id="arrange-tree">Arrange Tree</button>
                <button class="canvas-tool" id="center-view">Center View</button>
            </div>
            
            <div class="breeding-canvas" id="breeding-canvas">
                <!-- SVG for connections -->
				<svg class="connection-svg" id="connection-svg">
					<defs>
						<marker id="arrow-female" viewBox="0 0 10 10" refX="8" refY="5" 
								markerWidth="6" markerHeight="6" orient="auto-start-reverse">
							<path d="M 0 0 L 10 5 L 0 10 z" fill="#E91E63"/>
						</marker>
						<marker id="arrow-male" viewBox="0 0 10 10" refX="8" refY="5" 
								markerWidth="6" markerHeight="6" orient="auto-start-reverse">
							<path d="M 0 0 L 10 5 L 0 10 z" fill="#2196F3"/>
						</marker>
					</defs>
					<g id="connections-group"></g>
				</svg>
                <!-- Nodes will be added here -->
            </div>
            
			<div class="help-text">
				Click on strains to add them to the diagram. Connect strains by dragging from one connection point to another. Right-click nodes for more options.
				<div class="help-text-close">×</div>
			</div>
        </div>
    </div>
    
	<!-- Name Cross Modal -->
	<div class="modal" id="name-cross-modal">
		<div class="modal-content">
			<div class="modal-header">Name Your Cross</div>
			<div class="modal-body">
				<div class="form-group">
					<label class="form-label">Parents</label>
					<div id="cross-parents" style="color: #aaa;"></div>
				</div>
				<div class="form-group">
					<label class="form-label">Default Name</label>
					<div id="default-cross-name" style="color: #fff;"></div>
				</div>
				<div class="form-group">
					<label class="form-label">Custom Name (optional)</label>
					<input type="text" class="form-input" id="custom-cross-name" placeholder="Enter a custom name">
				</div>
				<div class="form-group" id="cross-type-container">
					<!-- Type selection will be inserted here -->
				</div>
			</div>
			<div class="modal-footer">
				<button class="btn btn-secondary" id="cancel-cross-btn">Cancel</button>
				<button class="btn btn-primary" id="create-cross-btn">Create Cross</button>
			</div>
		</div>
	</div>
    
    <!-- Save/Load Modals -->
    <div class="modal" id="save-diagram-modal">
        <div class="modal-content">
            <div class="modal-header">Save Breeding Plan</div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Plan Name</label>
                    <input type="text" class="form-input" id="diagram-name" placeholder="Enter a name for this breeding plan">
                </div>
                <div class="form-group">
                    <label class="form-label">Notes (optional)</label>
                    <textarea class="form-input" id="diagram-notes" rows="4" placeholder="Enter any notes about this breeding plan"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="cancel-save-btn">Cancel</button>
                <button class="btn btn-primary" id="confirm-save-btn">Save Plan</button>
            </div>
        </div>
    </div>
    
	<!-- Load Diagram Modal -->
	<div class="modal" id="load-diagram-modal">
		<div class="modal-content">
			<div class="modal-header">Load Breeding Plan</div>
			<div class="modal-body">
				<div id="saved-diagrams-list">
					Loading saved plans...
				</div>
			</div>
			<div class="modal-footer">
				<button class="btn btn-danger" id="delete-plan-btn">Delete</button>
				<button class="btn btn-secondary" id="rename-plan-btn">Rename</button>
				<button class="btn btn-secondary" id="cancel-load-btn">Cancel</button>
				<button class="btn btn-primary" id="confirm-load-btn">Load Plan</button>
			</div>
		</div>
	</div>

	<!-- Rename Plan Modal -->
	<div class="modal" id="rename-plan-modal">
		<div class="modal-content">
			<div class="modal-header">Rename Breeding Plan</div>
			<div class="modal-body">
				<div class="form-group">
					<label class="form-label">Current Name</label>
					<div id="rename-plan-current-name" style="color: #aaa;"></div>
				</div>
				<div class="form-group">
					<label class="form-label">New Name</label>
					<input type="text" class="form-input" id="rename-plan-input" placeholder="Enter new name">
				</div>
			</div>
			<div class="modal-footer">
				<button class="btn btn-secondary" id="cancel-rename-btn">Cancel</button>
				<button class="btn btn-primary" id="confirm-rename-btn">Rename</button>
			</div>
		</div>
	</div>
    
    <!-- Context Menu -->
    <div class="context-menu" id="node-context-menu">
        <div class="menu-item" id="context-edit">Edit Node</div>
        <div class="menu-item" id="context-duplicate">Duplicate</div>
        <div class="menu-divider"></div>
        <div class="menu-item" id="context-remove">Remove Node</div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Configuration
            const sheetId = '1A7kFjfw6cjmQQOwz-5liWVGgFK0K5lwS8AfIZ_Zthbg';
            const nodeSpacing = {
                horizontal: 250,
                vertical: 120
            };
            
            // DOM Elements
            const strainList = document.getElementById('strain-list');
            const searchInput = document.getElementById('search-input');
            const searchBtn = document.getElementById('search-btn');
            const filterTabs = document.querySelectorAll('.filter-tab');
            
            const canvasContainer = document.getElementById('canvas-container');
            const breedingCanvas = document.getElementById('breeding-canvas');
            const connectionsSvg = document.getElementById('connection-svg');
            const connectionsGroup = document.getElementById('connections-group');
            
            // Buttons
            const newDiagramBtn = document.getElementById('new-diagram');
            const saveDiagramBtn = document.getElementById('save-diagram');
            const loadDiagramBtn = document.getElementById('load-diagram');
            const arrangeTreeBtn = document.getElementById('arrange-tree');
            const centerViewBtn = document.getElementById('center-view');
            
            // Modals
            const nameCrossModal = document.getElementById('name-cross-modal');
            const crossParents = document.getElementById('cross-parents');
            const defaultCrossName = document.getElementById('default-cross-name');
            const customCrossName = document.getElementById('custom-cross-name');
            const crossType = document.getElementById('cross-type');
            const cancelCrossBtn = document.getElementById('cancel-cross-btn');
            const createCrossBtn = document.getElementById('create-cross-btn');
            
            const saveDiagramModal = document.getElementById('save-diagram-modal');
            const diagramName = document.getElementById('diagram-name');
            const diagramNotes = document.getElementById('diagram-notes');
            const cancelSaveBtn = document.getElementById('cancel-save-btn');
            const confirmSaveBtn = document.getElementById('confirm-save-btn');
            
            const loadDiagramModal = document.getElementById('load-diagram-modal');
            const savedDiagramsList = document.getElementById('saved-diagrams-list');
            const cancelLoadBtn = document.getElementById('cancel-load-btn');
            const confirmLoadBtn = document.getElementById('confirm-load-btn');
            const renamePlanModal = document.getElementById('rename-plan-modal');
			
            // Context Menu
            const nodeContextMenu = document.getElementById('node-context-menu');
            const contextEdit = document.getElementById('context-edit');
            const contextDuplicate = document.getElementById('context-duplicate');
            const contextRemove = document.getElementById('context-remove');
            
            // State
            let allStrains = [];
            let nodes = [];
            let connections = [];
            let nodeCounter = 0;
            let selectedNode = null;
            let connecting = false;
            let connectingSourceNode = null;
            let contextMenuTargetNode = null;
            let tempLine = null;
            let pendingCrossData = null;
            let selectedDiagramIndex = -1;
            
            // Pan & Zoom state
            let isPanning = false;
            let panStart = { x: 0, y: 0 };
            let canvasOffset = { x: 0, y: 0 };
            
            // Initialize
            initializeCanvas();
            loadStrains();
            setupEventListeners();
			
            // Functions
            function initializeCanvas() {
                // Set initial canvas position
                centerCanvas();
                
                // Update SVG size
                updateSvgSize();
            }
            
            function centerCanvas() {
                canvasOffset.x = (canvasContainer.clientWidth - breedingCanvas.clientWidth) / 2;
                canvasOffset.y = (canvasContainer.clientHeight - breedingCanvas.clientHeight) / 2;
                updateCanvasPosition();
            }
            
            function updateCanvasPosition() {
                breedingCanvas.style.transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px)`;
            }
            
            function updateSvgSize() {
                connectionsSvg.setAttribute('width', breedingCanvas.clientWidth);
                connectionsSvg.setAttribute('height', breedingCanvas.clientHeight);
            }
            
            function loadStrains() {
                strainList.innerHTML = '<div class="strain-item"><div class="strain-info"><div class="strain-name">Loading strains...</div></div></div>';
                
                const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv`;
                
                fetch(csvUrl)
                    .then(response => {
                        if (!response.ok) throw new Error('Network error');
                        return response.text();
                    })
                    .then(csv => {
                        allStrains = parseCSV(csv);
                        renderStrainList(allStrains);
                    })
                    .catch(error => {
                        console.error('Error loading data:', error);
                        strainList.innerHTML = '<div class="strain-item"><div class="strain-info"><div class="strain-name">Error loading strains</div></div></div>';
                    });
            }
            
            function parseCSV(csv) {
                const lines = csv.split('\n');
                const headers = lines[0].split(',').map(header => header.trim());
                
                const result = [];
                for (let i = 1; i < lines.length; i++) {
                    if (!lines[i].trim()) continue;
                    
                    // Handle quoted fields with commas
                    const values = parseCSVLine(lines[i]);
                    
                    if (values.length < 2 || !values[0].trim()) continue;
                    if (values[0].trim().toUpperCase() === 'STRAIN' || values[0].trim() === 'Unnamed Seed') continue;
                    
                    const entry = {};
                    for (let j = 0; j < headers.length; j++) {
                        entry[headers[j]] = j < values.length ? values[j].trim() : '';
                    }
                    
                    // Generate unique ID
                    entry.id = `strain-${i}`;
                    result.push(entry);
                }
                
                return result;
            }
            
            function parseCSVLine(line) {
                let results = [];
                let currentValue = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        results.push(currentValue);
                        currentValue = '';
                    } else {
                        currentValue += char;
                    }
                }
                
                results.push(currentValue);
                return results;
            }
            
            function renderStrainList(strains) {
                if (!strains.length) {
                    strainList.innerHTML = '<div class="strain-item"><div class="strain-info"><div class="strain-name">No strains found</div></div></div>';
                    return;
                }
                
                strainList.innerHTML = '';
                
                strains.forEach(strain => {
                    const strainName = strain.STRAIN || strain.Strain || strain.Name || 'Unnamed';
                    const count = strain.COUNT || strain.Count || '';
                    const type = strain['REG / FEM'] || strain.Type || '';
                    
                    // Create type tags
                    let tags = '';
                    if (type.toLowerCase().includes('reg')) tags += '<span class="strain-tag tag-reg">REG</span>';
                    if (type.toLowerCase().includes('fem')) tags += '<span class="strain-tag tag-fem">FEM</span>';
                    if (type.toLowerCase().includes('auto')) tags += '<span class="strain-tag tag-auto">AUTO</span>';
                    if (type.toLowerCase().includes('photo')) tags += '<span class="strain-tag tag-photo">PHOTO</span>';
                    if (type.toLowerCase().includes('fast')) tags += '<span class="strain-tag tag-fast">FAST</span>';
                    
                    const item = document.createElement('div');
                    item.className = 'strain-item';
                    item.dataset.id = strain.id;
                    
                    item.innerHTML = `
                        <div class="strain-info">
                            <div class="strain-name">${strainName}</div>
                            <div class="strain-type">${tags}</div>
                        </div>
                        <div class="strain-count">${count}</div>
                    `;
                    
                    item.addEventListener('click', () => addStrainToCanvas(strain));
                    
                    strainList.appendChild(item);
                });
            }
            
			function setupEventListeners() {
				// Canvas pan events
				canvasContainer.addEventListener('mousedown', startPan);
				document.addEventListener('mousemove', doPan);
				document.addEventListener('mouseup', endPan);
				
				// General canvas events
				canvasContainer.addEventListener('click', handleCanvasClick);
				canvasContainer.addEventListener('contextmenu', handleContextMenu);
				document.addEventListener('click', hideContextMenu);
				
				// Help text close button
				const helpTextClose = document.querySelector('.help-text-close');
				if (helpTextClose) {
					helpTextClose.addEventListener('click', function() {
						document.querySelector('.help-text').style.display = 'none';
					});
				}
				
				// Search & filter
				searchBtn.addEventListener('click', performSearch);
				searchInput.addEventListener('keyup', e => {
					if (e.key === 'Enter') performSearch();
				});
				
				filterTabs.forEach(tab => {
					tab.addEventListener('click', function() {
						filterTabs.forEach(t => t.classList.remove('active'));
						this.classList.add('active');
						filterStrains(this.dataset.filter);
					});
				});
				
				// Action buttons
				newDiagramBtn.addEventListener('click', newDiagram);
				saveDiagramBtn.addEventListener('click', showSaveModal);
				loadDiagramBtn.addEventListener('click', function() {
					showLoadModal();
				});
				arrangeTreeBtn.addEventListener('click', arrangeTreeLayout);
				centerViewBtn.addEventListener('click', centerView);
				
				// Cross modal
				cancelCrossBtn.addEventListener('click', () => hideModal(nameCrossModal));
				createCrossBtn.addEventListener('click', createCross);
				
				// Save modal
				cancelSaveBtn.addEventListener('click', () => hideModal(saveDiagramModal));
				confirmSaveBtn.addEventListener('click', saveDiagram);
				
				// Load diagram modal - FIXED EVENT LISTENERS
				cancelLoadBtn.addEventListener('click', () => hideModal(loadDiagramModal));
				confirmLoadBtn.addEventListener('click', loadSelectedDiagram);
				document.getElementById('delete-plan-btn').addEventListener('click', function() {
					const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
					
					if (selectedDiagramIndex < 0 || selectedDiagramIndex >= savedDiagrams.length) {
						alert('Please select a breeding plan to delete.');
						return;
					}
					
					const planName = savedDiagrams[selectedDiagramIndex].name;
					
					if (confirm(`Are you sure you want to delete the breeding plan "${planName}"?`)) {
						// Remove the plan from the array
						savedDiagrams.splice(selectedDiagramIndex, 1);
						
						// Save updated array
						localStorage.setItem('breedingDiagrams', JSON.stringify(savedDiagrams));
						
						// Refresh the list
						showLoadModal();
						
						alert(`Breeding plan "${planName}" has been deleted.`);
					}
				});
				document.getElementById('rename-plan-btn').addEventListener('click', showRenamePlanModal);
				
				// Rename plan modal
				document.getElementById('cancel-rename-btn').addEventListener('click', function() {
					hideModal(renamePlanModal);
					showModal(loadDiagramModal);
				});
				document.getElementById('confirm-rename-btn').addEventListener('click', confirmRenamePlan);
				
				// Context menu items
				contextEdit.addEventListener('click', () => {
					hideContextMenu();
				});
				
				contextDuplicate.addEventListener('click', () => {
					if (contextMenuTargetNode) {
						duplicateNode(contextMenuTargetNode);
					}
					hideContextMenu();
				});
				
				contextRemove.addEventListener('click', () => {
					if (contextMenuTargetNode) {
						removeNode(contextMenuTargetNode);
					}
					hideContextMenu();
				});
				
				// Window resize
				window.addEventListener('resize', updateSvgSize);
			}
            
            // Canvas Pan/Zoom
            function startPan(e) {
                // Only pan with middle mouse button or when not on a node or connection point
                if (e.button !== 1 && (e.target.closest('.breeding-node') || e.target.closest('.connection-point'))) {
                    return;
                }
                
                e.preventDefault();
                isPanning = true;
                panStart = { x: e.clientX, y: e.clientY };
            }
            
            function doPan(e) {
                if (!isPanning) return;
                
                const dx = e.clientX - panStart.x;
                const dy = e.clientY - panStart.y;
                
                canvasOffset.x += dx;
                canvasOffset.y += dy;
                
                updateCanvasPosition();
                
                panStart = { x: e.clientX, y: e.clientY };
            }
            
            function endPan() {
                isPanning = false;
            }
            
			function centerView() {
				// If no nodes, just center canvas
				if (nodes.length === 0) {
					centerCanvas();
					return;
				}
				
				// Find bounding box of all nodes
				let minX = Infinity, minY = Infinity;
				let maxX = -Infinity, maxY = -Infinity;
				
				nodes.forEach(node => {
					const nodeEl = document.getElementById(node.id);
					if (nodeEl) {
						const left = parseInt(nodeEl.style.left || '0');
						const top = parseInt(nodeEl.style.top || '0');
						const width = nodeEl.offsetWidth || 200;
						const height = nodeEl.offsetHeight || 100;
						
						minX = Math.min(minX, left);
						minY = Math.min(minY, top);
						maxX = Math.max(maxX, left + width);
						maxY = Math.max(maxY, top + height);
					}
				});
				
				// Add padding
				minX -= 100;
				minY -= 100;
				maxX += 100;
				maxY += 100;
				
				// Calculate center of nodes
				const centerX = (minX + maxX) / 2;
				const centerY = (minY + maxY) / 2;
				
				// Calculate new canvas position to center the nodes
				canvasOffset.x = canvasContainer.clientWidth / 2 - centerX;
				canvasOffset.y = canvasContainer.clientHeight / 2 - centerY;
				
				updateCanvasPosition();
			}
            
            // Search and Filter
            function performSearch() {
                const searchTerm = searchInput.value.trim().toLowerCase();
                
                if (!searchTerm) {
                    renderStrainList(allStrains);
                    return;
                }
                
                const filteredStrains = allStrains.filter(strain => {
                    const name = (strain.STRAIN || strain.Strain || strain.Name || '').toLowerCase();
                    const breeder = (strain.BREEDER || strain.Breeder || '').toLowerCase();
                    const type = (strain['REG / FEM'] || strain.Type || '').toLowerCase();
                    const parent1 = (strain.PARENT1 || strain.parent1 || '').toLowerCase();
                    const parent2 = (strain.PARENT2 || strain.parent2 || '').toLowerCase();
                    
                    return name.includes(searchTerm) || 
                        breeder.includes(searchTerm) || 
                        type.includes(searchTerm) || 
                        parent1.includes(searchTerm) || 
                        parent2.includes(searchTerm);
                });
                
                renderStrainList(filteredStrains);
            }
            
            function filterStrains(filter) {
                if (filter === 'all') {
                    renderStrainList(allStrains);
                    return;
                }
                
                const filteredStrains = allStrains.filter(strain => {
                    const type = (strain['REG / FEM'] || strain.Type || '').toLowerCase();
                    return type.includes(filter.toLowerCase());
                });
                
                renderStrainList(filteredStrains);
            }
            
            // Node Operations
			function addStrainToCanvas(strain) {
				nodeCounter++;
				const nodeId = `node-${nodeCounter}`;
				
				// Get strain data
				const strainName = strain.STRAIN || strain.Strain || strain.Name || 'Unnamed';
				const type = strain['REG / FEM'] || strain.Type || '';
				
				// Parse traits
				const traits = {
					growthType: type.toLowerCase().includes('auto') ? 'AUTO' : 
							   type.toLowerCase().includes('photo') ? 'PHOTO' : '',
					sexType: type.toLowerCase().includes('reg') ? 'REG' : 
							type.toLowerCase().includes('fem') ? 'FEM' : '',
					floweringType: type.toLowerCase().includes('fast') ? 'FAST' : ''
				};
				
				// Create node element
				const node = document.createElement('div');
				node.id = nodeId;
				node.className = 'breeding-node strain-node';
				node.dataset.name = strainName;
				node.dataset.growthType = traits.growthType;
				node.dataset.sexType = traits.sexType;
				node.dataset.floweringType = traits.floweringType;
				
				// Calculate position - ensure nodes don't stack
				// Find a free spot on the canvas with a grid-like layout
				const gridSize = 250; // Space between grid points
				const existingPositions = nodes.map(n => {
					const el = document.getElementById(n.id);
					if (el) {
						return {
							x: parseInt(el.style.left || 0),
							y: parseInt(el.style.top || 0)
						};
					}
					return null;
				}).filter(p => p);
				
				// Start at the center view position
				const centerX = (canvasContainer.scrollLeft - canvasOffset.x) + canvasContainer.clientWidth / 2 - 100;
				const centerY = (canvasContainer.scrollTop - canvasOffset.y) + canvasContainer.clientHeight / 2 - 60;
				
				let posX = centerX;
				let posY = centerY;
				let attemptCount = 0;
				
				// Try to find an empty spot in a spiral pattern
				while (attemptCount < 20) {
					const isOccupied = existingPositions.some(p => 
						Math.abs(p.x - posX) < 200 && Math.abs(p.y - posY) < 100
					);
					
					if (!isOccupied) {
						break;
					}
					
					// Spiral outward
					const angle = attemptCount * 0.5;
					const distance = (attemptCount + 1) * 80;
					posX = centerX + Math.cos(angle) * distance;
					posY = centerY + Math.sin(angle) * distance;
					attemptCount++;
				}
				
				node.style.left = `${posX}px`;
				node.style.top = `${posY}px`;
				
				// Create trait tags HTML
				let traitsHTML = '';
				if (traits.growthType) traitsHTML += `<span class="strain-trait ${traits.growthType.toLowerCase()}">${traits.growthType}</span>`;
				if (traits.sexType) traitsHTML += `<span class="strain-trait ${traits.sexType.toLowerCase()}">${traits.sexType}</span>`;
				if (traits.floweringType) traitsHTML += `<span class="strain-trait ${traits.floweringType.toLowerCase()}">${traits.floweringType}</span>`;
				
				// Simplified node content - removed breeder info
				node.innerHTML = `
					<div class="node-header">
						<div class="node-name">${strainName}</div>
						<div class="node-controls">
							<div class="node-control" data-action="remove" title="Remove">×</div>
						</div>
					</div>
					<div class="node-content">
						<div class="node-traits">${traitsHTML}</div>
					</div>
					<div class="connection-points">
						<div class="connection-point connection-point-female" data-node="${nodeId}" data-role="female" title="Use as Female (Mother)"></div>
						<div class="connection-point connection-point-male" data-node="${nodeId}" data-role="male" title="Use as Male (Father)"></div>
					</div>
				`;
				
				// Make node draggable
				node.addEventListener('mousedown', startDraggingNode);
				
				// Setup connection points
				node.querySelectorAll('.connection-point').forEach(point => {
					point.addEventListener('mousedown', startConnecting);
				});
				
				// Setup remove button
				const removeButton = node.querySelector('[data-action="remove"]');
				removeButton.addEventListener('click', e => {
					e.preventDefault();
					e.stopPropagation();
					removeNode(nodeId);
				});
				
				// Add to canvas
				breedingCanvas.appendChild(node);
				
				// Add to nodes array
				nodes.push({
					id: nodeId,
					name: strainName,
					growthType: traits.growthType,
					sexType: traits.sexType,
					floweringType: traits.floweringType,
					origin: 'strain',
					children: [],
					parents: []
				});
				
				selectNode(nodeId);
				return nodeId;
			}
            
			function createCross() {
				if (!pendingCrossData) return;
				
				// Get data from form
				const customName = customCrossName.value.trim();
				const finalName = customName || pendingCrossData.defaultName;
				
				// Get selected types from radio buttons and checkboxes
				const growthType = document.querySelector('input[name="growth-type"]:checked')?.value || 'PHOTO';
				const seedType = document.querySelector('input[name="seed-type"]:checked')?.value || 'REG';
				const floweringType = document.querySelector('input[name="flowering-type"]:checked') ? 'FAST' : '';
				
				// Create cross data
				const crossData = {
					femaleId: pendingCrossData.femaleId,
					maleId: pendingCrossData.maleId,
					femaleName: pendingCrossData.femaleName,
					maleName: pendingCrossData.maleName,
					name: finalName,
					growthType: growthType,
					sexType: seedType,
					floweringType: floweringType
				};
				
				// Add cross node to canvas
				const newNodeId = addCrossNodeToCanvas(crossData);
				
				// Hide modal and reset
				hideModal(nameCrossModal);
				customCrossName.value = '';
				pendingCrossData = null;
			}

			function addCrossNodeToCanvas(crossData) {
				nodeCounter++;
				const nodeId = `node-${nodeCounter}`;
				
				// Create node element
				const node = document.createElement('div');
				node.id = nodeId;
				node.className = 'breeding-node cross-node';
				node.dataset.name = crossData.name;
				
				// Store all type information
				node.dataset.growthType = crossData.growthType || '';
				node.dataset.sexType = crossData.sexType || '';
				node.dataset.floweringType = crossData.floweringType || '';
				
				// Calculate position - below and between the parents with offset
				const femaleEl = document.getElementById(crossData.femaleId);
				const maleEl = document.getElementById(crossData.maleId);
				
				let posX = 300;
				let posY = 300;
				
				if (femaleEl && maleEl) {
					const femaleLeft = parseInt(femaleEl.style.left || 0);
					const femaleTop = parseInt(femaleEl.style.top || 0);
					const maleLeft = parseInt(maleEl.style.left || 0);
					const maleTop = parseInt(maleEl.style.top || 0);
					
					// Position in a triangle relationship instead of directly below
					posX = femaleLeft + (maleLeft - femaleLeft) * 0.5;
					posY = Math.max(femaleTop, maleTop) + 150;
					
					// Check if this position is already occupied
					const isPositionOccupied = nodes.some(n => {
						const el = document.getElementById(n.id);
						if (el && n.id !== nodeId) {
							const nodeLeft = parseInt(el.style.left || 0);
							const nodeTop = parseInt(el.style.top || 0);
							return Math.abs(nodeLeft - posX) < 100 && Math.abs(nodeTop - posY) < 100;
						}
						return false;
					});
					
					// If position is occupied, offset it
					if (isPositionOccupied) {
						posX += 120;
						posY += 50;
					}
				}
				
				node.style.left = `${posX}px`;
				node.style.top = `${posY}px`;
				
				// Create trait tags HTML
				let traitsHTML = '';
				if (crossData.growthType) {
					traitsHTML += `<span class="strain-trait ${crossData.growthType.toLowerCase()}">${crossData.growthType}</span>`;
				}
				if (crossData.sexType) {
					traitsHTML += `<span class="strain-trait ${crossData.sexType.toLowerCase()}">${crossData.sexType}</span>`;
				}
				if (crossData.floweringType) {
					traitsHTML += `<span class="strain-trait ${crossData.floweringType.toLowerCase()}">${crossData.floweringType}</span>`;
				}
				
				// Cleaner node representation with parent info and connection points for further breeding
				node.innerHTML = `
					<div class="node-header">
						<div class="node-name">${crossData.name}</div>
						<div class="node-controls">
							<div class="node-control" data-action="remove" title="Remove">×</div>
						</div>
					</div>
					<div class="node-content">
						<div class="node-traits">${traitsHTML}</div>
						<div class="node-parents">
							<div>♀: ${crossData.femaleName}</div>
							<div>♂: ${crossData.maleName}</div>
						</div>
					</div>
					<div class="connection-points">
						<div class="connection-point connection-point-female" data-node="${nodeId}" data-role="female" title="Use as Female (Mother)"></div>
						<div class="connection-point connection-point-male" data-node="${nodeId}" data-role="male" title="Use as Male (Father)"></div>
					</div>
				`;
				
				// Make node draggable
				node.addEventListener('mousedown', startDraggingNode);
				
				// Setup connection points
				node.querySelectorAll('.connection-point').forEach(point => {
					point.addEventListener('mousedown', startConnecting);
				});
				
				// Setup remove button
				const removeButton = node.querySelector('[data-action="remove"]');
				removeButton.addEventListener('click', e => {
					e.preventDefault();
					e.stopPropagation();
					removeNode(nodeId);
				});
				
				// Add to canvas
				breedingCanvas.appendChild(node);
				
				// Add to nodes array
				const newNode = {
					id: nodeId,
					name: crossData.name,
					growthType: crossData.growthType,
					sexType: crossData.sexType,
					floweringType: crossData.floweringType,
					origin: 'cross',
					femaleParent: crossData.femaleId,
					maleParent: crossData.maleId,
					children: []
				};
				
				nodes.push(newNode);
				
				// Update parent nodes to have this as a child
				const femaleParent = nodes.find(n => n.id === crossData.femaleId);
				const maleParent = nodes.find(n => n.id === crossData.maleId);
				
				if (femaleParent) femaleParent.children.push(nodeId);
				if (maleParent) maleParent.children.push(nodeId);
				
				// Create connections with right-angle paths
				addConnection(crossData.femaleId, nodeId, 'female');
				addConnection(crossData.maleId, nodeId, 'male');
				
				selectNode(nodeId);
				return nodeId;
			}
            
            function duplicateNode(nodeId) {
                const nodeData = nodes.find(node => node.id === nodeId);
                if (!nodeData) return;
                
                const nodeElement = document.getElementById(nodeId);
                if (!nodeElement) return;
                
                nodeCounter++;
                const newNodeId = `node-${nodeCounter}`;
                
                // Create a clone of the node with new ID
                const clone = nodeElement.cloneNode(true);
                clone.id = newNodeId;
                
                // Update connection point data
                const connectionPoint = clone.querySelector('.connection-point');
                connectionPoint.dataset.node = newNodeId;
                
                // Position slightly offset from original
                const originalLeft = parseInt(nodeElement.style.left);
                const originalTop = parseInt(nodeElement.style.top);
                
                clone.style.left = `${originalLeft + 30}px`;
                clone.style.top = `${originalTop + 30}px`;
                
                // Add event listeners to clone
                clone.addEventListener('mousedown', startDraggingNode);
                
                const cloneConnectionPoint = clone.querySelector('.connection-point');
                cloneConnectionPoint.addEventListener('mousedown', startConnecting);
                
                const removeButton = clone.querySelector('[data-action="remove"]');
                removeButton.addEventListener('click', e => {
                    e.preventDefault();
                    e.stopPropagation();
                    removeNode(newNodeId);
                });
                
                // Add to canvas
                breedingCanvas.appendChild(clone);
                
                // Add to nodes array
                const newNodeData = {
                    ...JSON.parse(JSON.stringify(nodeData)),
                    id: newNodeId,
                    name: `${nodeData.name} (Copy)`,
                    children: [],
                    parents: []
                };
                
                nodes.push(newNodeData);
                
                selectNode(newNodeId);
                return newNodeId;
            }
            
            function removeNode(nodeId) {
                // Remove connections to/from this node
                removeConnectionsForNode(nodeId);
                
                // Remove node element
                const nodeElement = document.getElementById(nodeId);
                if (nodeElement) nodeElement.remove();
                
                // Find node data
                const nodeIndex = nodes.findIndex(node => node.id === nodeId);
                if (nodeIndex === -1) return;
                
                const nodeData = nodes[nodeIndex];
                
                // Update parent nodes to remove this as a child
                nodeData.parents.forEach(parentId => {
                    const parentNode = nodes.find(n => n.id === parentId);
                    if (parentNode) {
                        parentNode.children = parentNode.children.filter(id => id !== nodeId);
                    }
                });
                
                // Update child nodes to remove this as a parent
                nodeData.children.forEach(childId => {
                    const childNode = nodes.find(n => n.id === childId);
                    if (childNode) {
                        childNode.parents = childNode.parents.filter(id => id !== nodeId);
                    }
                });
                
                // Remove from nodes array
                nodes.splice(nodeIndex, 1);
                
                if (selectedNode === nodeId) {
                    deselectAllNodes();
                }
            }
            
			function startDraggingNode(e) {
				// Don't drag if clicking connection point or control
				if (e.target.classList.contains('connection-point') || 
					e.target.classList.contains('node-control')) {
					return;
				}
				
				e.preventDefault();
				e.stopPropagation();
				
				// Find the node element (could be child of node)
				const nodeElement = e.target.closest('.breeding-node');
				if (!nodeElement) return;
				
				// Select this node
				selectNode(nodeElement.id);
				
				// Calculate offset within the node
				const rect = nodeElement.getBoundingClientRect();
				const offsetX = e.clientX - rect.left;
				const offsetY = e.clientY - rect.top;
				
				function moveNode(moveEvent) {
					const canvasRect = breedingCanvas.getBoundingClientRect();
					const newLeft = moveEvent.clientX - canvasRect.left - offsetX;
					const newTop = moveEvent.clientY - canvasRect.top - offsetY;
					
					nodeElement.style.left = `${newLeft}px`;
					nodeElement.style.top = `${newTop}px`;
					
					// Update connections - this updates all connections in real-time
					updateConnectionsForNode(nodeElement.id);
				}
				
				function endDrag() {
					document.removeEventListener('mousemove', moveNode);
					document.removeEventListener('mouseup', endDrag);
					
					// Make sure connections are updated one final time
					updateConnectionsForNode(nodeElement.id);
				}
				
				document.addEventListener('mousemove', moveNode);
				document.addEventListener('mouseup', endDrag);
			}
            
            function selectNode(nodeId) {
                // Deselect any currently selected node
                deselectAllNodes();
                
                // Select the new node
                const nodeElement = document.getElementById(nodeId);
                if (nodeElement) {
                    nodeElement.classList.add('selected');
                    selectedNode = nodeId;
                }
            }
            
            function deselectAllNodes() {
                document.querySelectorAll('.breeding-node.selected').forEach(node => {
                    node.classList.remove('selected');
                });
                selectedNode = null;
            }
            
            // Connection Operations
			function startConnecting(e) {
				e.preventDefault();
				e.stopPropagation();
				
				const connectionPoint = e.target;
				const nodeId = connectionPoint.dataset.node;
				const role = connectionPoint.dataset.role; // 'female' or 'male'
				
				connecting = true;
				connectingSourceNode = nodeId;
				connectingRole = role;
				
				// Create temporary SVG line with right angles
				tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
				tempLine.setAttribute('stroke', role === 'female' ? '#e091b9' : '#91b7e0');
				tempLine.setAttribute('stroke-width', '2');
				tempLine.setAttribute('fill', 'none');
				tempLine.setAttribute('stroke-dasharray', '5,5'); // make it dashed while dragging
				tempLine.setAttribute('marker-end', `url(#arrow-${role})`);
				
				connectionsGroup.appendChild(tempLine);
				
				// Add mouse move and up handlers
				document.addEventListener('mousemove', updateTempConnection);
				document.addEventListener('mouseup', finishConnection);
			}

			function updateTempConnection(e) {
				if (!connecting || !connectingSourceNode) return;
				
				const canvasRect = breedingCanvas.getBoundingClientRect();
				const sourceNode = document.getElementById(connectingSourceNode);
				if (!sourceNode) return;
				
				const sourceRect = sourceNode.getBoundingClientRect();
				
				// Source center
				const startX = sourceRect.left + sourceRect.width/2 - canvasRect.left;
				const startY = sourceRect.top + sourceRect.height/2 - canvasRect.top;
				
				// Mouse position
				const endX = e.clientX - canvasRect.left;
				const endY = e.clientY - canvasRect.top;
				
				// Create a right-angled path
				let pathD;
				
				// Determine direction based on cursor position relative to source
				if (Math.abs(endX - startX) > Math.abs(endY - startY)) {
					// More horizontal movement
					const midX = (startX + endX) / 2;
					pathD = `M ${startX} ${startY} L ${midX} ${startY} L ${midX} ${endY} L ${endX} ${endY}`;
				} else {
					// More vertical movement
					const midY = (startY + endY) / 2;
					pathD = `M ${startX} ${startY} L ${startX} ${midY} L ${endX} ${midY} L ${endX} ${endY}`;
				}
				
				tempLine.setAttribute('d', pathD);
			}

			function finishConnection(e) {
				if (!connecting || !connectingSourceNode) return;
				
				document.removeEventListener('mousemove', updateTempConnection);
				document.removeEventListener('mouseup', finishConnection);
				
				// Remove temp line
				if (tempLine) {
					tempLine.remove();
					tempLine = null;
				}
				
				// Check if mouse is over a connection point
				const element = document.elementFromPoint(e.clientX, e.clientY);
				if (element && element.classList.contains('connection-point')) {
					const targetNodeId = element.dataset.node;
					const targetRole = element.dataset.role;
					
					// Don't connect to self
					if (targetNodeId !== connectingSourceNode) {
						// Don't connect same roles (female to female or male to male)
						if (connectingRole !== targetRole) {
							// Show cross creation modal
							showNameCrossModal(connectingSourceNode, targetNodeId, connectingRole, targetRole);
						} else {
							alert('Cannot connect same types. Connect female to male or male to female.');
						}
					}
				}
				
				connecting = false;
				connectingSourceNode = null;
				connectingRole = null;
			}

			function showNameCrossModal(sourceId, targetId, sourceRole, targetRole) {
				// Determine which is female and which is male
				let femaleId, maleId;
				
				if (sourceRole === 'female') {
					femaleId = sourceId;
					maleId = targetId;
				} else {
					femaleId = targetId;
					maleId = sourceId;
				}
				
				// Get parent nodes
				const femaleNode = nodes.find(n => n.id === femaleId);
				const maleNode = nodes.find(n => n.id === maleId);
				
				if (!femaleNode || !maleNode) return;
				
				// Setup cross parent information
				crossParents.innerHTML = `
					<div>
						<span style="color: #e091b9;">♀ ${femaleNode.name}</span> × 
						<span style="color: #91b7e0;">♂ ${maleNode.name}</span>
					</div>
				`;
				
				// Set default name - female × male format
				const defaultName = `${femaleNode.name} × ${maleNode.name}`;
				defaultCrossName.textContent = defaultName;
				
				// Replace the single dropdown with properly categorized trait selections
				const typeSelectionHTML = `
					<div class="type-selection">
						<div class="type-group">
							<label><strong>Growth Type:</strong></label>
							<div>
								<label><input type="radio" name="growth-type" value="AUTO" ${femaleNode.growthType === 'AUTO' || maleNode.growthType === 'AUTO' ? 'checked' : ''}> AUTO</label>
								<label><input type="radio" name="growth-type" value="PHOTO" ${(femaleNode.growthType === 'PHOTO' || !femaleNode.growthType) && (maleNode.growthType === 'PHOTO' || !maleNode.growthType) ? 'checked' : ''}> PHOTO</label>
							</div>
						</div>
						
						<div class="type-group">
							<label><strong>Seed Type:</strong></label>
							<div>
								<label><input type="radio" name="seed-type" value="REG" ${!(femaleNode.sexType === 'FEM' || maleNode.sexType === 'FEM') ? 'checked' : ''}> REG</label>
								<label><input type="radio" name="seed-type" value="FEM" ${femaleNode.sexType === 'FEM' || maleNode.sexType === 'FEM' ? 'checked' : ''}> FEM</label>
							</div>
						</div>
						
						<div class="type-group">
							<label><strong>Flowering Type:</strong></label>
							<div>
								<label><input type="checkbox" name="flowering-type" value="FAST" ${femaleNode.floweringType === 'FAST' || maleNode.floweringType === 'FAST' ? 'checked' : ''}> FAST</label>
							</div>
						</div>
					</div>
				`;
				
				// Replace the dropdown with our new interface
				const typeSelectContainer = document.getElementById('cross-type-container');
				if (!typeSelectContainer) {
					// If the container doesn't exist yet, create a hidden element to replace
					const crossTypeInput = document.getElementById('cross-type');
					const parentElement = crossTypeInput.parentElement;
					parentElement.innerHTML = typeSelectionHTML;
				} else {
					typeSelectContainer.innerHTML = typeSelectionHTML;
				}
				
				// Store data for cross creation
				pendingCrossData = {
					femaleId: femaleId,
					maleId: maleId,
					femaleName: femaleNode.name,
					maleName: maleNode.name,
					defaultName: defaultName
				};
				
				// Show modal
				showModal(nameCrossModal);
				customCrossName.focus();
			}
            
			function addConnection(sourceId, targetId, role) {
				// Create connection id with role information
				const connectionId = `connection-${sourceId}-${targetId}-${role}`;
				
				// Check if connection already exists
				if (connections.some(c => c.id === connectionId)) {
					return;
				}
				
				// Set color based on role
				const connectionColor = role === 'female' ? '#e091b9' : '#91b7e0';
				
				// Create SVG path for connection - we'll use a right-angled path
				const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
				path.id = connectionId;
				path.classList.add('connector');
				path.setAttribute('stroke', connectionColor);
				path.setAttribute('stroke-width', '2');
				path.setAttribute('fill', 'none');
				path.setAttribute('marker-end', 'url(#arrow-' + role + ')');
				path.setAttribute('data-source', sourceId);
				path.setAttribute('data-target', targetId);
				path.setAttribute('data-role', role);
				
				// Add to SVG
				connectionsGroup.appendChild(path);
				
				// Add to connections array
				connections.push({
					id: connectionId,
					source: sourceId,
					target: targetId,
					role: role,
					color: connectionColor
				});
				
				// Update connection immediately
				updateConnection(connectionId);
			}

			function updateConnection(connectionId) {
				const connection = typeof connectionId === 'string' 
					? connections.find(c => c.id === connectionId)
					: connectionId;
					
				if (!connection) return;
				
				const path = document.getElementById(connection.id);
				if (!path) return;
				
				const sourceNode = document.getElementById(connection.source);
				const targetNode = document.getElementById(connection.target);
				
				if (!sourceNode || !targetNode) {
					removeConnection(connection.id);
					return;
				}
				
				// Get the source and target rectangles
				const sourceRect = sourceNode.getBoundingClientRect();
				const targetRect = targetNode.getBoundingClientRect();
				const canvasRect = breedingCanvas.getBoundingClientRect();
				
				// Calculate the margin to maintain from the node edge
				const margin = 15;
				
				// Determine connection points based on relative positions
				let startPoint, endPoint;
				
				// Source node connection point
				if (sourceRect.left > targetRect.right) { // Source is to the right of target
					startPoint = {
						x: sourceRect.left - canvasRect.left - margin,
						y: sourceRect.top + sourceRect.height/2 - canvasRect.top
					};
				} else if (sourceRect.right < targetRect.left) { // Source is to the left of target
					startPoint = {
						x: sourceRect.right - canvasRect.left + margin,
						y: sourceRect.top + sourceRect.height/2 - canvasRect.top
					};
				} else if (sourceRect.top > targetRect.bottom) { // Source is below target
					startPoint = {
						x: sourceRect.left + sourceRect.width/2 - canvasRect.left,
						y: sourceRect.top - canvasRect.top - margin
					};
				} else { // Source is above target
					startPoint = {
						x: sourceRect.left + sourceRect.width/2 - canvasRect.left,
						y: sourceRect.bottom - canvasRect.top + margin
					};
				}
				
				// Target node connection point
				if (targetRect.left > sourceRect.right) { // Target is to the right of source
					endPoint = {
						x: targetRect.left - canvasRect.left - margin,
						y: targetRect.top + targetRect.height/2 - canvasRect.top
					};
				} else if (targetRect.right < sourceRect.left) { // Target is to the left of source
					endPoint = {
						x: targetRect.right - canvasRect.left + margin,
						y: targetRect.top + targetRect.height/2 - canvasRect.top
					};
				} else if (targetRect.top > sourceRect.bottom) { // Target is below source
					endPoint = {
						x: targetRect.left + targetRect.width/2 - canvasRect.left,
						y: targetRect.top - canvasRect.top - margin
					};
				} else { // Target is above source
					endPoint = {
						x: targetRect.left + targetRect.width/2 - canvasRect.left,
						y: targetRect.bottom - canvasRect.top + margin
					};
				}
				
				// Create the path with right angles
				let pathD;
				
				// Determine which type of path to create
				if (Math.abs(endPoint.x - startPoint.x) > Math.abs(endPoint.y - startPoint.y)) {
					// More horizontal distance - create a path with horizontal segments first
					const midX = (startPoint.x + endPoint.x) / 2;
					pathD = `M ${startPoint.x} ${startPoint.y} L ${midX} ${startPoint.y} L ${midX} ${endPoint.y} L ${endPoint.x} ${endPoint.y}`;
				} else {
					// More vertical distance - create a path with vertical segments first
					const midY = (startPoint.y + endPoint.y) / 2;
					pathD = `M ${startPoint.x} ${startPoint.y} L ${startPoint.x} ${midY} L ${endPoint.x} ${midY} L ${endPoint.x} ${endPoint.y}`;
				}
				
				path.setAttribute('d', pathD);
			}

			function updateAllConnections() {
				connections.forEach(connection => {
					updateConnection(connection);
				});
			}
            
			function updateConnectionsForNode(nodeId) {
				// Update all connections involving this node
				connections.forEach(conn => {
					if (conn.source === nodeId || conn.target === nodeId) {
						updateConnection(conn);
					}
				});
			}
            
            function removeConnectionsForNode(nodeId) {
                // Find all connections involving this node
                const nodeConnections = connections.filter(conn => 
                    conn.source === nodeId || conn.target === nodeId
                );
                
                // Remove each connection
                nodeConnections.forEach(conn => {
                    removeConnection(conn.id);
                });
            }

			function loadLatestDiagram() {
				const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
				if (savedDiagrams.length === 0) {
					alert('No saved breeding plans found');
					return;
				}
				loadDiagram(savedDiagrams[savedDiagrams.length - 1]);
			}

			function showDeleteSelector() {
				const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
				if (savedDiagrams.length === 0) {
					alert('No saved breeding plans found');
					return;
				}
				
				// Create selector element
				const selector = document.createElement('div');
				selector.className = 'plan-selector';
				selector.style = 'position: absolute; top: 50px; left: 10px; background: #333; padding: 10px; border-radius: 4px; z-index: 1000; box-shadow: 0 2px 10px rgba(0,0,0,0.5);';
				
				savedDiagrams.forEach((plan, index) => {
					const item = document.createElement('div');
					item.innerText = plan.name;
					item.style = 'padding: 8px; cursor: pointer; border-bottom: 1px solid #444;';
					
					item.onclick = function() {
						if (confirm(`Delete plan "${plan.name}"?`)) {
							savedDiagrams.splice(index, 1);
							localStorage.setItem('breedingDiagrams', JSON.stringify(savedDiagrams));
							selector.remove();
						}
					};
					
					selector.appendChild(item);
				});
				
				const closeBtn = document.createElement('div');
				closeBtn.innerText = 'Cancel';
				closeBtn.style = 'padding: 8px; text-align: center; cursor: pointer; border-top: 1px solid #444;';
				closeBtn.onclick = () => selector.remove();
				selector.appendChild(closeBtn);
				
				document.body.appendChild(selector);
				
				document.addEventListener('mousedown', function closeSelector(e) {
					if (!selector.contains(e.target)) {
						selector.remove();
						document.removeEventListener('mousedown', closeSelector);
					}
				});
			}

			function showRenameSelector() {
				const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
				if (savedDiagrams.length === 0) {
					alert('No saved breeding plans found');
					return;
				}
				
				const selector = document.createElement('div');
				selector.className = 'plan-selector';
				selector.style = 'position: absolute; top: 50px; left: 10px; background: #333; padding: 10px; border-radius: 4px; z-index: 1000; box-shadow: 0 2px 10px rgba(0,0,0,0.5);';
				
				savedDiagrams.forEach((plan, index) => {
					const item = document.createElement('div');
					item.innerText = plan.name;
					item.style = 'padding: 8px; cursor: pointer; border-bottom: 1px solid #444;';
					
					item.onclick = function() {
						const newName = prompt('Enter new name:', plan.name);
						if (newName && newName.trim()) {
							savedDiagrams[index].name = newName.trim();
							localStorage.setItem('breedingDiagrams', JSON.stringify(savedDiagrams));
							selector.remove();
						}
					};
					
					selector.appendChild(item);
				});
				
				const closeBtn = document.createElement('div');
				closeBtn.innerText = 'Cancel';
				closeBtn.style = 'padding: 8px; text-align: center; cursor: pointer; border-top: 1px solid #444;';
				closeBtn.onclick = () => selector.remove();
				selector.appendChild(closeBtn);
				
				document.body.appendChild(selector);
				
				document.addEventListener('mousedown', function closeSelector(e) {
					if (!selector.contains(e.target)) {
						selector.remove();
						document.removeEventListener('mousedown', closeSelector);
					}
				});
			}
            
            function removeConnection(connectionId) {
                // Remove connection element
                const connectionElement = document.getElementById(connectionId);
                if (connectionElement) connectionElement.remove();
                
                // Remove from connections array
                connections = connections.filter(conn => conn.id !== connectionId);
            }
            
            // Layout Arrangement
			function arrangeTreeLayout() {
				if (nodes.length === 0) return;
				
				// Reset all potential parent-child relationships
				nodes.forEach(node => {
					node.children = [];
					node.parents = [];
				});
				
				// Rebuild relationships from connections
				connections.forEach(conn => {
					const sourceNode = nodes.find(n => n.id === conn.source);
					const targetNode = nodes.find(n => n.id === conn.target);
					
					if (sourceNode && targetNode) {
						// Source is parent of target
						if (!sourceNode.children.includes(conn.target)) {
							sourceNode.children.push(conn.target);
						}
						
						// Target is child of source
						if (!targetNode.parents.includes(conn.source)) {
							targetNode.parents.push(conn.source);
						}
					}
				});
				
				// Find root nodes (no parents)
				const rootNodes = nodes.filter(node => node.parents.length === 0);
				
				if (rootNodes.length === 0 && nodes.length > 0) {
					// If no root nodes found but we have nodes, use first node as root
					console.log("No root nodes found, using first node");
					const startX = 100;
					const startY = 100;
					positionNode(nodes[0], startX, startY, {}, 0);
				} else if (rootNodes.length > 0) {
					// Arrange from each root node
					console.log(`Found ${rootNodes.length} root nodes`);
					
					// Calculate spacing between root nodes
					const rootSpacing = Math.max(300, 800 / Math.max(1, rootNodes.length));
					let startX = 100;
					
					rootNodes.forEach(root => {
						positionNode(root, startX, 100, {}, 0);
						startX += rootSpacing;
					});
				}
				
				// Force update all connections with a slight delay
				setTimeout(() => {
					connections.forEach(conn => {
						updateConnection(conn);
					});
				}, 100);
				
				// Center view with a delay
				setTimeout(centerView, 200);
			}

			function positionNode(node, x, y, placedNodes, level) {
				console.log(`Positioning node ${node.id} at (${x}, ${y}), level ${level}`);
				
				// Skip if already placed at a deeper level
				if (placedNodes[node.id] && placedNodes[node.id].level >= level) {
					return;
				}
				
				// Mark this node as placed
				placedNodes[node.id] = { x, y, level };
				
				// Position this node
				const nodeElement = document.getElementById(node.id);
				if (nodeElement) {
					nodeElement.style.left = `${x}px`;
					nodeElement.style.top = `${y}px`;
				}
				
				// If no children, we're done with this branch
				if (!node.children || node.children.length === 0) {
					return;
				}
				
				// Calculate horizontal space for children
				const childSpacing = 250; // Space between child nodes
				const totalWidth = (node.children.length - 1) * childSpacing;
				let childX = x - totalWidth / 2;
				const childY = y + 150; // Fixed vertical spacing
				
				// Position each child
				node.children.forEach(childId => {
					const childNode = nodes.find(n => n.id === childId);
					if (childNode) {
						positionNode(childNode, childX, childY, placedNodes, level + 1);
						childX += childSpacing;
					}
				});
			}
            
            // UI Handlers
            function handleCanvasClick(e) {
                // If clicking on canvas background, deselect nodes
                if (e.target === breedingCanvas || e.target === canvasContainer) {
                    deselectAllNodes();
                }
            }
            
            function handleContextMenu(e) {
                e.preventDefault();
                
                // Hide existing context menu
                hideContextMenu();
                
                // Check if clicking on a node
                const nodeElement = e.target.closest('.breeding-node');
                if (nodeElement) {
                    // Set target node
                    contextMenuTargetNode = nodeElement.id;
                    
                    // Show context menu at mouse position
                    nodeContextMenu.style.left = `${e.clientX}px`;
                    nodeContextMenu.style.top = `${e.clientY}px`;
                    nodeContextMenu.classList.add('visible');
                }
            }
            
            function hideContextMenu() {
                nodeContextMenu.classList.remove('visible');
                contextMenuTargetNode = null;
            }
            
            function showModal(modal) {
                modal.classList.add('visible');
            }
            
            function hideModal(modal) {
                modal.classList.remove('visible');
            }
            
            // Diagram Management
            function newDiagram() {
                if (nodes.length > 0) {
                    if (!confirm('Are you sure you want to create a new diagram? This will clear all current nodes.')) {
                        return;
                    }
                }
                
                // Clear canvas
                breedingCanvas.querySelectorAll('.breeding-node').forEach(node => node.remove());
                connectionsGroup.innerHTML = '';
                
                // Reset state
                nodes = [];
                connections = [];
                nodeCounter = 0;
                selectedNode = null;
                
                // Reset canvas position
                centerCanvas();
            }
            
            function showSaveModal() {
                if (nodes.length === 0) {
                    alert('Nothing to save. Add some strains to your diagram first.');
                    return;
                }
                
                showModal(saveDiagramModal);
                diagramName.focus();
            }
            
			function saveDiagram() {
			  const name = diagramName.value.trim();
			  const notes = diagramNotes.value.trim();
			  
			  if (!name) {
				alert('Please enter a name for your breeding plan.');
				return;
			  }
			  
			  // Capture position data for all nodes
			  const nodePositions = {};
			  nodes.forEach(node => {
				const nodeEl = document.getElementById(node.id);
				if (nodeEl) {
				  nodePositions[node.id] = {
					left: nodeEl.style.left,
					top: nodeEl.style.top
				  };
				}
			  });
			  
			  // Ensure cross nodes have parent name information
			  nodes.forEach(node => {
				if (node.origin === 'cross') {
				  if (node.femaleParent) {
					const femaleNode = nodes.find(n => n.id === node.femaleParent);
					if (femaleNode) node.femaleName = femaleNode.name;
				  }
				  if (node.maleParent) {
					const maleNode = nodes.find(n => n.id === node.maleParent);
					if (maleNode) node.maleName = maleNode.name;
				  }
				}
			  });
			  
			  // Create save data
			  const saveData = {
				name: name,
				notes: notes,
				date: new Date().toISOString(),
				nodes: nodes,
				connections: connections,
				positions: nodePositions
			  };
			  
			  // Get existing saved diagrams
			  let savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
			  
			  // Check if diagram with this name already exists
			  const existingIndex = savedDiagrams.findIndex(d => d.name === name);
			  if (existingIndex >= 0) {
				if (confirm(`A breeding plan named "${name}" already exists. Overwrite it?`)) {
				  savedDiagrams[existingIndex] = saveData;
				} else {
				  return;
				}
			  } else {
				savedDiagrams.push(saveData);
			  }
			  
			  // Save to localStorage
			  localStorage.setItem('breedingDiagrams', JSON.stringify(savedDiagrams));
			  
			  // Hide modal and reset
			  hideModal(saveDiagramModal);
			  diagramName.value = '';
			  diagramNotes.value = '';
			  
			  alert(`Breeding plan "${name}" saved successfully!`);
			}

			function loadDiagram(diagram) {
			  // Clear existing diagram first
			  breedingCanvas.querySelectorAll('.breeding-node').forEach(node => node.remove());
			  connectionsGroup.innerHTML = '';
			  nodes = [];
			  connections = [];
			  
			  // Set the node counter to prevent ID conflicts
			  if (diagram.nodes.length > 0) {
				const nodeIds = diagram.nodes.map(n => {
				  const match = n.id.match(/node-(\d+)/);
				  return match ? parseInt(match[1]) : 0;
				});
				nodeCounter = Math.max(...nodeIds);
			  }
			  
			  // Create all nodes first
			  diagram.nodes.forEach(nodeData => {
				// Create node element
				const node = document.createElement('div');
				node.id = nodeData.id;
				node.className = nodeData.origin === 'strain' ? 'breeding-node strain-node' : 'breeding-node cross-node';
				node.dataset.name = nodeData.name;
				node.dataset.growthType = nodeData.growthType || '';
				node.dataset.sexType = nodeData.sexType || '';
				node.dataset.floweringType = nodeData.floweringType || '';
				
				// Set position
				if (diagram.positions && diagram.positions[nodeData.id]) {
				  node.style.left = diagram.positions[nodeData.id].left;
				  node.style.top = diagram.positions[nodeData.id].top;
				} else {
				  node.style.left = '200px';
				  node.style.top = '200px';
				}
				
				// Create trait tags HTML
				let traitsHTML = '';
				if (nodeData.growthType) traitsHTML += `<span class="strain-trait ${nodeData.growthType.toLowerCase()}">${nodeData.growthType}</span>`;
				if (nodeData.sexType) traitsHTML += `<span class="strain-trait ${nodeData.sexType.toLowerCase()}">${nodeData.sexType}</span>`;
				if (nodeData.floweringType) traitsHTML += `<span class="strain-trait ${nodeData.floweringType.toLowerCase()}">${nodeData.floweringType}</span>`;
				
				// Generate node HTML based on type
				if (nodeData.origin === 'cross') {
				  node.innerHTML = `
					<div class="node-header">
					  <div class="node-name">${nodeData.name}</div>
					  <div class="node-controls">
						<div class="node-control" data-action="remove" title="Remove">×</div>
					  </div>
					</div>
					<div class="node-content">
					  <div class="node-traits">${traitsHTML}</div>
					  <div class="node-parents">
						<div>♀: ${nodeData.femaleName || ''}</div>
						<div>♂: ${nodeData.maleName || ''}</div>
					  </div>
					</div>
					<div class="connection-points">
					  <div class="connection-point connection-point-female" data-node="${nodeData.id}" data-role="female" title="Use as Female (Mother)"></div>
					  <div class="connection-point connection-point-male" data-node="${nodeData.id}" data-role="male" title="Use as Male (Father)"></div>
					</div>
				  `;
				} else {
				  node.innerHTML = `
					<div class="node-header">
					  <div class="node-name">${nodeData.name}</div>
					  <div class="node-controls">
						<div class="node-control" data-action="remove" title="Remove">×</div>
					  </div>
					</div>
					<div class="node-content">
					  <div class="node-traits">${traitsHTML}</div>
					</div>
					<div class="connection-points">
					  <div class="connection-point connection-point-female" data-node="${nodeData.id}" data-role="female" title="Use as Female (Mother)"></div>
					  <div class="connection-point connection-point-male" data-node="${nodeData.id}" data-role="male" title="Use as Male (Father)"></div>
					</div>
				  `;
				}
				
				// Add event listeners
				node.addEventListener('mousedown', startDraggingNode);
				
				node.querySelectorAll('.connection-point').forEach(point => {
				  point.addEventListener('mousedown', startConnecting);
				});
				
				const removeButton = node.querySelector('[data-action="remove"]');
				if (removeButton) {
				  removeButton.addEventListener('click', e => {
					e.preventDefault();
					e.stopPropagation();
					removeNode(nodeData.id);
				  });
				}
				
				// Add to canvas
				breedingCanvas.appendChild(node);
			  });
			  
			  // Add nodes to state array with all properties preserved
			  nodes = diagram.nodes.map(n => ({...n}));
			  
			  // Recreate all connections
			  connections = [];
			  if (diagram.connections) {
				diagram.connections.forEach(conn => {
				  addConnection(conn.source, conn.target, conn.role);
				});
			  }
			  
			  // Center view
			  centerView();
			}
            
			function showLoadModal() {
				// Get saved diagrams
				const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
				
				if (savedDiagrams.length === 0) {
					savedDiagramsList.innerHTML = `<div style="padding: 10px; text-align: center; color: #999;">No saved breeding plans found</div>`;
					confirmLoadBtn.disabled = true;
					document.getElementById('delete-plan-btn').disabled = true;
					document.getElementById('rename-plan-btn').disabled = true;
				} else {
					// Create list of saved diagrams
					let html = '<div class="saved-plans-list">';
					savedDiagrams.forEach((diagram, index) => {
						const date = new Date(diagram.date).toLocaleDateString();
						const nodeCount = diagram.nodes.length;
						html += `<div class="saved-plan-item" style="padding: 10px; border-bottom: 1px solid #444; cursor: pointer;" data-index="${index}" onclick="selectPlan(${index})"><div style="display: flex; justify-content: space-between; align-items: center;"><span style="font-weight: 500; cursor: pointer; flex: 1;">${diagram.name}</span><span style="font-size: 12px; color: #999;">${date}</span></div><div style="font-size: 12px; color: #aaa; margin-top: 5px;">${nodeCount} strain${nodeCount !== 1 ? 's' : ''} ${diagram.notes ? `<div style="margin-top: 5px; color: #888;">${diagram.notes}</div>` : ''}</div></div>`;
					});
					html += '</div>';
					savedDiagramsList.innerHTML = html;
					confirmLoadBtn.disabled = false;
					document.getElementById('delete-plan-btn').disabled = false;
					document.getElementById('rename-plan-btn').disabled = false;
					
					// Set default selection
					selectedDiagramIndex = 0;
					
					// Highlight the first plan
					setTimeout(highlightSelectedPlan, 50);
				}
				
				showModal(loadDiagramModal);
			}

			function selectPlan(index) {
				selectedDiagramIndex = index;
				highlightSelectedPlan();
			}

			function highlightSelectedPlan() {
				document.querySelectorAll('.saved-plan-item').forEach((item, i) => {
					if (parseInt(item.dataset.index) === selectedDiagramIndex) {
						item.style.backgroundColor = '#444';
					} else {
						item.style.backgroundColor = '';
					}
				});
			}

			function loadSelectedDiagram() {
				const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
				
				if (selectedDiagramIndex < 0 || selectedDiagramIndex >= savedDiagrams.length) {
					alert('Please select a breeding plan to load.');
					return;
				}
				
				console.log(`Loading diagram at index ${selectedDiagramIndex}`);
				
				// Load the selected diagram
				loadDiagram(savedDiagrams[selectedDiagramIndex]);
				
				// Hide modal
				hideModal(loadDiagramModal);
			}

			function deleteSavedPlan() {
				const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
				
				if (selectedDiagramIndex < 0 || selectedDiagramIndex >= savedDiagrams.length) {
					alert('Please select a breeding plan to delete.');
					return;
				}
				
				const planName = savedDiagrams[selectedDiagramIndex].name;
				
				if (confirm(`Are you sure you want to delete the breeding plan "${planName}"?`)) {
					// Remove the plan from the array
					savedDiagrams.splice(selectedDiagramIndex, 1);
					
					// Save updated array
					localStorage.setItem('breedingDiagrams', JSON.stringify(savedDiagrams));
					
					// Update the selection index
					selectedDiagramIndex = -1;
					
					// Refresh the list
					showLoadModal();
					
					alert(`Breeding plan "${planName}" has been deleted.`);
				}
			}

			function showRenamePlanModal() {
				const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
				
				if (selectedDiagramIndex < 0 || selectedDiagramIndex >= savedDiagrams.length) {
					alert('Please select a breeding plan to rename.');
					return;
				}
				
				const plan = savedDiagrams[selectedDiagramIndex];
				
				// Set up rename modal
				document.getElementById('rename-plan-current-name').textContent = plan.name;
				document.getElementById('rename-plan-input').value = plan.name;
				
				// Show rename modal
				hideModal(loadDiagramModal);
				showModal(renamePlanModal);
				document.getElementById('rename-plan-input').focus();
			}

			function confirmRenamePlan() {
				const newName = document.getElementById('rename-plan-input').value.trim();
				
				if (!newName) {
					alert('Please enter a name for your breeding plan.');
					return;
				}
				
				const savedDiagrams = JSON.parse(localStorage.getItem('breedingDiagrams') || '[]');
				
				if (selectedDiagramIndex < 0 || selectedDiagramIndex >= savedDiagrams.length) {
					alert('Invalid selection.');
					return;
				}
				
				const oldName = savedDiagrams[selectedDiagramIndex].name;
				
				// Check for name collision (except with itself)
				const nameExists = savedDiagrams.some((plan, idx) => idx !== selectedDiagramIndex && plan.name === newName);
				if (nameExists) {
					if (!confirm(`A breeding plan named "${newName}" already exists. Do you want to use this name anyway?`)) {
						return;
					}
				}
				
				// Update the name
				savedDiagrams[selectedDiagramIndex].name = newName;
				
				// Save updated array
				localStorage.setItem('breedingDiagrams', JSON.stringify(savedDiagrams));
				
				// Hide rename modal and show confirmation
				hideModal(renamePlanModal);
				alert(`Breeding plan renamed from "${oldName}" to "${newName}".`);
				
				// Refresh the load modal
				showModal(loadDiagramModal);
				showLoadModal();
			}
            
						
        });
    </script>
</body>
</html>
