<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI BRANDING ASSISTANT</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
		:root {
			--primary-color: #2E7D32;
			--secondary-color: #81C784;
			--accent-color: #4CAF50;
			--dark-color: #1B5E20;
			--light-color: #C8E6C9;
			--text-color: #212121;
			--light-text: #FFFFFF;
			--shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
			--transition: all 0.3s ease;
		}

		* {
			padding: 0;
			box-sizing: border-box;
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
		}

		.ai-ministries-nav-only {
			width: 100%;
			font-family: Arial, sans-serif;
			background: black;
			color: white;
			z-index: 9999;
			position: fixed;
			top: 0;
			left: 0;
			padding: 15px 0;
			height: 50px !important;
			display: flex;
			align-items: center;
			margin-top: 0 !important;
		}

		body {
			background-color: #F9FFF9;
			color: var(--text-color);
			line-height: 1.6;
			min-height: 100vh; /* Ensures body takes full viewport height */
			display: flex;
			flex-direction: column;
			overflow-x: hidden; 
		}

		header {
			background: linear-gradient(135deg, var(--primary-color), var(--dark-color));
			color: var(--light-text);
			text-align: center;
			padding: 0.75rem 0;
			box-shadow: var(--shadow);
			position: relative;
			overflow: hidden;
		}

		footer {
			text-align: center;
			padding: 0.25rem;
			margin-top: 10px;
			font-size: 0.7rem;
			color: #666;
			line-height: 1.2;
		}

		.logo {
			font-size: 1.8rem;
			font-weight: bold;
			margin-bottom: 0.2rem;
			text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
		}

		.tagline {
			font-size: 0.9rem;
			opacity: 0.9;
		}

		.container {
			display: grid;
			grid-template-columns: 1fr 1fr;
			width: 100%;
			max-width: 1200px;
			margin: 100px auto;
		}

		.chat-container {
			background-color: white;
			border-radius: 10px;
			box-shadow: var(--shadow);
			overflow: hidden;
			display: flex;
			flex-direction: column;
			height: 800px !important;
			max-height: 800px !important;
			min-height: 800px !important;
		}

		.image-container {
			background-color: white;
			border-radius: 10px;
			box-shadow: var(--shadow);
			overflow: visible;
			display: flex;
			flex-direction: column;
			height: auto !important;
			min-height: 800px;
		}

		.chat-container, .image-container {
			width: 100%;
			min-width: 0;
			max-width: 100%;
			flex-basis: 100%;
		}

		.chat-header, .image-header {
			background-color: var(--primary-color);
			color: var(--light-text);
			padding: 0.5rem;
			display: flex;
			align-items: center;
			height: 40px;
		}

		.chat-header i {
			margin-right: 0.5rem;
			font-size: 1rem;
		}

		.chat-header h2, .image-header h2 {
			font-size: 1rem;
			margin: 0;
		}

		.chat-messages {
			flex: 1;
			padding: 0.75rem;
			height: 600px;
			max-height: 600px;
			overflow-y: auto;
		}

		.message {
			margin-bottom: 0.75rem;
			display: flex;
			flex-direction: column;
		}

		.message-user {
			align-items: flex-end;
		}

		.message-ai {
			align-items: flex-start;
		}

		.message-content {
			max-width: 80%;
			padding: 0.6rem;
			border-radius: 10px;
			box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
		}

		.message-user .message-content {
			background-color: var(--light-color);
		}

		.message-ai .message-content {
			background-color: #f0f0f0;
		}

		.message-image {
			max-width: 100%;
			border-radius: 8px;
			margin-top: 0.5rem;
			cursor: pointer;
			transition: transform 0.3s ease;
		}

		.message-image:hover {
			transform: scale(1.02);
		}

		.chat-input {
			display: flex;
			padding: 0.5rem;
			background-color: #f9f9f9;
			border-top: 1px solid #eee;
			min-height: 60px;
		}

		.chat-input input {
			flex: 1;
			padding: 0.6rem;
			border: 1px solid #ddd;
			border-radius: 20px;
			outline: none;
			transition: var(--transition);
			font-size: 0.9rem;
			min-height: 40px;
		}

		.chat-input input::placeholder {
			color: #888;
			font-size: 0.85rem;
		}

		.chat-input input:focus {
			border-color: var(--accent-color);
			box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
		}

		.send-btn, .generate-btn {
			background-color: var(--primary-color);
			color: white;
			border: none;
			padding: 0.6rem 1rem;
			margin-left: 0.5rem;
			border-radius: 20px;
			cursor: pointer;
			transition: var(--transition);
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 0.85rem;
		}

		.send-btn:hover, .generate-btn:hover {
			background-color: var(--dark-color);
		}

		.send-btn i, .generate-btn i {
			margin-right: 0.3rem;
			font-size: 0.9rem;
		}

		.image-header {
			justify-content: space-between;
		}

		.image-display {
			flex: 0 0 auto;
			height: 450px;
			display: flex;
			align-items: center;
			justify-content: center;
			padding: 0.25rem;
			position: relative;
			overflow: hidden;
			background-color: #f5f5f5;
		}

		.image-display img {
			max-width: 90%;
			max-height: 90%;
			border-radius: 8px;
			box-shadow: var(--shadow);
			transition: transform 0.3s ease;
			object-fit: contain;
		}

		.image-display.loading::after {
			content: '';
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			width: 40px;
			height: 40px;
			border: 4px solid var(--light-color);
			border-top: 4px solid var(--primary-color);
			border-radius: 50%;
			animation: spin 1s linear infinite;
		}

		#downloadLink {
			display: flex;
			gap: 10px;
		}

		#downloadLink a {
			display: inline-flex;
			align-items: center;
			color: white;
			text-decoration: none;
			font-size: 0.8rem;
		}

		#downloadLink a i {
			margin-right: 4px;
		}

		.overlay-options {
			display: flex;
			flex-direction: column;
			gap: 0.75rem;
			margin-top: 0.5rem;
		}

		.overlay-option {
			display: flex;
			align-items: center;
			gap: 0.5rem;
			flex-wrap: wrap;
		}

		.overlay-option select {
			padding: 0.4rem;
			border: 1px solid #ddd;
			border-radius: 4px;
			font-size: 0.8rem;
			background-color: white;
		}

		.overlay-option input[type="range"] {
			width: 100px;
		}

		@keyframes spin {
			0% { transform: translate(-50%, -50%) rotate(0deg); }
			100% { transform: translate(-50%, -50%) rotate(360deg); }
		}

		.thumbnail-gallery {
			display: flex;
			overflow-x: auto;
			white-space: nowrap;
			width: 100%;
			max-width: 100%;
			padding: 0.5rem;
			gap: 0.5rem;
			background-color: rgba(0,0,0,0.03);
			height: 80px;
		}

		.image-container {
			width: 100%;
			max-width: 100%;
			overflow-x: hidden; /* Prevent horizontal overflow */
		}

		.thumbnail {
			width: 60px;
			height: 60px;
			border-radius: 4px;
			object-fit: cover;
			cursor: pointer;
			box-shadow: 0 1px 3px rgba(0,0,0,0.1);
			transition: transform 0.2s ease;
		}

		.thumbnail:hover {
			transform: scale(1.05);
		}

		/* Ensure image controls are always visible with no scroll */
		.image-controls {
			height: auto !important;
			padding: 1rem;
			background-color: #f9f9f9;
			border-top: 1px solid #eee;
			overflow: visible !important;
			min-height: 300px;
		}

		.options-group {
			margin-bottom: 1.5rem;
		}

		.options-group label {
			font-weight: bold;
			display: block;
			margin-bottom: 0.25rem;
			color: var(--primary-color);
			font-size: 0.9rem;
		}

		.checkbox-option {
			display: flex;
			align-items: center;
			margin-bottom: 0.25rem;
		}

		.checkbox-option input[type="checkbox"] {
			margin-right: 0.5rem;
		}

		.style-selector {
			position: relative;
		}

		.style-selector select {
			width: 100%;
			padding: 0.6rem;
			border: 1px solid #ddd;
			border-radius: 5px;
			appearance: none;
			background-color: white;
			background-image: url('data:image/svg+xml;utf8,<svg fill="%232E7D32" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"/></svg>');
			background-repeat: no-repeat;
			background-position: right 10px center;
			cursor: pointer;
			font-size: 0.9rem;
		}

		.style-selector select:focus {
			outline: none;
			border-color: var(--accent-color);
			box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2);
		}

		/* Style tags area with no overflow limit */
		.style-tags {
			display: flex;
			flex-wrap: wrap;
			gap: 0.4rem;
			margin-top: 0.4rem;
			margin-bottom: 1.5rem;
			min-height: 40px;
			overflow: visible !important;
		}

		.style-tag {
			background-color: var(--light-color);
			padding: 0.25rem 0.5rem;
			border-radius: 15px;
			font-size: 0.8rem;
			display: flex;
			align-items: center;
		}

		.style-tag .remove {
			margin-left: 0.3rem;
			cursor: pointer;
			font-size: 0.7rem;
			opacity: 0.7;
		}

		.style-tag .remove:hover {
			opacity: 1;
		}

		.modal {
			display: none;
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.8);
			z-index: 1000;
			display: flex;
			align-items: center;
			justify-content: center;
			opacity: 0;
			visibility: hidden;
			transition: opacity 0.3s, visibility 0.3s;
		}

		.modal.active {
			opacity: 1;
			visibility: visible;
		}

		.modal-content {
			max-width: 90%;
			max-height: 90%;
		}

		.modal-content img {
			width: 100%;
			height: auto;
			max-height: 90vh;
			border-radius: 5px;
		}

		.modal-close {
			position: absolute;
			top: 20px;
			right: 20px;
			color: white;
			font-size: 2rem;
			cursor: pointer;
			transition: var(--transition);
		}

		.modal-close:hover {
			transform: scale(1.1);
		}

		.toast {
			position: fixed;
			bottom: 20px;
			right: 20px;
			background-color: var(--primary-color);
			color: var(--light-text);
			padding: 0.75rem;
			border-radius: 5px;
			box-shadow: var(--shadow);
			opacity: 0;
			transform: translateY(20px);
			transition: opacity 0.3s, transform 0.3s;
			z-index: 1000;
			font-size: 0.9rem;
		}

		.toast.show {
			opacity: 1;
			transform: translateY(0);
		}

		.selected-styles {
			margin-top: 0.5rem;
			padding-top: 0.5rem;
			border-top: 1px solid #eee;
		}

		.selected-styles h3 {
			font-size: 0.9rem;
			margin-bottom: 0.3rem;
			color: var(--primary-color);
		}

		.typing-indicator {
			display: inline-flex;
			align-items: center;
			padding: 0.4rem 0.8rem;
			background-color: #f0f0f0;
			border-radius: 20px;
			margin-bottom: 0.75rem;
		}

		.typing-indicator span {
			width: 6px;
			height: 6px;
			margin: 0 2px;
			background-color: #888;
			border-radius: 50%;
			display: inline-block;
			opacity: 0.4;
		}

		.typing-indicator span:nth-child(1) {
			animation: blink 1s infinite 0.3s;
		}

		.typing-indicator span:nth-child(2) {
			animation: blink 1s infinite 0.5s;
		}

		.typing-indicator span:nth-child(3) {
			animation: blink 1s infinite 0.7s;
		}

		@keyframes blink {
			50% { opacity: 1; }
		}

		footer {
			text-align: center;
			padding: 0.25rem;
			margin-top: 0;
			font-size: 0.7rem;
			color: #666;
			line-height: 1.2;
		}

		footer p {
			margin: 0;
		}

		footer a {
			color: #2E7D32;
			text-decoration: none;
		}

		.bottom-margin {
			margin-bottom: 80px;
		}

		/* QR CODE STYLES */
		.qr-overlay {
			position: absolute;
			background-color: white;
			border-radius: 5px;
			box-shadow: 0 2px 4px rgba(0,0,0,0.2);
			display: none;
			z-index: 10;
		}

		.qr-top-left {
			top: 20px;
			left: 20px;
		}

		.qr-top-right {
			top: 20px;
			right: 20px;
		}

		.qr-bottom-left {
			bottom: 20px;
			left: 20px;
		}

		.qr-bottom-right {
			bottom: 20px;
			right: 20px;
		}

		.qr-group {
			display: flex;
			align-items: center;
			gap: 0.5rem;
			margin-bottom: 0.5rem;
		}

		.qr-group input[type="text"] {
			flex: 1;
			padding: 0.4rem;
			border: 1px solid #ddd;
			border-radius: 4px;
			font-size: 0.8rem;
		}

		.qr-group select,
		.qr-position select {
			padding: 0.4rem;
			border: 1px solid #ddd;
			border-radius: 4px;
			font-size: 0.8rem;
			background-color: white;
		}

		.qr-button {
			background-color: var(--accent-color);
			color: white;
			border: none;
			padding: 0.4rem 0.8rem;
			border-radius: 4px;
			cursor: pointer;
			font-size: 0.8rem;
			display: flex;
			align-items: center;
			justify-content: center;
		}

		.qr-button i {
			margin-right: 0.3rem;
		}

		.qr-button:hover {
			background-color: var(--dark-color);
		}

		/* Toggle QR code switch */
		.toggle-switch {
			position: relative;
			display: inline-block;
			width: 42px;
			height: 24px;
			margin-right: 0.5rem;
		}

		.toggle-switch input {
			opacity: 0;
			width: 0;
			height: 0;
		}

		.toggle-slider {
			position: absolute;
			cursor: pointer;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background-color: #ccc;
			transition: .4s;
			border-radius: 24px;
		}

		.toggle-slider:before {
			position: absolute;
			content: "";
			height: 18px;
			width: 18px;
			left: 3px;
			bottom: 3px;
			background-color: white;
			transition: .4s;
			border-radius: 50%;
		}

		input:checked + .toggle-slider {
			background-color: var(--primary-color);
		}

		input:checked + .toggle-slider:before {
			transform: translateX(18px);
		}

		@media (max-width: 768px) {
			.container {
				grid-template-columns: 1fr;
			}
		}
    </style>
</head>
<body>
    <div class="container">
        <div class="chat-container">
			<div class="chat-header">
				<i class="fas fa-comment-dots"></i>
				<h2>STRAINNAVIGATOR AI Branding Assistant</h2>
			</div>
            <div class="chat-messages" id="chatMessages">
                <!-- Messages will be added here -->
            </div>
            <div class="chat-input">
                <input type="text" id="messageInput" placeholder="Describe your brand's concept, history, or desired vibe...">
                <button class="send-btn" id="sendBtn">
                    <i class="fas fa-paper-plane"></i>
                    Chat
                </button>
                <button class="generate-btn" id="generateBtn">
                    <i class="fas fa-magic"></i>
                    Generate
                </button>
            </div>
        </div>

        <div class="image-container">
			<div class="image-header">
				<h2>Brand Designer</h2>
				<div id="downloadLink"></div>
			</div>
            <div class="image-display" id="imageDisplay">
                <img id="currentImage" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMDAgMzAwIj48cmVjdCB3aWR0aD0iMzAwIiBoZWlnaHQ9IjMwMCIgZmlsbD0iI2Y1ZjVmNSIvPjx0ZXh0IHg9IjE1MCIgeT0iMTQwIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMTYiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZpbGw9IiM2NjY2NjYiPkJyYW5kIExvZ28gRGVzaWduPC90ZXh0Pjx0ZXh0IHg9IjE1MCIgeT0iMTYwIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMTIiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZpbGw9IiM4ODg4ODgiPkRlc2NyaWJlIHlvdXIgYnJhbmQgYW5kIGNsaWNrIEdlbmVyYXRlPC90ZXh0Pjwvc3ZnPg==" alt="Generate a brand design">
            </div>
            
            <!-- Thumbnail Gallery -->
            <div class="thumbnail-gallery" id="thumbnailGallery">
                <!-- Thumbnails will be added here -->
            </div>
            
            <div class="image-controls">
                <div class="options-group">
                    <div class="checkbox-option">
                        <input type="checkbox" id="enhanceOption" checked>
                        <label for="enhanceOption">Enhance (improve prompt quality)</label>
                    </div>
                    <div class="checkbox-option">
                        <input type="checkbox" id="privateOption" checked>
                        <label for="privateOption">Private (don't share in public feed)</label>
                    </div>
                </div>
                
                <!-- QR Code Controls -->
                <div class="options-group">
                    <div class="qr-group">
                        <label class="toggle-switch">
                            <input type="checkbox" id="qrToggle">
                            <span class="toggle-slider"></span>
                        </label>
                        <label for="qrToggle">Add QR Code</label>
                        <input type="text" id="qrUrlInput" placeholder="Enter URL for QR code" value="https://www.strainnavigator.com">
                        <button class="qr-button" id="generateQrBtn">
                            <i class="fas fa-qrcode"></i>
                        </button>
                    </div>
                    <div class="qr-position">
                        <select id="qrPositionSelect">
                            <option value="top-left">Top Left</option>
                            <option value="top-right">Top Right</option>
                            <option value="bottom-left">Bottom Left</option>
                            <option value="bottom-right" selected>Bottom Right</option>
                        </select>
                        <input type="range" id="qrSizeSlider" min="15" max="30" value="20" 
                            title="QR Code Size (% of image)">
                        <span id="qrSizeValue">20%</span>
                    </div>
                </div>
                
                <!-- Image Overlays -->
                <div class="options-group">
                    <label>Image Overlays</label>
                    <div class="overlay-options">
                        <div class="overlay-option">
                            <label class="toggle-switch">
                                <input type="checkbox" id="twentyOneToggle">
                                <span class="toggle-slider"></span>
                            </label>
                            <label for="twentyOneToggle">Add 21+ Symbol</label>
                            <select id="twentyOnePositionSelect">
                                <option value="top-left">Top Left</option>
                                <option value="top-right">Top Right</option>
                                <option value="bottom-left">Bottom Left</option>
                                <option value="bottom-right" selected>Bottom Right</option>
                            </select>
                            <input type="range" id="twentyOneSizeSlider" min="10" max="30" value="15" 
                                title="21+ Symbol Size (% of image)">
                            <span id="twentyOneSizeValue">15%</span>
                        </div>
                        
                        <div class="overlay-option">
                            <label class="toggle-switch">
                                <input type="checkbox" id="weedLeafToggle">
                                <span class="toggle-slider"></span>
                            </label>
                            <label for="weedLeafToggle">Add Weed Leaf</label>
                            <select id="weedLeafPositionSelect">
                                <option value="top-left">Top Left</option>
                                <option value="top-right" selected>Top Right</option>
                                <option value="bottom-left">Bottom Left</option>
                                <option value="bottom-right">Bottom Right</option>
                            </select>
                            <input type="range" id="weedLeafSizeSlider" min="10" max="30" value="15" 
                                title="Weed Leaf Size (% of image)">
                            <span id="weedLeafSizeValue">15%</span>
                        </div>
                    </div>
                </div>
                
                <div class="options-group bottom-margin">
                    <label for="styleSelector"></label>
                    <div class="style-selector">
                        <select id="styleSelector">
                            <option value="">Select a style...</option>
                            <!-- Styles will be populated by JavaScript -->
                        </select>
                    </div>
                    <div class="style-tags" id="styleTags">
                        <!-- Selected styles will appear here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="imageModal">
        <div class="modal-close" id="modalClose">&times;</div>
        <div class="modal-content">
            <img id="modalImage" src="" alt="Brand visualization">
        </div>
    </div>

    <div class="toast" id="toast"></div>
	
	<footer style="text-align: center; padding: 1rem; margin-top: 2rem; font-size: 0.8rem; color: #666;">
		<p>
			<a href="https://pollinations.ai" target="_blank" style="color: #2E7D32; text-decoration: none;">
				Generations by Pollinations.ai
			</a>
		</p>
		<p>© StrainNavigator.com 2025. All Rights Reserved.</p>
	</footer>	


    <script>
        // Main application logic
		console.log("Script tag encountered at", new Date().toISOString());
					
		document.addEventListener('DOMContentLoaded', function() { 
			console.log("DOMContentLoaded fired at", new Date().toISOString());
			
			// Define hasInitialized at the top of your function
			let hasInitialized = false;
			
			// Now check if already initialized
			console.log("DOMContentLoaded fired at", new Date().toISOString());
			if (hasInitialized) {
				console.log("Preventing duplicate initialization");
				return;
			}
			hasInitialized = true;

            // DOM Elements
            const chatMessages = document.getElementById('chatMessages');
            const messageInput = document.getElementById('messageInput');
            const sendBtn = document.getElementById('sendBtn');
            const generateBtn = document.getElementById('generateBtn');
            const imageDisplay = document.getElementById('imageDisplay');
            const currentImage = document.getElementById('currentImage');
            const enhanceOption = document.getElementById('enhanceOption');
            const privateOption = document.getElementById('privateOption');
            const styleSelector = document.getElementById('styleSelector');
            const styleTags = document.getElementById('styleTags');
            const imageModal = document.getElementById('imageModal');
            const modalImage = document.getElementById('modalImage');
            const modalClose = document.getElementById('modalClose');
            const toast = document.getElementById('toast');
            const downloadLink = document.getElementById('downloadLink');
            const thumbnailGallery = document.getElementById('thumbnailGallery');

			const compositeCanvas = document.createElement('canvas');
			compositeCanvas.style.display = 'none';
			document.body.appendChild(compositeCanvas);            
			
            // QR code elements
            const qrUrlInput = document.getElementById('qrUrlInput');
            const generateQrBtn = document.getElementById('generateQrBtn');
            const qrToggle = document.getElementById('qrToggle');
            const qrOverlay = document.getElementById('qrOverlay');
            const qrImage = document.getElementById('qrImage');
            const qrPositionSelect = document.getElementById('qrPositionSelect');

			const twentyOneToggle = document.getElementById('twentyOneToggle');
			const twentyOnePositionSelect = document.getElementById('twentyOnePositionSelect');
			const twentyOneSizeSlider = document.getElementById('twentyOneSizeSlider');
			const twentyOneSizeValue = document.getElementById('twentyOneSizeValue');

			const weedLeafToggle = document.getElementById('weedLeafToggle');
			const weedLeafPositionSelect = document.getElementById('weedLeafPositionSelect');
			const weedLeafSizeSlider = document.getElementById('weedLeafSizeSlider');
			const weedLeafSizeValue = document.getElementById('weedLeafSizeValue');


			const systemMessage = {
				role: 'system',
				content: `You are a branding specialist ranging from Cannabis to anything requested.
				KEEP ALL RESPONSES BRIEF AND TO THE POINT. Follow the users lead on design ideas.
				
				If it is a Cannabis strain AND Only If users ask for names:
				- Provide a simple list of 5-7 creative name options only if the user asks (no long explanations)
				- NEVER USE ASTRICKS or similar ways to markdown or highlight etc.
				
				You have access to the following EXACT command format:
				
				GENERATE_IMAGE: [detailed visual description]
				
				Use this GENERATE_IMAGE command when:
				1. A user infers they want an image or visualization
				2. A user supplies a name and concept OR selects one of your suggested names
				3. No need to also tell the user the description unless asking, generation is plenty.
				
				IMPORTANT: When writing image prompts, focus ONLY on the CONTENT, OBJECTS and COMPOSITION.
				- DO describe: what objects should appear, their arrangement, text elements, color themes, mood
				- DO NOT include any visual style directives (no terms like "cartoon style", "animated", "3D render", etc.)
				- The user will select visual styles separately through the interface
				
				Example of a good prompt: "GENERATE_IMAGE: A design for 'Cosmic Haze' cannabis strain featuring a spiral galaxy in the center, with deep purple and blue colors, gold text overlay, and a dark background with subtle cosmic dust elements."
				
				You can both respond conversationally AND generate an image in the same message if appropriate.`
			}

            // State management
            let selectedStyles = [];
            let currentPrompt = '';
            let conversationHistory = [];
            let isGenerating = false;
            let thumbnailHistory = []; // Store previous generations
            let currentQrUrl = '';
            let qrPosition = 'bottom-right'; // Default position
			
			// New variables for storing image versions
			let originalImageUrl = ''; // Store the original image without QR
			let qrImageUrl = '';      // Store the version with QR
			let qrCodeDataUrl = '';   // Store the generated QR code image			
			
			let twentyOneDataUrl = '';
			let weedLeafDataUrl = '';
			
            // Function to show toast notification
            function showToast(message, duration = 3000) {
                toast.textContent = message;
                toast.classList.add('show');
                setTimeout(() => {
                    toast.classList.remove('show');
                }, duration);
            }

			function createTwentyOneSvg() {
				const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
					<circle cx="50" cy="50" r="45" fill="black" stroke="white" stroke-width="2"/>
					<text x="50" y="60" font-family="Arial" font-size="40" font-weight="bold" fill="white" text-anchor="middle">21+</text>
				</svg>`;
				return 'data:image/svg+xml;base64,' + btoa(svg);
			}

			function createWeedLeafSvg() {
				// Use Font Awesome's cannabis icon SVG path - same approach as your twentyOneSvg
				const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
					<circle cx="50" cy="50" r="45" fill="transparent"/>
					<text x="50" y="70" font-family="'Font Awesome 5 Free'" font-size="70" font-weight="900" fill="#00AA00" text-anchor="middle">&#xf55f;</text>
				</svg>`;
				return 'data:image/svg+xml;base64,' + btoa(svg);
			}

			twentyOneDataUrl = createTwentyOneSvg();

			function createWeedLeafOverlay() {
			  // Create a simple div with the cannabis Font Awesome icon
			  const weedLeafDiv = document.createElement('div');
			  weedLeafDiv.innerHTML = '<i class="fas fa-cannabis" style="color: #00AA00; font-size: 100px;"></i>';
			  return weedLeafDiv;
			}

			// Function to add message to chat
			function addMessage(content, isUser, imageUrl = null) {
				const messageDiv = document.createElement('div');
				messageDiv.className = isUser ? 'message message-user' : 'message message-ai';
				
				const messageContent = document.createElement('div');
				messageContent.className = 'message-content';
				messageContent.textContent = content;
				messageDiv.appendChild(messageContent);
				
				if (imageUrl) {
					const img = document.createElement('img');
					img.src = imageUrl;
					img.alt = 'Generated brand design';
					img.className = 'message-image';
					img.addEventListener('click', () => {
						openImageModal(imageUrl);
					});
					messageDiv.appendChild(img);
				}
				
				chatMessages.appendChild(messageDiv);
				chatMessages.scrollTop = chatMessages.scrollHeight;
				
				// Update conversation history
				conversationHistory.push({
					role: isUser ? 'user' : 'assistant',
					content: content
				});

				// Limit history to last 10 messages
				if (conversationHistory.length > 10) {
					conversationHistory = conversationHistory.slice(-10);
				}
			}

            // Function to show typing indicator
            function showTypingIndicator() {
                const indicator = document.createElement('div');
                indicator.className = 'typing-indicator';
                indicator.id = 'typingIndicator';
                indicator.innerHTML = '<span></span><span></span><span></span>';
                chatMessages.appendChild(indicator);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            // Function to remove typing indicator
            function removeTypingIndicator() {
                const indicator = document.getElementById('typingIndicator');
                if (indicator) {
                    indicator.remove();
                }
            }

            function detectImageRequest(userMessage, aiResponse) {
                // Check if user is asking for an image
                const imageKeywords = ['image', 'picture', 'visual', 'visualize', 'show me', 'generate', 'create'];
                
                // If user mentions image-related terms, generate an image
                if (imageKeywords.some(keyword => userMessage.toLowerCase().includes(keyword))) {
                    // Extract the brand name or description from the conversation
                    let imagePrompt = "";
                    
                    // Check if we have a brand name in context
                    const nameMatch = aiResponse.match(/\*\*(.*?)\*\*/);
                    if (nameMatch && nameMatch[1]) {
                        // Check if user is asking about cannabis
                        if (userMessage.toLowerCase().includes('cannabis') || 
                            userMessage.toLowerCase().includes('strain') || 
                            userMessage.toLowerCase().includes('marijuana')) {
                            imagePrompt = nameMatch[1] + " cannabis brand label";
                        } else {
                            imagePrompt = nameMatch[1] + " brand logo";
                        }
                    } else {
                        // Use the user's message as the prompt
                        imagePrompt = userMessage + " brand design";
                    }
                    
                    // Generate the image
                    setTimeout(() => {
                        generateImageFromPrompt(imagePrompt);
                    }, 500);
                    
                    return true;
                }
                
                return false;
            }

            // Function to generate QR code
			async function generateQrCode(url) {
				if (!url) {
					showToast('Please enter a URL for the QR code');
					return null;
				}
				
				try {
					const encodedUrl = encodeURIComponent(url);
					const qrCodeUrl = `https://api.qrserver.com/v1/create-qr-code/?size=250x250&data=${encodedUrl}&format=png&margin=20`;
					
					return new Promise((resolve, reject) => {
						const img = new Image();
						img.crossOrigin = "Anonymous"; // Critical for CORS
						
						img.onload = function() {
							// Create a fresh canvas for this operation
							const canvas = document.createElement('canvas');
							canvas.width = img.width;
							canvas.height = img.height;
							const ctx = canvas.getContext('2d');
							ctx.drawImage(img, 0, 0);
							
							// Convert to data URL to avoid CORS issues with future operations
							const dataUrl = canvas.toDataURL('image/png');
							resolve(dataUrl);
						};
						
						img.onerror = function(err) {
							console.error("QR code image load error:", err);
							reject(new Error('Failed to load QR code'));
						};
						
						img.src = qrCodeUrl;
					});
				} catch (error) {
					console.error('Error generating QR code:', error);
					showToast('Error generating QR code. Please try again.');
					return null;
				}
			}

			async function compositeOverlayOntoImage(imageUrl, overlay, position, sizePercent) {
				return new Promise((resolve, reject) => {
					const mainImg = new Image();
					mainImg.crossOrigin = "Anonymous";
					
					mainImg.onload = function() {
						const canvas = document.createElement('canvas');
						canvas.width = mainImg.width;
						canvas.height = mainImg.height;
						const ctx = canvas.getContext('2d');
						
						// Draw main image on canvas
						ctx.drawImage(mainImg, 0, 0, mainImg.width, mainImg.height);
						
						// Calculate overlay size based on the main image dimension
						const size = Math.min(mainImg.width, mainImg.height) * (sizePercent / 100);
						
						// Calculate overlay position
						let x = 0;
						let y = 0;
						const padding = size * 0.1; // 10% padding
						
						// Determine position
						switch(position) {
							case 'top-left':
								x = padding;
								y = padding;
								break;
							case 'top-right':
								x = mainImg.width - size - padding;
								y = padding;
								break;
							case 'bottom-left':
								x = padding;
								y = mainImg.height - size - padding;
								break;
							case 'bottom-right':
								x = mainImg.width - size - padding;
								y = mainImg.height - size - padding;
								break;
						}
						
						// Handle different types of overlays
						if (typeof overlay === 'string') {
							// It's a QR code or 21+ symbol (URL string)
							const overlayImg = new Image();
							overlayImg.crossOrigin = "Anonymous";
							
							overlayImg.onload = function() {
								// Add white background for QR codes only
								if (overlay === qrCodeDataUrl) {
									ctx.fillStyle = 'white';
									ctx.fillRect(x, y, size, size);
								}
								
								// Draw overlay on canvas
								ctx.drawImage(overlayImg, x, y, size, size);
								
								try {
									const compositeImageUrl = canvas.toDataURL('image/jpeg', 0.95);
									resolve(compositeImageUrl);
								} catch (err) {
									console.error("Canvas toDataURL error:", err);
									reject(new Error('Failed to convert canvas to data URL'));
								}
							};
							
							overlayImg.onerror = function(err) {
								console.error("Overlay image load error:", err);
								reject(new Error('Failed to load overlay image'));
							};
							
							overlayImg.src = overlay;
						} else if (overlay instanceof HTMLElement) {
							// It's a DOM element (Font Awesome icon)
							// Create a temporary container for the icon
							const tempContainer = document.createElement('div');
							tempContainer.style.position = 'absolute';
							tempContainer.style.top = '0';
							tempContainer.style.left = '0';
							tempContainer.style.width = size + 'px';
							tempContainer.style.height = size + 'px';
							tempContainer.style.zIndex = '-1000';
							tempContainer.style.opacity = '0';
							
							// Add the overlay element to the temporary container
							const clonedOverlay = overlay.cloneNode(true);
							clonedOverlay.style.width = size + 'px';
							clonedOverlay.style.height = size + 'px';
							tempContainer.appendChild(clonedOverlay);
							
							// Add to document temporarily
							document.body.appendChild(tempContainer);
							
							// Use html2canvas to render the Font Awesome icon
							html2canvas(clonedOverlay, {backgroundColor: null}).then(iconCanvas => {
								// Draw the icon on our main canvas
								ctx.drawImage(iconCanvas, x, y, size, size);
								
								// Remove temporary container
								document.body.removeChild(tempContainer);
								
								try {
									const compositeImageUrl = canvas.toDataURL('image/jpeg', 0.95);
									resolve(compositeImageUrl);
								} catch (err) {
									console.error("Canvas toDataURL error:", err);
									reject(new Error('Failed to convert canvas to data URL'));
								}
							}).catch(err => {
								document.body.removeChild(tempContainer);
								console.error("html2canvas error:", err);
								reject(new Error('Failed to render icon'));
							});
						}
					};
					
					mainImg.onerror = function(err) {
						console.error("Main image load error:", err);
						reject(new Error('Failed to load main image'));
					};
					
					mainImg.src = imageUrl;
				});
			}

			function compositeQrCodeOntoImage(imageUrl, qrCodeUrl, position, sizePercent) {
				return compositeOverlayOntoImage(imageUrl, qrCodeUrl, position, sizePercent);
			}
            
            // Function to position QR code overlay
            function positionQrOverlay() {
                if (!qrToggle.checked) {
                    qrOverlay.style.display = 'none';
                    return;
                }
                
                const position = qrPositionSelect.value;
                // Remove all position classes
                qrOverlay.classList.remove('qr-top-left', 'qr-top-right', 'qr-bottom-left', 'qr-bottom-right');
                // Add selected position class
                qrOverlay.classList.add(`qr-${position}`);
                qrOverlay.style.display = 'block';
                
                // Update QR code size based on slider
                const sizePercent = document.getElementById('qrSizeSlider').value;
                const containerWidth = imageDisplay.offsetWidth;
                const newSize = Math.round((containerWidth * sizePercent) / 100);
                
                qrImage.width = newSize;
                qrImage.height = newSize;
                
                // Update size display
                document.getElementById('qrSizeValue').textContent = `${sizePercent}%`;
            }
            
			// Function to add a thumbnail to the gallery
			function addThumbnail(imageUrl) {
				// Only add if it's a valid URL (not the placeholder)
				if (imageUrl && !imageUrl.includes('data:image/svg+xml')) {
					// Create thumbnail element
					const thumb = document.createElement('img');
					thumb.src = imageUrl;
					thumb.className = 'thumbnail';
					thumb.alt = 'Previous design';
					thumb.title = 'Click to view this design';
					
					// Add click event to restore this image
					thumb.addEventListener('click', async () => {
						// Set this as the original image
						originalImageUrl = imageUrl;
						currentImage.src = imageUrl;
						
						// If QR toggle is on, add QR to this image
						if (qrToggle.checked) {
							await addQrCodeToCurrentImage();
						} else {
							// Update download link for original only
							downloadLink.innerHTML = `
								<a href="${originalImageUrl}" download="brand_design.jpg" style="color: white;">
									<i class="fas fa-download"></i> Download
								</a>
							`;
						}
					});
					
					// FIXED: Limit the number of thumbnails
					const MAX_THUMBNAILS = 8;
					
					// Add to thumbnail gallery at the BEGINNING (prepend)
					thumbnailGallery.prepend(thumb);
					
					// Add to thumbnail history array
					thumbnailHistory.push(imageUrl);
					
					// Remove oldest thumbnails if we exceed the maximum
					while (thumbnailGallery.children.length > MAX_THUMBNAILS) {
						// Remove the LAST child (oldest thumbnail) from DOM
						thumbnailGallery.removeChild(thumbnailGallery.lastChild);
						
						// Also remove from the history array
						if (thumbnailHistory.length > MAX_THUMBNAILS) {
							thumbnailHistory.shift(); // Remove oldest from array
						}
					}
					
					// Make sure gallery scrolls to show newest thumbnails
					thumbnailGallery.scrollLeft = 0;
				}
			}

			// Improved function to apply styles in a more natural way
			function applySelectedStylesToPrompt(prompt) {
				if (selectedStyles.length === 0) {
					return prompt;
				}
				
				if (selectedStyles.length === 1) {
					// For a single style, apply it directly
					return `${prompt}. ${selectedStyles[0].value}`;
				} else {
					// For multiple styles, create a more natural blend instruction
					const styleNames = selectedStyles.map(style => style.text).join(' and ');
					
					// Take the first sentence of each style value to avoid overly long prompts
					const styleDescriptions = selectedStyles.map(style => {
						// Extract first sentence or use the whole value if no period found
						const firstSentence = style.value.split('.')[0];
						return firstSentence;
					}).join('; ');
					
					return `${prompt}. Blend the styles of ${styleNames} - ${styleDescriptions}`;
				}
			}

			// Function to send message to AI with better error handling
			async function sendMessage(message, generateImage = false, retryCount = 0) {
				// Define userMessage at function level so it's available everywhere in the function
				let userMessage = '';
				
				if (!message.trim() && !generateImage) return;
				
				// If generate button clicked with no input, reuse last prompt
				if (generateImage && !message.trim()) {
					if (currentPrompt) {
						generateImageFromPrompt(currentPrompt);
					} else {
						showToast("Please enter a description first or chat to generate content.");
					}
					return;
				}
				
				// Add user message to chat ONLY ONCE
				if (message.trim()) {
					addMessage(message, true);
					messageInput.value = '';
					
					// Store message in a variable to prevent re-adding
					userMessage = message;
					message = '';  // Clear message to prevent duplicate sending
				}
				
				// If generate button clicked with input, use input directly
				if (generateImage) {
					generateImageFromPrompt(userMessage || message);
					return;
				}
				
				// Show typing indicator before API call
				showTypingIndicator();
				
				// Prevent multiple simultaneous requests
				if (isGenerating) {
					showToast("Already processing a message, please wait...");
					removeTypingIndicator();
					return;
				}
				
				isGenerating = true;
				
				try {
					// First filter conversation history to exclude image generation messages
					const filteredHistory = conversationHistory.filter(msg => 
						!(msg.role === 'assistant' && 
						  (msg.content === "Your brand design has been generated in the display area." ||
						   msg.content === "Generating your branded label..." ||
						   msg.content.includes("Sorry, there was a problem generating the image")
						  )
						)
					);
					
					// Take only the last 10 exchanges (20 messages total - 10 user, 10 assistant)
					const recentHistory = filteredHistory.slice(-20);
					
					const messages = [
						systemMessage,  // Use the existing system message
						...recentHistory
					];
					
					// Send to API
					const response = await fetch('https://text.pollinations.ai/', {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json',
						},
						body: JSON.stringify({
							messages: messages,
							model: 'openai-large',
							private: true,
							jsonMode: false,
							seed: Math.floor(Math.random() * 1000000)
						}),
						signal: AbortSignal.timeout(15000) // 15 second timeout
					});
					
					if (!response.ok) {
						throw new Error(`Failed to get response from AI: ${response.status}`);
					}
					
					const responseText = await response.text();
					removeTypingIndicator();
					
					// Check for GENERATE_IMAGE command
					const imageMatch = responseText.match(/GENERATE_IMAGE:\s*(.*?)(?:$|(?=\n\n))/s);
					
					if (imageMatch && imageMatch[1]) {
						// Extract image description
						let imagePrompt = imageMatch[1].trim();
						
						// Store for reuse (original prompt without styles)
						currentPrompt = imagePrompt;
						
						// Clean the response
						let cleanResponse = responseText.replace(/GENERATE_IMAGE:\s*(.*?)(?:$|(?=\n\n))/s, '').trim();
						
						if (!cleanResponse) {
							cleanResponse = "Generating your branded label...";
						}
						
						// Add to chat
						addMessage(cleanResponse, false);
						
						// Add to conversation history
						conversationHistory.push({
							role: 'assistant',
							content: responseText // Keep full response for context
						});
						
						// Call generateImageFromPrompt with the prompt
						setTimeout(() => {
							generateImageFromPrompt(imagePrompt);
						}, 100);
					} else {
						// No image command found
						addMessage(responseText, false);
						
						// Add to conversation history
						conversationHistory.push({
							role: 'assistant',
							content: responseText
						});
						
						// Check if user wanted an image despite no explicit command
						detectImageRequest(userMessage, responseText);
					}
					
				} catch (error) {
					console.error('Error:', error);
					removeTypingIndicator();
					
					// Handle retry with exponential backoff
					if (retryCount < 2) {
						const delay = 1000 * (retryCount + 1); // 1s, 2s, 3s
						console.log(`Retrying in ${delay/1000} seconds...`);
						
						setTimeout(() => {
							// Don't re-add the user message on retry
							const retryMessage = '';
							sendMessage(retryMessage, generateImage, retryCount + 1);
						}, delay);
					} else {
						addMessage("I'm sorry, I encountered an error connecting to the AI service. Please try again in a moment.", false);
					}
				} finally {
					isGenerating = false;
				}
			}

			async function generateImageFromPrompt(prompt) {
				if (isGenerating) {
					showToast("Already generating a label, please wait...");
					return;
				}
				
				isGenerating = true;
				imageDisplay.classList.add('loading');
				
				console.log("Generating image with prompt:", prompt);
				
				// Store current prompt for potential reuse (store the original, not the enhanced one)
				currentPrompt = prompt;
				
				// Always apply selected styles to the prompt before generating
				const enhancedPrompt = applySelectedStylesToPrompt(prompt);
				
				// Create image URL with parameters
				const randomSeed = Math.floor(Math.random() * 1000000);
				const encodedPrompt = encodeURIComponent(enhancedPrompt);
				const enhanceParam = enhanceOption.checked ? '&enhance=true' : '';
				const privateParam = privateOption.checked ? '&private=true' : '';
				const modelParam = '&model=flux';
				const imageUrl = `https://image.pollinations.ai/prompt/${encodedPrompt}?nologo=true${enhanceParam}${privateParam}${modelParam}&width=2048&height=2048&seed=${randomSeed}`;
				
				try {
					showToast("Generating your branded label...");
					
					// Create an Image element and set up onload/onerror handlers
					const img = new Image();
					img.crossOrigin = "Anonymous"; // Critical for CORS handling
					
					// Set up a Promise to handle image loading
					const imageLoadPromise = new Promise((resolve, reject) => {
						img.onload = () => resolve(img);
						img.onerror = (e) => {
							console.error("Image load error:", e);
							reject(new Error("Failed to load image"));
						};
						
						// Set a timeout in case the image takes too long to load
						setTimeout(() => reject(new Error("Image generation timed out")), 60000);
					});
					
					// Start loading the image
					img.src = imageUrl;
					
					// Wait for the image to load
					await imageLoadPromise;
					
					// Save the original image URL
					originalImageUrl = imageUrl;
					qrImageUrl = ''; // Reset QR version
					
					// Display the original image
					currentImage.src = originalImageUrl;
					currentImage.alt = "Branded label";
					
					// Add to thumbnail gallery
					addThumbnail(originalImageUrl);
					
					// Add text notification to chat
					addMessage("Your brand design has been generated in the display area.", false);
					
					// Add to conversation history
					conversationHistory.push({
						role: 'assistant',
						content: "Your brand design has been generated in the display area."
					});
					
					// Only add QR if toggle is checked
					if (qrToggle.checked && qrUrlInput.value.trim()) {
						// Generate and apply QR code
						await addQrCodeToCurrentImage();
					}
					
				} catch (error) {
					console.error('Error generating image:', error);
					showToast("Error generating label. Please try a different description.");
					addMessage("Sorry, there was a problem generating the image. Please try a different description.", false);
					
					// Add to conversation history
					conversationHistory.push({
						role: 'assistant',
						content: "Sorry, there was a problem generating the image. Please try a different description."
					});
				} finally {
					// Always clean up regardless of success/failure
					imageDisplay.classList.remove('loading');
					isGenerating = false;
				}
			}

			async function updateCurrentImage() {
				if (!originalImageUrl || originalImageUrl.includes('data:image/svg+xml')) {
					showToast("Please generate an image first");
					return;
				}
				
				try {
					showToast("Updating image overlays...");
					
					// Start with the original image
					let currentImageUrl = originalImageUrl;
					let hasOverlays = false;
					
					// Add QR code if enabled
					if (qrToggle.checked && qrUrlInput.value.trim()) {
						if (!qrCodeDataUrl || qrUrlInput.value !== currentQrUrl) {
							currentQrUrl = qrUrlInput.value;
							qrCodeDataUrl = await generateQrCode(qrUrlInput.value);
						}
						
						if (qrCodeDataUrl) {
							currentImageUrl = await compositeOverlayOntoImage(
								currentImageUrl,
								qrCodeDataUrl,
								qrPositionSelect.value,
								parseInt(document.getElementById('qrSizeSlider').value)
							);
							hasOverlays = true;
						}
					}
					
					// Add 21+ symbol if enabled
					if (twentyOneToggle.checked) {
						currentImageUrl = await compositeOverlayOntoImage(
							currentImageUrl,
							twentyOneDataUrl,
							twentyOnePositionSelect.value,
							parseInt(twentyOneSizeSlider.value)
						);
						hasOverlays = true;
					}
					
					// Add weed leaf if enabled - THIS IS THE UPDATED PART
					if (weedLeafToggle.checked) {
						// We'll need to include html2canvas library first
						if (typeof html2canvas === 'undefined') {
							// Load html2canvas if it's not already loaded
							await new Promise((resolve, reject) => {
								const script = document.createElement('script');
								script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
								script.onload = resolve;
								script.onerror = reject;
								document.head.appendChild(script);
							});
						}
						
						const weedLeafElement = createWeedLeafOverlay();
						currentImageUrl = await compositeOverlayOntoImage(
							currentImageUrl,
							weedLeafElement,
							weedLeafPositionSelect.value,
							parseInt(weedLeafSizeSlider.value)
						);
						hasOverlays = true;
					}
					
					// Update the current image
					currentImage.src = currentImageUrl;
					
					// Update download links
					if (hasOverlays) {
						downloadLink.innerHTML = `
							<a href="${currentImageUrl}" download="brand_design_with_overlays.jpg" style="color: white; margin-right: 10px;">
								<i class="fas fa-download"></i> With Overlays
							</a>
							<a href="${originalImageUrl}" download="brand_design.jpg" style="color: white;">
								<i class="fas fa-download"></i> Original
							</a>
						`;
					} else {
						downloadLink.innerHTML = `
							<a href="${originalImageUrl}" download="brand_design.jpg" style="color: white;">
								<i class="fas fa-download"></i> Download
							</a>
						`;
					}
					
					showToast("Image updated");
					return currentImageUrl;
				} catch (error) {
					console.error("Error updating image:", error);
					showToast("Failed to update image with overlays");
					return null;
				}
			}

			// ADD THIS SIMPLE WRAPPER FUNCTION TO MAINTAIN COMPATIBILITY
			function addQrCodeToCurrentImage() {
				return updateCurrentImage();
			}

			function removeQrCodeFromCurrentImage() {
				if (originalImageUrl) {
					// If any other overlay is still active, update the image without QR
					if (twentyOneToggle.checked || weedLeafToggle.checked) {
						updateCurrentImage();
					} else {
						// Switch back to the original image
						currentImage.src = originalImageUrl;
						
						// Update download link
						downloadLink.innerHTML = `
							<a href="${originalImageUrl}" download="brand_design.jpg" style="color: white;">
								<i class="fas fa-download"></i> Download
							</a>
						`;
						
						showToast("Overlays removed");
					}
				}
			}

            // Function to open image modal
            function openImageModal(imageUrl) {
                modalImage.src = imageUrl;
                imageModal.classList.add('active');
                document.body.style.overflow = 'hidden'; // Prevent scrolling
            }

            // Function to close image modal
            function closeImageModal() {
                imageModal.classList.remove('active');
                document.body.style.overflow = ''; // Restore scrolling
            }

            // Function to add style to selected styles
            function addStyle(styleText, styleValue) {
                if (!styleValue || selectedStyles.some(s => s.value === styleValue)) {
                    return; // Don't add empty or duplicate styles
                }
                
                const style = { text: styleText, value: styleValue };
                selectedStyles.push(style);
                
                // Create tag element
                const tagEl = document.createElement('div');
                tagEl.className = 'style-tag';
                tagEl.innerHTML = `
                    ${styleText}
                    <span class="remove" data-value="${styleValue}">&times;</span>
                `;
                styleTags.appendChild(tagEl);
                
                // Reset selector
                styleSelector.value = '';
            }

            // Function to remove style from selected styles
            function removeStyle(styleValue) {
                selectedStyles = selectedStyles.filter(s => s.value !== styleValue);
                
                // Remove from DOM
                const tags = styleTags.querySelectorAll('.style-tag');
                tags.forEach(tag => {
                    const removeBtn = tag.querySelector('.remove');
                    if (removeBtn.getAttribute('data-value') === styleValue) {
                        tag.remove();
                    }
                });
            }

            // Function to populate style selector
            function populateStyleSelector() {
                // An abbreviated list of styles - you can expand this with more from your provided list
			const styles = [
				// Traditional Art Styles
				{ text: "Oil Painting", value: "create this as an oil painting with rich textures and visible brushstrokes, like a museum masterpiece" },
				{ text: "Watercolor", value: "render this as a delicate watercolor with flowing translucent colors and soft bleeding edges" },
				{ text: "Sketch", value: "present this as a hand-drawn sketch with careful pencil linework and subtle shading" },
				{ text: "Ink Wash", value: "depict this as a flowing ink wash painting with elegant brush strokes and varying tones of black" },

				// Classical Art Movements
				{ text: "Impressionism", value: "paint this in impressionist style with small, visible brushstrokes and emphasis on light and movement, similar to Monet's work" },
				{ text: "Art Nouveau", value: "design this with Art Nouveau elegance, featuring ornate curved lines, natural forms, and decorative elements like Alphonse Mucha" },
				{ text: "Art Deco", value: "style this with bold Art Deco geometry, symmetrical patterns, and luxurious gold and metallic elements" },
				{ text: "Renaissance", value: "render this with Renaissance mastery, displaying perfect proportions, realistic details, and classical composition like Leonardo da Vinci" },
				{ text: "Baroque", value: "portray this with Baroque drama, using rich contrasts between light and shadow, emotional intensity, and ornate details" },

				// Modern Art Movements
				{ text: "Cubism", value: "interpret this through Cubist fragmentation, showing multiple perspectives simultaneously, with geometric shapes like Picasso's work" },
				{ text: "Surrealism", value: "transform this into a surrealist dreamscape with impossible elements and strange juxtapositions, reminiscent of Salvador Dali" },
				{ text: "Pop Art", value: "recreate this as vibrant Pop Art with bold outlines, primary colors, and commercial imagery in the style of Andy Warhol" },
				{ text: "Abstract", value: "express this as an abstract composition focusing on pure form, color, and line without recognizable subject matter" },
				{ text: "Minimalism", value: "distill this into minimalist form, using clean lines, limited elements, and intentional negative space" },

				// Digital & Contemporary
				{ text: "Digital Painting", value: "create this as a polished digital painting with smooth color blending and crisp details" },
				{ text: "Concept Art", value: "visualize this as professional concept art for a film or game, with dramatic lighting and atmospheric perspective" },
				{ text: "Hyperrealism", value: "render this with hyperrealistic detail that exceeds photography, where every texture and reflection is perfectly captured" },
				{ text: "Photorealism", value: "create an ultra-realistic photograph with perfect lighting, incredible detail and photographic qualities" },
				{ text: "Low Poly", value: "transform this into a low-poly 3D rendering with geometric faces and clean edges" },

				// Cultural & Regional
				{ text: "Ukiyo-e", value: "depict this as a Japanese Ukiyo-e woodblock print with flat color areas, bold outlines, and traditional subjects like Hokusai" },
				{ text: "Graffiti", value: "spray this as vibrant street art with bold colors, dynamic lettering, and urban energy" },
				{ text: "Folk Art", value: "illustrate this with folk art charm, using decorative patterns, flat perspectives, and cultural symbolism" },

				// Visual Media Styles
				{ text: "Anthro", value: "design this with anthropomorphic characters, blending human and animal traits into natural, expressive figures" },
				{ text: "Anime", value: "draw this in anime style with expressive large eyes, colorful hair, and dynamic poses typical of Japanese animation" },
				{ text: "Manga", value: "illustrate this as a manga page with strong black linework, dynamic action, and expressive character designs" },
				{ text: "Cartoon", value: "render this as a playful cartoon with exaggerated features, bold outlines, and vibrant colors" },
				{ text: "Pixel Art", value: "create this as nostalgic pixel art with limited color palette and blocky aesthetic reminiscent of retro games" },
				{ text: "Comic Book", value: "illustrate this as a comic book panel with bold outlines, dynamic composition, and narrative clarity" },
				{ text: "Character Cartoon", value: "design this as a professional cartoon character with distinctive silhouette, expressive features, and memorable design" },
				{ text: "Pop Surreal", value: "blend this with pop surrealism, mixing cartoon elements with dreamlike imagery and symbolic meaning" },
				{ text: "Lowbrow Art", value: "create this in lowbrow art style with underground aesthetic, pop culture references, and irreverent humor" },
				{ text: "Fantasy Realism", value: "imagine this through fantasy realism, where impossible elements are rendered with photographic detail and dramatic lighting" },
				{ text: "Illustrated Logo", value: "design this as a professional illustrated logo with clean lines, distinctive silhouette, and commercial appeal" },

				// Specialized Themes
				{ text: "Fantasy Art", value: "envision this as epic fantasy art with magical elements, heroic composition, and otherworldly atmosphere" },
				{ text: "Sci-Fi", value: "visualize this as science fiction concept art with futuristic technology, alien environments, and advanced machinery" },
				{ text: "Gothic", value: "portray this with Gothic atmosphere, featuring ornate architecture, dramatic shadows, and a sense of melancholy" },
				{ text: "Steampunk", value: "reimagine this with steampunk aesthetics, featuring brass machinery, Victorian style, and retrofuturistic steam-powered technology" },
				{ text: "Cyberpunk", value: "visualize this in a cyberpunk world with neon lights cutting through rain-slicked streets, high tech and low life aesthetic" },

				// Contemporary Aesthetics
				{ text: "Vaporwave", value: "create this in vaporwave style with retro computing aesthetics, pastel pink and blue colors, and nostalgic 80s and 90s elements" },
				{ text: "Retrowave", value: "style this with retrowave aesthetics, featuring neon grids, sunset gradients, and 80s synthwave vibes" },
				{ text: "Glitch Art", value: "distort this with digital glitch effects, broken pixels, and visual artifacts that create a sense of digital decay" },
				{ text: "Psychedelic", value: "transform this with psychedelic patterns, swirling colors, and mind-bending visual effects that distort reality" },
				{ text: "Nature Art", value: "compose this with natural elements, organic forms, and botanical details integrated harmoniously" },

				// Commercial & Design
				{ text: "Luxury", value: "present this with luxury brand aesthetics, featuring premium materials, elegant typography, and sophisticated restraint" },
				{ text: "Corporate", value: "design this with professional corporate identity, using clean typography, structured layout, and business-appropriate color scheme" },
				{ text: "Vintage", value: "age this with vintage charm, featuring retro typography, weathered textures, and nostalgic color palettes" },
				{ text: "Minimalist Design", value: "simplify this with minimalist design principles, using essential elements only, clean typography, and generous white space" },
				{ text: "Illustrated", value: "craft this as a hand-drawn illustration with personal artistic style, unique linework, and organic imperfections" },

				// Specialized Commercial
				{ text: "Product Photography", value: "show this as professional product photography with perfect lighting against a clean backdrop" },
				{ text: "Fashion", value: "capture this as editorial fashion photography with dramatic poses, stylized lighting, and high-end atmosphere" },
				{ text: "Architectural", value: "photograph this as architectural imagery with perfect symmetry, dramatic perspective, and attention to structural details" },
				{ text: "Food Photography", value: "present this as mouth-watering food photography with perfect styling, soft lighting, and appetizing colors" },
				{ text: "Cinematic", value: "frame this as a cinematic scene with widescreen composition, atmospheric lighting, and narrative focus" }
			];
                
				// Check if styles array is empty
				if (styles.length === 0) {
					console.error("Styles array is empty!");
					// Add a fallback style
					const fallbackStyle = { text: "Default", value: "professional label design" };
					const option = document.createElement('option');
					option.value = fallbackStyle.value;
					option.textContent = fallbackStyle.text;
					styleSelector.appendChild(option);
					return;
				}
				
				// Log styles length
				console.log(`Adding ${styles.length} styles to selector`);
				
				// Add options to select
				styles.forEach((style, index) => {
					const option = document.createElement('option');
					option.value = style.value;
					option.textContent = style.text;
					styleSelector.appendChild(option);
					
					// Log every 10th style to avoid console spam
					if (index % 10 === 0) {
						console.log(`Added style #${index}: ${style.text}`);
					}
				});
				
				// Verify styles were added
				console.log(`Total options in selector after population: ${styleSelector.options.length}`);
			}

            // Function to list all available styles
            function listStyles() {
                addMessage("Here are some styles you can use for your images:", false);
                
                // Get all options from the style selector
                const options = Array.from(styleSelector.options).slice(1); // Skip the first "Select a style" option
                
                // Create message with style list
                let styleList = options.map(option => option.textContent).join(", ");
                addMessage(`Available styles: ${styleList}`, false);
                addMessage("To use a style, select it from the dropdown menu or ask me to use a specific style when generating an image.", false);
            }

            // Event Listeners for main functions
            sendBtn.addEventListener('click', () => {
                const message = messageInput.value.trim();
                if (message) {
                    sendMessage(message, false);
                }
            });

            generateBtn.addEventListener('click', () => {
                const message = messageInput.value.trim();
                if (message) {
                    sendMessage(message, true);
                } else if (currentPrompt) {
                    // If there's no new prompt but there is a current one, regenerate
                    generateImageFromPrompt(currentPrompt);
                } else {
                    showToast("Please enter a description first.");
                }
            });

            messageInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendBtn.click();
                }
            });

			messageInput.addEventListener('input', () => {
				const value = messageInput.value.toLowerCase();
				
				// Handle command shortcuts
				if (value.startsWith('/image') || value.startsWith('/generate')) {
					const prompt = value.replace('/image', '').replace('/generate', '').trim();
					if (prompt) {
						messageInput.value = '';
						generateImageFromPrompt(prompt);
					} else {
						showToast("Please add a description after /image or /generate");
					}
				} else if (value === '/styles' || value === '/list styles') {
					messageInput.value = '';
					listStyles();
				}
			});

            // Style selector events
			styleSelector.addEventListener('change', () => {
				const selectedOption = styleSelector.options[styleSelector.selectedIndex];
				if (selectedOption && selectedOption.value) {
					addStyle(selectedOption.textContent, selectedOption.value);
					styleSelector.selectedIndex = 0; // Reset selector immediately
				}
			});

            // Event delegation for style tag removal
            styleTags.addEventListener('click', (e) => {
                if (e.target.classList.contains('remove')) {
                    const styleValue = e.target.getAttribute('data-value');
                    removeStyle(styleValue);
                }
            });

            // Modal events
            currentImage.addEventListener('click', () => {
                if (currentImage.src && !currentImage.src.includes('data:image/svg+xml')) {
                    openImageModal(currentImage.src);
                }
            });

            modalClose.addEventListener('click', closeImageModal);
            imageModal.addEventListener('click', (e) => {
                if (e.target === imageModal) {
                    closeImageModal();
                }
            });
            
            // QR Code events
			generateQrBtn.addEventListener('click', async () => {
				const url = qrUrlInput.value.trim();
				if (!url) {
					showToast('Please enter a URL for the QR code');
					return;
				}
				
				// Generate and cache QR code
				showToast('Generating QR code...');
				qrCodeDataUrl = await generateQrCode(url);
				currentQrUrl = url;
				
				if (!qrCodeDataUrl) {
					showToast('Failed to generate QR code');
					return;
				}
				
				// Turn on QR toggle if it's not already on
				if (!qrToggle.checked) {
					qrToggle.checked = true;
				}
				
				// Apply QR to current image
				if (currentImage.src && !currentImage.src.includes('data:image/svg+xml')) {
					await addQrCodeToCurrentImage();
				} else {
					showToast('QR code ready for next generation');
				}
			});
            
			qrPositionSelect.addEventListener('change', async () => {
				if (qrToggle.checked && currentImage.src && !currentImage.src.includes('data:image/svg+xml')) {
					await addQrCodeToCurrentImage();
				}
			});

			document.getElementById('qrSizeSlider').addEventListener('input', async (e) => {
				// Update size display immediately
				document.getElementById('qrSizeValue').textContent = `${e.target.value}%`;
			});

			document.getElementById('qrSizeSlider').addEventListener('change', async () => {
				if (qrToggle.checked && currentImage.src && !currentImage.src.includes('data:image/svg+xml')) {
					await addQrCodeToCurrentImage();
				}
			});

			qrToggle.addEventListener('change', async () => {
				if (currentImage.src && !currentImage.src.includes('data:image/svg+xml')) {
					if (qrToggle.checked) {
						await updateCurrentImage();
					} else {
						// Only reset to original if no other overlays are active
						if (!twentyOneToggle.checked && !weedLeafToggle.checked) {
							removeQrCodeFromCurrentImage();
						} else {
							await updateCurrentImage();
						}
					}
				}
			});

			twentyOneToggle.addEventListener('change', updateCurrentImage);
			twentyOnePositionSelect.addEventListener('change', updateCurrentImage);
			twentyOneSizeSlider.addEventListener('input', (e) => {
				twentyOneSizeValue.textContent = `${e.target.value}%`;
			});
			twentyOneSizeSlider.addEventListener('change', updateCurrentImage);

			weedLeafToggle.addEventListener('change', updateCurrentImage);
			weedLeafPositionSelect.addEventListener('change', updateCurrentImage);
			weedLeafSizeSlider.addEventListener('input', (e) => {
				weedLeafSizeValue.textContent = `${e.target.value}%`;
			});
			weedLeafSizeSlider.addEventListener('change', updateCurrentImage);

            // Initialize
            populateStyleSelector();
            
            // Add welcome message
            setTimeout(() => {
                addMessage("Welcome! I'm your AI branding design assistant. Describe your concept or details, and I can help visualize a logo for you. What kind of logo image would you like to create today?", false);
            }, 500);

        });
    </script>
</body>
</html>	
