<!DOCTYPE html>
<html lang="en">
<head>
	<!-- Basic Meta Tags -->
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Winner's List - An interactive random name picker tool. Perfect for choosing winners, making decisions, or adding excitement to your events and giveaways.">
	
	<!-- Open Graph Meta Tags for Facebook, LinkedIn, etc. -->
	<meta property="og:type" content="website">
	<meta property="og:url" content="https://www.strainnavigator.com/tools/winnerslist.html">
	<meta property="og:title" content="Winner's List - Random Name Picker">
	<meta property="og:description" content="A beautiful and customizable name picker for random selections, contests, giveaways and decision making. Easy to use with no sign-up required.">
	<meta property="og:image" content="https://www.strainnavigator.com/tools/img/WinnersList.jpg?v=1">
	<meta property="og:image:width" content="1200">
	<meta property="og:image:height" content="630">
	<meta property="og:site_name" content="Strain Navigator Tools">

	<!-- Twitter Card Meta Tags -->
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:url" content="https://www.strainnavigator.com/tools/winnerslist.html">
	<meta name="twitter:title" content="Winner's List - Random Name Picker">
	<meta name="twitter:description" content="A beautiful and customizable name picker for random selections, contests, giveaways and decision making. Easy to use with no sign-up required.">
	<meta name="twitter:image" content="https://www.strainnavigator.com/tools/img/WinnersList.jpg?v=1">

	<!-- Additional Meta Tags -->
	<meta name="robots" content="index, follow">
	<meta name="author" content="Strain Navigator">
	<meta name="theme-color" content="#ff5252">

    <title>Winner's List</title>
    <style>
        :root {
            --primary: #ff5252;
            --secondary: #ffeb3b;
            --accent: #2196f3;
            --dark: #212121;
            --light: #f5f5f5;
            --winner: #4CAF50;
            --eliminated: #ff0000;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial Rounded MT Bold', 'Helvetica Rounded', Arial, sans-serif;
        }
        
        body {
            background-color: #121212;
            color: white;
            background-image: radial-gradient(circle, #303030 1px, transparent 1px);
            background-size: 20px 20px;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            height: calc(100vh - 40px);
        }
        
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                height: auto;
            }
        }
        
        .header {
            grid-column: 1 / -1;
            text-align: center;
            margin-bottom: 0;
        }

		.container {
			gap: 10px;
		}
        
        .title {
            font-size: 4rem;
            margin: 10px 0;
            color: var(--secondary);
            text-shadow: 
                0 0 5px var(--primary),
                0 0 10px var(--primary),
                0 0 15px var(--primary);
            animation: flicker 3s infinite alternate;
        }
        
        @keyframes flicker {
            0%, 18%, 22%, 25%, 53%, 57%, 100% {
                text-shadow: 
                    0 0 5px var(--primary),
                    0 0 10px var(--primary),
                    0 0 15px var(--primary);
            }
            20%, 24%, 55% {
                text-shadow: none;
            }
        }
        
        .subtitle {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--light);
        }
        
        .panel {
            background: rgba(20, 20, 20, 0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            border: 2px solid var(--primary);
            position: relative;
            overflow: hidden;
        }
        
        .panel::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: repeating-conic-gradient(
                transparent 0deg 10deg,
                rgba(255, 82, 82, 0.1) 10deg 20deg
            );
            animation: rotate 120s linear infinite;
            z-index: -1;
        }
        
        @keyframes rotate {
            100% {
                transform: rotate(360deg);
            }
        }
        
        .panel-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            text-align: center;
            color: var(--secondary);
        }
        
        .name-list-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }
        
        .name-list {
            list-style: none;
            overflow-y: visible;
			max-height: none;
            flex-grow: 1;
            margin-bottom: 15px;
            position: relative;
        }
        
        .name-item {
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.1);
            margin-bottom: 8px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s;
            position: relative;
        }
        
        .name-item:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .name-text {
            flex-grow: 1;
            margin-right: 10px;
        }
        
        .edit-btn, .delete-btn {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 5px;
        }
        
        .edit-btn {
            background-color: var(--accent);
            color: white;
        }
        
        .delete-btn {
            background-color: var(--primary);
            color: white;
        }
        
        .add-name-form {
            display: flex;
            margin-top: auto;
        }
        
        .name-input {
            flex-grow: 1;
            padding: 10px 15px;
            border: 2px solid var(--accent);
            border-radius: 8px 0 0 8px;
            font-size: 1rem;
            background: rgba(0, 0, 0, 0.2);
            color: white;
        }
        
        .add-btn {
            padding: 10px 20px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 0 8px 8px 0;
            cursor: pointer;
            font-weight: bold;
        }
        
        .settings-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .form-label {
            font-size: 1rem;
            color: var(--light);
        }
        
        .form-select, .form-input {
            padding: 10px;
            border-radius: 8px;
            border: 2px solid var(--accent);
            background: rgba(0, 0, 0, 0.2);
            color: white;
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .action-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            flex-grow: 1;
            transition: all 0.2s;
        }
        
        .import-export-btn {
            background: var(--secondary);
            color: var(--dark);
        }
        
        .reset-btn {
            background: var(--primary);
            color: white;
        }
        
        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        .controls-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }
        
        .pick-button {
            padding: 15px 40px;
            font-size: 1.5rem;
            background: linear-gradient(145deg, var(--primary), #ff0000);
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(255, 0, 0, 0.3);
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 20px;
            width: 100%;
            max-width: 300px;
        }
        
        .pick-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(255, 0, 0, 0.4);
        }
        
        .pick-button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 10px rgba(255, 0, 0, 0.4);
        }
        
        .result-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            text-align: center;
        }
        
        .result-title {
            font-size: 1.2rem;
            margin-bottom: 10px;
            color: var(--secondary);
        }
        
        .winner-display {
            font-size: 2rem;
            font-weight: bold;
            color: var(--primary);
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 20px;
            border-radius: 10px;
            margin-bottom: 15px;
            min-height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            text-shadow: 0 0 10px var(--primary);
        }
        
        .history-list {
            list-style: none;
            text-align: left;
            width: 100%;
            margin-top: 10px;
            overflow-y: auto;
            max-height: 200px;
        }
        
        .history-item {
            padding: 8px 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.9rem;
        }
        
        .history-item span {
            font-weight: bold;
            color: var(--secondary);
        }
        
        .remaining-display {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            width: 100%;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background: #212121;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            border: 2px solid var(--primary);
            position: relative;
        }
        
        .close-btn {
            position: absolute;
            right: 15px;
            top: 15px;
            font-size: 1.5rem;
            background: none;
            border: none;
            color: white;
            cursor: pointer;
        }
        
        .modal-title {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: var(--secondary);
        }
        
        .modal-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .modal-input, .modal-textarea {
            padding: 10px;
            border-radius: 8px;
            border: 2px solid var(--accent);
            background: rgba(0, 0, 0, 0.2);
            color: white;
            width: 100%;
        }
        
        .modal-textarea {
            min-height: 200px;
            font-family: monospace;
        }
        
        .modal-btn {
            padding: 10px 20px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
        }
        
        /* Selection animation and styles */
        .selection-indicator {
            position: absolute;
            left: 0;
            width: 100%;
            height: 48px; /* Adjust to match your list item height */
            background: rgba(255, 235, 59, 0.3);
            border-radius: 8px;
            box-shadow: 0 0 10px var(--secondary);
            z-index: -1;
            pointer-events: none;
            opacity: 0;
            transition: top 0.1s linear;
        }
        
        .selection-active .selection-indicator {
            opacity: 1;
        }
        
        .selected {
            transform: scale(1.02);
            background: rgba(255, 235, 59, 0.2) !important;
            border: 2px solid var(--secondary);
            z-index: 10;
        }
        
        .eliminated {
            text-decoration: line-through;
            opacity: 0.5;
            background: rgba(128, 0, 0, 0.3) !important;
        }
        
        .winner {
            background: rgba(0, 128, 0, 0.3) !important;
            border: 2px solid var(--winner);
            font-weight: bold;
        }

		/* Toggle Switch Styles */
		.toggle-switch {
			position: relative;
			display: inline-block;
			width: 60px;
			height: 34px;
			margin-right: 10px;
		}

		.toggle-input {
			opacity: 0;
			width: 0;
			height: 0;
		}

		.toggle-label {
			position: absolute;
			cursor: pointer;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background-color: #ccc;
			transition: .4s;
			border-radius: 34px;
		}

		.toggle-label:before {
			position: absolute;
			content: "";
			height: 26px;
			width: 26px;
			left: 4px;
			bottom: 4px;
			background-color: white;
			transition: .4s;
			border-radius: 50%;
		}

		.toggle-input:checked + .toggle-label {
			background-color: var(--accent);
		}

		.toggle-input:checked + .toggle-label:before {
			transform: translateX(26px);
		}

		.toggle-text-off, .toggle-text-on {
			position: absolute;
			top: 50%;
			transform: translateY(-50%);
			font-size: 0.7rem;
			font-weight: bold;
			color: white;
		}

		.toggle-text-off {
			right: 8px;
		}

		.toggle-text-on {
			left: 8px;
			display: none;
		}

		.toggle-input:checked + .toggle-label .toggle-text-off {
			display: none;
		}

		.toggle-input:checked + .toggle-label .toggle-text-on {
			display: block;
		}

		.form-help {
			font-size: 0.8rem;
			color: #aaa;
			margin-top: 5px;
		}

		/* Place indicators */
		.place-1 {
			background: rgba(255, 215, 0, 0.3) !important; /* Gold */
			border: 2px solid gold !important;
			font-weight: bold;
		}

		.place-2 {
			background: rgba(192, 192, 192, 0.3) !important; /* Silver */
			border: 2px solid silver !important;
			font-weight: bold;
		}

		.place-3 {
			background: rgba(205, 127, 50, 0.3) !important; /* Bronze */
			border: 2px solid #cd7f32 !important;
			font-weight: bold;
		}
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
                gap: 10px;
            }
            
            .title {
                font-size: 2.5rem;
            }
            
            .subtitle {
                font-size: 1rem;
            }
            
            .pick-button {
                padding: 10px 25px;
                font-size: 1.2rem;
            }
        }
        
        /* Confetti container */
        #confetti-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            pointer-events: none;
        }
        
        /* Selection animation */
        @keyframes selectionMove {
            0% {
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                opacity: 0;
            }
        }
        
        /* Winner animation */
        @keyframes celebrate {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }
        
        .celebrate {
            animation: celebrate 0.5s ease-in-out 3;
        }
        
        /* Speed control for selection animation */
        .speed-1 .selection-indicator { transition: top 0.08s linear; }
        .speed-2 .selection-indicator { transition: top 0.06s linear; }
        .speed-3 .selection-indicator { transition: top 0.04s linear; }
        .speed-4 .selection-indicator { transition: top 0.02s linear; }
        .speed-5 .selection-indicator { transition: top 0.01s linear; }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1 class="title">Winner's List</h1>
        </header>
        
        <div class="panel">
            <h2 class="panel-title">Contestants</h2>
            <div class="name-list-container">
                <div class="selection-indicator"></div>
                <ul class="name-list" id="nameList">
                    <!-- Names will be populated here -->
                </ul>
            </div>
            <form class="add-name-form" id="addNameForm">
                <input type="text" class="name-input" id="nameInput" placeholder="Enter name..." required>
                <button type="submit" class="add-btn">Add</button>
            </form>
            
            <div class="controls-container">
                <button class="pick-button" id="pickButton">PICK</button>
                <div class="result-container">
                    <div class="result-title">Result</div>
                    <div class="winner-display" id="winnerDisplay">Click Pick to find out!</div>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <h2 class="panel-title">Settings</h2>
            <form class="settings-form" id="settingsForm">
				<div class="form-group">
					<label class="form-label">Game Mode</label>
					<select class="form-select" id="gameMode">
						<option value="first">First One Picked</option>
						<option value="last">Last One Standing</option>
						<option value="placed">Placed Winners (1st, 2nd, 3rd)</option>
					</select>
				</div>
				
				<div class="form-group" id="autoPickContainer" style="display: none;">
					<label class="form-label">Auto-Pick Mode</label>
					<div class="toggle-switch">
						<input type="checkbox" id="autoPick" class="toggle-input">
						<label for="autoPick" class="toggle-label">
							<span class="toggle-text-off">Off</span>
							<span class="toggle-text-on">On</span>
						</label>
					</div>
					<p class="form-help">When enabled, all names will be automatically picked in sequence until the game is complete.</p>
				</div>				

				<div class="form-group" id="placeOrderContainer" style="display: none;">
					<label class="form-label">Selection Order</label>
					<div class="toggle-switch">
						<input type="checkbox" id="placeOrderToggle" class="toggle-input">
						<label for="placeOrderToggle" class="toggle-label">
							<span class="toggle-text-off">1→2→3</span>
							<span class="toggle-text-on">3→2→1</span>
						</label>
					</div>
					<p class="form-help">Choose whether to select in ascending (1st, 2nd, 3rd) or descending (3rd, 2nd, 1st) order.</p>
				</div>
				
                <div class="form-group">
                    <label class="form-label">Selection Speed</label>
                    <input type="range" class="form-input" id="selectionSpeed" min="1" max="5" value="3" step="1">
                    <span id="speedValue">Medium</span>
                </div>
                <div class="form-group">
                    <label class="form-label">Selection Time (seconds)</label>
                    <input type="range" class="form-input" id="selectionDuration" min="1" max="10" value="3" step="0.5">
                    <span id="selectionDurationValue">3.0</span>
                </div>
				<div class="form-group">
					<label class="form-label">Background Music</label>
					<div class="toggle-switch">
						<input type="checkbox" id="musicToggle" class="toggle-input" checked>
						<label for="musicToggle" class="toggle-label">
							<span class="toggle-text-off">Off</span>
							<span class="toggle-text-on">On</span>
						</label>
					</div>
					<p class="form-help">Enable or disable background music</p>
				</div>

				<div class="form-group" id="musicSelectionContainer">
					<label class="form-label">Music Track</label>
					<select class="form-select" id="musicSelection">
						<option value="v1">Track 1</option>
						<option value="v2">Track 2</option>
					</select>
					<p class="form-help">Choose your background music</p>
				</div>				
                <div class="btn-group">
                    <button type="button" class="action-btn import-export-btn" id="importExportBtn">Import/Export</button>
                    <button type="button" class="action-btn reset-btn" id="resetBtn">Reset All</button>
                </div>
            </form>
            
            <div class="history-container">
                <h3 class="panel-title" style="margin-top: 20px">Results History</h3>
                <ul class="history-list" id="historyList">
                    <!-- History will be populated here -->
                </ul>
                <div class="remaining-display" id="remainingDisplay"></div>
            </div>
        </div>
    </div>
    
    <!-- Import/Export Modal -->
    <div class="modal" id="importExportModal">
        <div class="modal-content">
            <button class="close-btn" id="closeModal">&times;</button>
            <h3 class="modal-title">Import/Export Names</h3>
            <form class="modal-form" id="importExportForm">
                <p>Enter names (one per line) or copy the existing list:</p>
                <textarea class="modal-textarea" id="namesTextarea"></textarea>
                <button type="submit" class="modal-btn">Save Names</button>
            </form>
        </div>
    </div>
    
    <!-- Edit Name Modal -->
    <div class="modal" id="editNameModal">
        <div class="modal-content">
            <button class="close-btn" id="closeEditModal">&times;</button>
            <h3 class="modal-title">Edit Name</h3>
            <form class="modal-form" id="editNameForm">
                <input type="hidden" id="editNameIndex">
                <input type="text" class="modal-input" id="editNameInput" placeholder="Enter name..." required>
                <button type="submit" class="modal-btn">Update Name</button>
            </form>
        </div>
    </div>

	<!-- Audio elements for background music - MOVE THESE BEFORE THE SCRIPT TAG -->
	<audio id="music-v1" loop>
		<source src="/tools/audio/WinnerList_v1.mp3" type="audio/mpeg">
	</audio>
	<audio id="music-v2" loop>
		<source src="/tools/audio/WinnerList_v2.mp3" type="audio/mpeg">
	</audio>
    
    <!-- Confetti canvas -->
    <canvas id="confetti-canvas"></canvas>
    
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
    <script>
        // Initialize variables
        let names = [];
        let originalNames = [];
        let winHistory = [];
        let isSelecting = false;
        let nameColorAssignments = {};
        let currentSelectionIndex = 0;
        let selectionInterval = null;
		let savedSettings = {
			gameMode: 'first',
			selectionSpeed: 3,
			selectionDuration: 3,
			autoPick: false,
			reverseOrder: false,
			musicEnabled: true,
			musicTrack: 'v1'
		};

		let currentMusic = 'v1';
		let isMusicEnabled = true;

		let currentPlace = 1;  // For placed mode: 1 = 1st place, 2 = 2nd place, 3 = 3rd place
		const placeOrderContainer = document.getElementById('placeOrderContainer');
		const placeOrderToggle = document.getElementById('placeOrderToggle');

        // DOM Elements
        const nameList = document.getElementById('nameList');
        const selectionIndicator = document.querySelector('.selection-indicator');
        const pickButton = document.getElementById('pickButton');
        const addNameForm = document.getElementById('addNameForm');
        const nameInput = document.getElementById('nameInput');
        const winnerDisplay = document.getElementById('winnerDisplay');
        const historyList = document.getElementById('historyList');
        const remainingDisplay = document.getElementById('remainingDisplay');
        const importExportBtn = document.getElementById('importExportBtn');
        const resetBtn = document.getElementById('resetBtn');
        const importExportModal = document.getElementById('importExportModal');
        const closeModal = document.getElementById('closeModal');
        const namesTextarea = document.getElementById('namesTextarea');
        const importExportForm = document.getElementById('importExportForm');
        const editNameModal = document.getElementById('editNameModal');
        const closeEditModal = document.getElementById('closeEditModal');
        const editNameForm = document.getElementById('editNameForm');
        const editNameInput = document.getElementById('editNameInput');
        const editNameIndex = document.getElementById('editNameIndex');
        const gameMode = document.getElementById('gameMode');
        const selectionSpeed = document.getElementById('selectionSpeed');
        const speedValue = document.getElementById('speedValue');
        const selectionDuration = document.getElementById('selectionDuration');
        const selectionDurationValue = document.getElementById('selectionDurationValue');
		const autoPickContainer = document.getElementById('autoPickContainer');
		const autoPick = document.getElementById('autoPick');        

		const musicToggle = document.getElementById('musicToggle');
		const musicSelection = document.getElementById('musicSelection');
		const musicV1 = document.getElementById('music-v1');
		const musicV2 = document.getElementById('music-v2');
		
        // Colors for name items
        const colors = [
            '#FF5252', '#FF4081', '#E040FB', '#7C4DFF', 
            '#536DFE', '#448AFF', '#40C4FF', '#18FFFF', 
            '#64FFDA', '#69F0AE', '#B2FF59', '#EEFF41', 
            '#FFFF00', '#FFD740', '#FFAB40', '#FF6E40'
        ];
        
        // Initialize the app
        function init() {
            // Load saved names from localStorage
            loadNames();
            
			// Load saved settings
			loadSettings();			
			
            // Add event listeners			
			autoPick.addEventListener('change', function() {
				saveSettings();
			});

			placeOrderToggle.addEventListener('change', function() {
				saveSettings();
			});

            addNameForm.addEventListener('submit', addName);
            pickButton.addEventListener('click', startSelection);
            importExportBtn.addEventListener('click', openImportExportModal);
            closeModal.addEventListener('click', closeImportExportModal);
            importExportForm.addEventListener('submit', saveImportedNames);
            resetBtn.addEventListener('click', resetAll);
            closeEditModal.addEventListener('click', closeEditNameModal);
            editNameForm.addEventListener('submit', updateName);
            gameMode.addEventListener('change', handleGameModeChange);
            selectionSpeed.addEventListener('input', updateSpeedDisplay);
            selectionDuration.addEventListener('input', updateSelectionDurationDisplay);
			musicToggle.addEventListener('change', toggleMusic);
			musicSelection.addEventListener('change', changeMusic);
            
            // Initialize the selection container
            document.querySelector('.name-list-container').classList.add(`speed-${selectionSpeed.value}`);
            
            // Update the display initially
            updateRemainingDisplay();
			
			initMusic();
        }

		// Initialize music
		function initMusic() {
			// Set initial volume
			musicV1.volume = 0.5;
			musicV2.volume = 0.5;
			
			// Update UI to match settings
			musicToggle.checked = savedSettings.musicEnabled;
			musicSelection.value = savedSettings.musicTrack;
			
			// Add a one-time click handler to the document to enable audio
			document.addEventListener('click', function enableAudio() {
				if (savedSettings.musicEnabled) {
					playMusic(savedSettings.musicTrack);
				}
				// Remove this listener after first click
				document.removeEventListener('click', enableAudio);
			}, { once: true });
		}

		// Play selected music
		function playMusic(track) {
			// Stop all tracks first
			musicV1.pause();
			musicV2.pause();
			
			// Play the selected track if music is enabled
			if (savedSettings.musicEnabled) {
				if (track === 'v1') {
					musicV1.currentTime = 0;
					musicV1.play().catch(e => console.log('Music playback failed:', e));
				} else {
					musicV2.currentTime = 0;
					musicV2.play().catch(e => console.log('Music playback failed:', e));
				}
			}
			
			// Update current track
			currentMusic = track;
		}

		// Toggle music on/off
		function toggleMusic() {
			savedSettings.musicEnabled = musicToggle.checked;
			
			if (savedSettings.musicEnabled) {
				playMusic(currentMusic);
			} else {
				musicV1.pause();
				musicV2.pause();
			}
			
			saveSettings();
		}

		// Change music track
		function changeMusic() {
			savedSettings.musicTrack = musicSelection.value;
			playMusic(musicSelection.value);
			saveSettings();
		}

		// Add function to load settings
		function loadSettings() {
			const savedSettingsStr = localStorage.getItem('winnerListSettings');
			if (savedSettingsStr) {
				savedSettings = JSON.parse(savedSettingsStr);
				
				// Apply loaded settings to form elements
				gameMode.value = savedSettings.gameMode;
				selectionSpeed.value = savedSettings.selectionSpeed;
				selectionDuration.value = savedSettings.selectionDuration;
				
				// Set auto-pick checkbox
				autoPick.checked = savedSettings.autoPick || false;
				
				// Set place order toggle
				placeOrderToggle.checked = savedSettings.reverseOrder || false;
				
				// Music settings (add these lines)
				musicToggle.checked = savedSettings.musicEnabled !== false; // Default to true if not set
				musicSelection.value = savedSettings.musicTrack || 'v1'; // Default to v1 if not set
				
				// Show/hide option containers based on game mode
				toggleOptionVisibility();
				
				// Update display values
				updateSpeedDisplay();
				updateSelectionDurationDisplay();
			}
		}

		// Add function to save settings
		function saveSettings() {
			// Update saved settings object
			savedSettings.gameMode = gameMode.value;
			savedSettings.selectionSpeed = selectionSpeed.value;
			savedSettings.selectionDuration = selectionDuration.value;
			savedSettings.autoPick = autoPick.checked;
			savedSettings.reverseOrder = placeOrderToggle.checked;
			savedSettings.musicEnabled = musicToggle.checked;
			savedSettings.musicTrack = musicSelection.value;
			
			// Save to localStorage
			localStorage.setItem('winnerListSettings', JSON.stringify(savedSettings));
		}

		function toggleOptionVisibility() {
			// Show/hide auto-pick for Last Man Standing mode
			if (gameMode.value === 'last') {
				autoPickContainer.style.display = 'block';
				placeOrderContainer.style.display = 'none';
			} 
			// Show/hide place order toggle for Placed Winners mode
			else if (gameMode.value === 'placed') {
				autoPickContainer.style.display = 'none';
				placeOrderContainer.style.display = 'block';
			}
			else {
				autoPickContainer.style.display = 'none';
				placeOrderContainer.style.display = 'none';
			}
		}
        
        // Load names from localStorage
        function loadNames() {
            const savedNames = localStorage.getItem('winnerListNames');
            names = savedNames ? JSON.parse(savedNames) : [];
            originalNames = [...names];
            
            // Load saved color assignments
            const savedColorAssignments = localStorage.getItem('winnerListColorAssignments');
            nameColorAssignments = savedColorAssignments ? JSON.parse(savedColorAssignments) : {};
            
            // Assign colors to names that don't have one yet
            names.forEach(name => assignColorToName(name));
            
            updateNameList();
        }
        
        // Save names to localStorage
        function saveNames() {
            localStorage.setItem('winnerListNames', JSON.stringify(names));
            localStorage.setItem('winnerListColorAssignments', JSON.stringify(nameColorAssignments));
            originalNames = [...names];
        }
        
        // Add a new name
        function addName(e) {
            e.preventDefault();
            const name = nameInput.value.trim();
            
            if (name && !names.includes(name)) {
                // Assign color FIRST before adding the name
                assignColorToName(name);
                
                names.push(name);
                saveNames();
                updateNameList();
                nameInput.value = '';
            } else if (names.includes(name)) {
                alert('This name already exists!');
            }
        }
        
        // Deterministically assign a color to a name
        function assignColorToName(name) {
            // If the name doesn't have a color yet, assign one
            if (!nameColorAssignments[name]) {
                // Use the name's string value to deterministically assign a color index
                let nameHash = 0;
                for (let i = 0; i < name.length; i++) {
                    nameHash = ((nameHash << 5) - nameHash) + name.charCodeAt(i);
                    nameHash = nameHash & nameHash; // Convert to 32bit integer
                }
                const colorIndex = Math.abs(nameHash) % colors.length;
                nameColorAssignments[name] = colors[colorIndex];
            }
            return nameColorAssignments[name];
        }

		function handlePlacedWinners(selectedName, index) {
			let placeText;
			let placeOrdinal;
			
			// Determine which place we're selecting based on the order toggle
			if (placeOrderToggle.checked) {
				// Reverse order (3→2→1)
				placeOrdinal = 4 - currentPlace;
				placeText = getOrdinalText(placeOrdinal);
			} else {
				// Normal order (1→2→3)
				placeOrdinal = currentPlace;
				placeText = getOrdinalText(placeOrdinal);
			}
			
			// Display the winner
			winnerDisplay.textContent = `${selectedName} - ${placeText} PLACE!`;
			
			// Set appropriate text color based on place
			if (placeOrdinal === 1) {
				winnerDisplay.style.color = 'gold';
				winnerDisplay.classList.add('celebrate');
			} else if (placeOrdinal === 2) {
				winnerDisplay.style.color = 'silver';
			} else {
				winnerDisplay.style.color = '#cd7f32'; // bronze
			}
			
			// Highlight the winner in the list with the appropriate place
			const items = nameList.querySelectorAll('.name-item');
			items[index].classList.add(`place-${placeOrdinal}`);
			
			// Add to history - modified to handle different ordering for 1→2→3 mode
			if (!placeOrderToggle.checked) {
				// For 1→2→3 mode, add at the end if this is a new round (first 3 selections)
				if (winHistory.length < 3 || (winHistory.length > 0 && winHistory[0].includes("COMPLETE"))) {
					winHistory.push(`${selectedName} (${placeText} Place)`);
				} else {
					// Otherwise use the default behavior
					winHistory.unshift(`${selectedName} (${placeText} Place)`);
				}
			} else {
				// For 3→2→1 mode use the original behavior
				winHistory.unshift(`${selectedName} (${placeText} Place)`);
			}
			updateHistoryList();
			
			// Remove this winner from the list for subsequent place selections
			names.splice(index, 1);
			
			// Move to the next place
			currentPlace++;
			
			// Check if we've selected all three places
			if (currentPlace > 3 || names.length === 0) {
				// Finished selecting all places or ran out of names
				setTimeout(() => {
					// Add a "FINISHED!" message to history
					if (!placeOrderToggle.checked && (winHistory.length <= 3 || (winHistory.length > 0 && winHistory[winHistory.length-1].includes("Place")))) {
						// For 1→2→3 mode, add at the end
						winHistory.push("★ PLACED SELECTION COMPLETE ★");
					} else {
						// For 3→2→1 mode add at the beginning
						winHistory.unshift("★ PLACED SELECTION COMPLETE ★");
					}
					updateHistoryList();
					
					// Show completion announcement
					showPlacedCompletionAnnouncement();
					
					// Reset for a new round
					currentPlace = 1;
				}, 1000);
			} else {
				// Update the list for the next place selection
				setTimeout(() => {
					updateNameList();
					
					// Re-enable the pick button for the next place
					isSelecting = false;
					pickButton.disabled = false;
					
					// If using auto-pick, automatically select the next place
					if (autoPick.checked && names.length > 0) {
						setTimeout(() => {
							startSelection();
						}, 1000);
					}
				}, 1000);
			}
			
			// Remove celebration class after animation completes
			if (placeOrdinal === 1) {
				setTimeout(() => {
					winnerDisplay.classList.remove('celebrate');
				}, 1500);
			}
		}

		function getOrdinalText(place) {
			switch(place) {
				case 1: return '1st';
				case 2: return '2nd';
				case 3: return '3rd';
				default: return `${place}th`;
			}
		}

		function showPlacedCompletionAnnouncement() {

			// Create a modal for announcing the winners
			const completionModal = document.createElement('div');
			completionModal.className = 'modal winner-announcement';
			completionModal.style.display = 'flex';
			completionModal.style.zIndex = '2000';
			
			// Create the modal content with wider dimensions
			const modalContent = document.createElement('div');
			modalContent.className = 'modal-content winner-modal';
			modalContent.style.textAlign = 'center';
			modalContent.style.padding = '40px';
			modalContent.style.background = 'linear-gradient(145deg, #212121, #333333)';
			modalContent.style.boxShadow = '0 0 30px rgba(255, 235, 59, 0.5)';
			modalContent.style.width = '80%';
			modalContent.style.maxWidth = '800px';
			
			// Title
			const title = document.createElement('h2');
			title.className = 'modal-title';
			title.style.fontSize = '3rem';
			title.style.marginBottom = '30px';
			title.style.color = 'var(--secondary)';
			title.style.textShadow = '0 0 10px var(--secondary)';
			title.textContent = 'WINNERS ANNOUNCED!';
			
			// Winners container
			const winnersContainer = document.createElement('div');
			winnersContainer.style.margin = '20px 0';
			
			// Get the winners from history
			const winners = [];
			for (let i = 0; i < winHistory.length; i++) {
				if (winHistory[i].includes('Place')) {
					winners.push(winHistory[i]);
					if (winners.length >= 3) break;
				}
			}
			
			// Sort winners by place
			winners.sort((a, b) => {
				const aPlace = parseInt(a.match(/(\d+)st|(\d+)nd|(\d+)rd|(\d+)th/)[0]);
				const bPlace = parseInt(b.match(/(\d+)st|(\d+)nd|(\d+)rd|(\d+)th/)[0]);
				return aPlace - bPlace;
			});
			
			// Add each winner to the container
			winners.forEach((winner, index) => {
				const place = index + 1;
				const name = winner.split(' (')[0];
				
				const winnerDiv = document.createElement('div');
				winnerDiv.style.padding = '15px';
				winnerDiv.style.margin = '10px 0';
				winnerDiv.style.borderRadius = '10px';
				winnerDiv.style.background = 'rgba(0, 0, 0, 0.3)';
				
				// Style based on place
				let medal, color;
				if (place === 1) {
					medal = '🥇';
					color = 'gold';
					winnerDiv.style.animation = 'celebrate 0.5s ease-in-out infinite alternate';
				} else if (place === 2) {
					medal = '🥈';
					color = 'silver';
				} else {
					medal = '🥉';
					color = '#cd7f32'; // bronze
				}
				
				winnerDiv.innerHTML = `<span style="font-size: 2rem; color: ${color};">${medal} ${getOrdinalText(place)} Place: ${name}</span>`;
				winnersContainer.appendChild(winnerDiv);
			});
			
			// Add a button to start a new round
			const newRoundBtn = document.createElement('button');
			newRoundBtn.className = 'action-btn';
			newRoundBtn.style.padding = '15px 40px';
			newRoundBtn.style.fontSize = '1.5rem';
			newRoundBtn.style.background = 'linear-gradient(145deg, var(--primary), #ff0000)';
			newRoundBtn.style.color = 'white';
			newRoundBtn.style.border = 'none';
			newRoundBtn.style.borderRadius = '30px';
			newRoundBtn.style.cursor = 'pointer';
			newRoundBtn.style.transition = 'all 0.3s';
			newRoundBtn.style.boxShadow = '0 5px 15px rgba(255, 0, 0, 0.3)';
			newRoundBtn.style.fontWeight = 'bold';
			newRoundBtn.style.margin = '20px auto 0';
			newRoundBtn.style.display = 'block';
			newRoundBtn.textContent = 'START NEW ROUND';
			
			// Add button event listener
			newRoundBtn.addEventListener('click', function() {
				newRoundBtn.disabled = true;
				document.body.removeChild(completionModal);
				
				// Reset for new round
				resetToOriginalNames();
				winHistory = [];
				updateHistoryList();
				
				// Reset currentPlace
				currentPlace = 1;
				
				// Reset the winner display
				winnerDisplay.textContent = 'Click Pick to find out!';
				winnerDisplay.style.color = 'var(--primary)';
				
				// Clear any place selection text again
				clearPlaceSelectionText();
				
				// Re-enable the pick button
				isSelecting = false;
				pickButton.disabled = false;
			});
			
			// Build the modal
			modalContent.appendChild(title);
			modalContent.appendChild(winnersContainer);
			modalContent.appendChild(newRoundBtn);
			completionModal.appendChild(modalContent);
			
			// Add to body
			document.body.appendChild(completionModal);
			
			// Launch confetti for the winners
			confetti({
				particleCount: 200,
				spread: 90,
				origin: { y: 0.4 },
				disableForReducedMotion: true
			});
		}
        
        // Edit a name
        function editName(index) {
            editNameIndex.value = index;
            editNameInput.value = names[index];
            editNameModal.style.display = 'flex';
        }
        
        // Update a name
        function updateName(e) {
            e.preventDefault();
            const index = parseInt(editNameIndex.value);
            const oldName = names[index];
            const newName = editNameInput.value.trim();
            
            if (newName && !names.includes(newName)) {
                // Preserve the color assignment
                nameColorAssignments[newName] = nameColorAssignments[oldName];
                delete nameColorAssignments[oldName]; // Remove the old name's color
                
                names[index] = newName;
                saveNames();
                updateNameList();
                closeEditNameModal();
            } else if (names.includes(newName) && names[index] !== newName) {
                alert('This name already exists!');
            } else {
                closeEditNameModal();
            }
        }
        
        // Close the edit name modal
        function closeEditNameModal() {
            editNameModal.style.display = 'none';
        }
        
        // Delete a name
        function deleteName(index) {
            const nameToDelete = names[index];
            
            // Remove the color assignment when completely deleting from game
            delete nameColorAssignments[nameToDelete];
            
            names.splice(index, 1);
            saveNames();
            updateNameList();
        }
        
        // Update the name list UI
        function updateNameList() {
            nameList.innerHTML = '';
            
            names.forEach((name, index) => {
                const li = document.createElement('li');
                li.className = 'name-item';
                li.setAttribute('data-index', index);
                
                // Use the stored color assignment for background
                li.style.backgroundColor = nameColorAssignments[name];
                li.style.color = 'white';
                li.style.textShadow = '1px 1px 2px black';
                
                const nameText = document.createElement('span');
                nameText.className = 'name-text';
                nameText.style.overflow = 'hidden';
                nameText.style.textOverflow = 'ellipsis';
                nameText.style.whiteSpace = 'nowrap';
                nameText.style.maxWidth = 'calc(100% - 110px)';
                nameText.textContent = name;
                nameText.title = name;
                
                const editBtn = document.createElement('button');
                editBtn.className = 'edit-btn';
                editBtn.textContent = 'Edit';
                editBtn.addEventListener('click', () => editName(index));
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.textContent = 'Delete';
                deleteBtn.addEventListener('click', () => deleteName(index));
                
                li.appendChild(nameText);
                li.appendChild(editBtn);
                li.appendChild(deleteBtn);
                
                nameList.appendChild(li);
            });
            
            // Update selection indicator height based on list item height
            if (names.length > 0) {
                const firstItem = nameList.querySelector('.name-item');
                if (firstItem) {
                    const itemHeight = firstItem.offsetHeight;
                    selectionIndicator.style.height = `${itemHeight}px`;
                }
            }
            
            updateRemainingDisplay();
        }
        
        // Start the selection animation
		function startSelection() {
			// If already selecting or there are no names, do nothing
			if (isSelecting || names.length === 0) return;
			
			// If only one name remains, do absolutely nothing when PICK is clicked
			if (names.length === 1) return;
			
			// Only continue if we have multiple names
			isSelecting = true;
			pickButton.disabled = true;
			
			// Reset any previous selections
			resetSelectionStates();
			
			// Activate selection mode
			document.querySelector('.name-list-container').classList.add('selection-active');
			
			// Start with a random position
			currentSelectionIndex = Math.floor(Math.random() * names.length);
			
			// Calculate selection parameters
			const speed = 6 - parseInt(selectionSpeed.value); // Invert so higher = faster
			const duration = parseFloat(selectionDuration.value) * 1000; // Convert to milliseconds
			
			// Start the selection animation
			moveSelectionIndicator();
			
			// Set interval to move the indicator
			selectionInterval = setInterval(moveSelectionIndicator, speed * 25);
			
			// Schedule end of selection
			setTimeout(finishSelection, duration);
		}
        
        // Move the selection indicator
        function moveSelectionIndicator() {
            // Clear previous selection
            const items = nameList.querySelectorAll('.name-item');
            items.forEach(item => item.classList.remove('selected'));
            
            // Move to next index (loop around if needed)
            currentSelectionIndex = (currentSelectionIndex + 1) % names.length;
            
            // Get the current item
            const currentItem = items[currentSelectionIndex];
            
            if (currentItem) {
                // Calculate position and move indicator
                const topPosition = currentItem.offsetTop;
                selectionIndicator.style.top = `${topPosition}px`;
                
                // Add selected class to current item
                currentItem.classList.add('selected');
            }
        }
        
        // Finish the selection process
		function finishSelection() {
			// Clear the selection interval
			clearInterval(selectionInterval);
			
			// Get the selected name
			const selectedName = names[currentSelectionIndex];
			
			// Stop the animation
			document.querySelector('.name-list-container').classList.remove('selection-active');
			
			// Handle the selection based on game mode
			if (gameMode.value === 'first') {
				handleFirstOnePicked(selectedName, currentSelectionIndex);
				
				// Reset state
				isSelecting = false;
				pickButton.disabled = false;
			} else if (gameMode.value === 'last') {
				handleLastManStanding(selectedName, currentSelectionIndex);
				
				// Check if we should continue automatically
				if (autoPick.checked && names.length > 1) {
					// Reset state for the next pick
					isSelecting = false;
					
					// Wait a moment before picking the next name
					setTimeout(() => {
						// Only continue if there are at least 2 names left
						if (names.length > 1) {
							startSelection();
						}
					}, 2000); // 2 second delay between picks
				} else {
					// Reset state if not auto-picking or no more names
					isSelecting = false;
					pickButton.disabled = false;
				}
			} else if (gameMode.value === 'placed') {
				handlePlacedWinners(selectedName, currentSelectionIndex);
			}
		}
        
        // Handle first one picked mode
		function handleFirstOnePicked(selectedName, index) {
			// Display the winner
			winnerDisplay.textContent = selectedName;
			winnerDisplay.style.color = 'var(--winner)';
			winnerDisplay.classList.add('celebrate');
			
			// Highlight the winner in the list
			const items = nameList.querySelectorAll('.name-item');
			items[index].classList.add('winner');
			
			// Add to history
			winHistory.unshift(`${selectedName} (WINNER!)`);
			updateHistoryList();
			
			// Remove celebration class after animation completes
			setTimeout(() => {
				winnerDisplay.classList.remove('celebrate');
				
				// Show the winner announcement modal
				showWinnerAnnouncement(selectedName, false);
			}, 1500);
		}

        
        // Handle last man standing mode
		function handleLastManStanding(selectedName, index) {
			// Show who's been eliminated
			winnerDisplay.textContent = `${selectedName} ELIMINATED!`;
			winnerDisplay.style.color = 'var(--eliminated)';
			
			// Add to history as an elimination
			winHistory.unshift(`${selectedName} (Eliminated)`);
			updateHistoryList();
			
			// Mark as eliminated in the list
			const items = nameList.querySelectorAll('.name-item');
			items[index].classList.add('eliminated');
			
			// Remove the eliminated person
			names.splice(index, 1);
			
			// Check if only one person remains
			if (names.length <= 1) {
				// Disable the pick button to prevent further selections
				pickButton.disabled = true;
				
				// Update the list after a short delay
				setTimeout(() => {
					updateNameList();
					
					if (names.length === 1) {
						const finalWinner = names[0];
						
						// Highlight the final winner
						const updatedItems = nameList.querySelectorAll('.name-item');
						updatedItems[0].classList.add('winner');
						
						// Announce the final winner
						winnerDisplay.textContent = `${finalWinner} WINS!`;
						winnerDisplay.style.color = 'var(--winner)';
						winnerDisplay.classList.add('celebrate');
						
						// Add the winner to history
						winHistory.unshift(`${finalWinner} (WINNER!)`);
						updateHistoryList();
						
						// Show the game over announcement after a delay
						setTimeout(() => {
							showWinnerAnnouncement(finalWinner, true);
						}, 1500);
					} else {
						// No contestants left
						setTimeout(() => {
							showWinnerAnnouncement("EVERYONE", true);
						}, 1000);
					}
				}, 1000);
			} else {
				// Normal elimination for non-final rounds
				setTimeout(() => {
					updateNameList();
					
					// If not auto-picking, re-enable the pick button
					if (!autoPick.checked) {
						isSelecting = false;
						pickButton.disabled = false;
					}
					// If auto-picking, the button stays disabled until game over
				}, 1000);
			}
		}
		
		// Improved winner announcement modal with better sizing for long names
		function showWinnerAnnouncement(winnerName, isGameOver = false) {

			// Don't show announcement modal when auto-picking until the game is over
			if (autoPick.checked && gameMode.value === 'last' && !isGameOver) {
				return;
			}
			// Create a modal for announcing the winner
			const winnerModal = document.createElement('div');
			winnerModal.className = 'modal winner-announcement';
			winnerModal.style.display = 'flex';
			winnerModal.style.zIndex = '2000';
			
			// Create the modal content with wider dimensions
			const modalContent = document.createElement('div');
			modalContent.className = 'modal-content winner-modal';
			modalContent.style.textAlign = 'center';
			modalContent.style.padding = '40px';
			modalContent.style.background = 'linear-gradient(145deg, #212121, #333333)';
			modalContent.style.boxShadow = '0 0 30px rgba(255, 235, 59, 0.5)';
			modalContent.style.width = '80%'; // Wider modal (80% of screen)
			modalContent.style.maxWidth = '800px'; // Maximum width
			
			// Winner title
			const winnerTitle = document.createElement('h2');
			winnerTitle.className = 'modal-title';
			winnerTitle.style.fontSize = '3rem';
			winnerTitle.style.marginBottom = '30px';
			winnerTitle.style.color = 'var(--secondary)';
			winnerTitle.style.textShadow = '0 0 10px var(--secondary)';
			winnerTitle.textContent = isGameOver ? 'GAME OVER!' : 'ROUND COMPLETE!';
			
			// Winner name container with responsive text
			const winnerNameContainer = document.createElement('div');
			winnerNameContainer.style.margin = '20px 0';
			winnerNameContainer.style.padding = '20px';
			winnerNameContainer.style.background = 'rgba(0, 0, 0, 0.3)';
			winnerNameContainer.style.borderRadius = '10px';
			winnerNameContainer.style.overflow = 'hidden';
			winnerNameContainer.style.display = 'flex';
			winnerNameContainer.style.justifyContent = 'center';
			winnerNameContainer.style.alignItems = 'center';
			winnerNameContainer.style.minHeight = '120px';
			winnerNameContainer.style.animation = 'celebrate 0.5s ease-in-out infinite alternate';
			
			// Winner name with auto-sizing text
			const winnerName_el = document.createElement('div');
			winnerName_el.textContent = winnerName;
			winnerName_el.style.color = 'var(--winner)';
			winnerName_el.style.fontWeight = 'bold';
			winnerName_el.style.wordBreak = 'break-word';
			winnerName_el.style.lineHeight = '1.2';
			
			// Dynamically size the text based on name length
			if (winnerName.length > 20) {
				winnerName_el.style.fontSize = '3rem';
			} else if (winnerName.length > 15) {
				winnerName_el.style.fontSize = '3.5rem';
			} else if (winnerName.length > 10) {
				winnerName_el.style.fontSize = '4rem';
			} else {
				winnerName_el.style.fontSize = '4.5rem';
			}
			
			winnerNameContainer.appendChild(winnerName_el);
			
			// Winner message
			const winnerMessage = document.createElement('p');
			winnerMessage.style.fontSize = '1.5rem';
			winnerMessage.style.margin = '20px 0 40px';
			winnerMessage.style.color = 'white';
			winnerMessage.textContent = isGameOver ? 'is the last one standing!' : 'is the winner of this round!';
			
			// New round button
			const newRoundBtn = document.createElement('button');
			newRoundBtn.className = 'action-btn';
			newRoundBtn.style.padding = '15px 40px';
			newRoundBtn.style.fontSize = '1.5rem';
			newRoundBtn.style.background = 'linear-gradient(145deg, var(--primary), #ff0000)';
			newRoundBtn.style.color = 'white';
			newRoundBtn.style.border = 'none';
			newRoundBtn.style.borderRadius = '30px';
			newRoundBtn.style.cursor = 'pointer';
			newRoundBtn.style.transition = 'all 0.3s';
			newRoundBtn.style.boxShadow = '0 5px 15px rgba(255, 0, 0, 0.3)';
			newRoundBtn.style.fontWeight = 'bold';
			newRoundBtn.style.margin = '0 auto';
			newRoundBtn.style.display = 'block';
			newRoundBtn.textContent = isGameOver ? 'START NEW GAME' : 'START NEW ROUND';
			
			// Add a single-click handler to the button
			newRoundBtn.addEventListener('click', function() {
				// Prevent multiple clicks
				newRoundBtn.disabled = true;
				
				// Remove the modal
				document.body.removeChild(winnerModal);
				
				// Clear history for new round
				winHistory = [];
				updateHistoryList();
				
				// Reset the winner display
				winnerDisplay.textContent = 'Click Pick to find out!';
				winnerDisplay.style.color = 'var(--primary)';
				
				currentPlace = 1;
				
				// If game over, reset names too
				if (isGameOver) {
					resetToOriginalNames();
				} else {
					// If not game over (just a round), reset visual states
					resetAllVisualStates();
				}
				
				updateRemainingDisplay();
				
				// Re-enable the pick button
				isSelecting = false;
				pickButton.disabled = false;
			});
			
			// Build the modal
			modalContent.appendChild(winnerTitle);
			modalContent.appendChild(winnerNameContainer);
			modalContent.appendChild(winnerMessage);
			modalContent.appendChild(newRoundBtn);
			winnerModal.appendChild(modalContent);
			
			// Add to body
			document.body.appendChild(winnerModal);
			
			// Launch confetti for the winner
			confetti({
				particleCount: 200,
				spread: 90,
				origin: { y: 0.4 },
				disableForReducedMotion: true
			});			

		}

		function resetAllVisualStates() {
			// Reset all name items to their original state
			const items = nameList.querySelectorAll('.name-item');
			items.forEach((item, index) => {
				// Remove any special classes
				item.classList.remove('selected');
				item.classList.remove('winner');
				item.classList.remove('eliminated');
				item.classList.remove('place-1');
				item.classList.remove('place-2');
				item.classList.remove('place-3');
				
				// Reset background color to the assigned color
				const name = names[index];
				item.style.backgroundColor = nameColorAssignments[name];
			});
		}
        
        // Reset selection states
        function resetSelectionStates() {
            const items = nameList.querySelectorAll('.name-item');
            items.forEach(item => {
                item.classList.remove('selected');
                item.classList.remove('winner');
            });
        }
        
        // Reset to original names
		function resetToOriginalNames() {
			names = [...originalNames];
			
			// Reset currentPlace
			currentPlace = 1;
			
			updateNameList();
			resetAllVisualStates(); // Make sure this is called
			
			// Reset displays
			winnerDisplay.style.color = 'var(--primary)';
			winnerDisplay.textContent = 'Click Pick to find out!';
			
			// Update remaining display to clear any place selection text
			updateRemainingDisplay();
		}

		function clearPlaceSelectionText() {
			// Directly clear the remaining display text
			remainingDisplay.innerHTML = '';
			remainingDisplay.style.display = 'none';
		}

        // Handle game mode change
		function handleGameModeChange() {
			if (gameMode.value === 'first') {
				// Restore original names if switching from another mode
				resetToOriginalNames();
			} else if (gameMode.value === 'last') {
				// Reset history when starting last man standing
				winHistory = [];
				updateHistoryList();
			} else if (gameMode.value === 'placed') {
				// Reset for placed mode
				resetToOriginalNames();
				winHistory = [];
				updateHistoryList();
			}
			
			// Reset currentPlace when changing modes
			currentPlace = 1;
			
			// Toggle option visibility
			toggleOptionVisibility();
			
			updateRemainingDisplay();
			saveSettings(); // Save settings after change
		}
        
        // Update history list
		function updateHistoryList() {
			historyList.innerHTML = '';
			
			// Add each history item to the list (show up to 10 most recent)
			const historyToShow = winHistory.slice(0, 10);
			
			historyToShow.forEach((item) => {
				const li = document.createElement('li');
				li.className = 'history-item';
				
				// Check if this is a winner or eliminated entry
				if (item.includes('WINNER') || item.includes('WIN')) {
					li.innerHTML = `<span style="color: var(--winner)">${item}</span>`;
				} else if (item.includes('Eliminated')) {
					li.innerHTML = `<span style="color: var(--eliminated)">${item}</span>`;
				} else {
					li.innerHTML = `<span>${item}</span>`;
				}
				
				historyList.appendChild(li);
			});
		}
        
        // Update remaining display based on game mode
		function updateRemainingDisplay() {
			if (gameMode.value === 'last') {
				if (names.length > 0) {
					remainingDisplay.innerHTML = `<strong>Remaining:</strong> ${names.length} contestants`;
					remainingDisplay.style.display = 'block';
				} else {
					remainingDisplay.innerHTML = '';
					remainingDisplay.style.display = 'none';
				}
			} else {
				// For 'first' mode and 'placed' mode, don't show anything in remaining display
				remainingDisplay.innerHTML = '';
				remainingDisplay.style.display = 'none';
			}
		}
        
        // Update the speed display
		function updateSpeedDisplay() {
			const speedLabels = ['Very Slow', 'Slow', 'Medium', 'Fast', 'Very Fast'];
			speedValue.textContent = speedLabels[parseInt(selectionSpeed.value) - 1];
			
			// Update speed class on container
			const container = document.querySelector('.name-list-container');
			container.className = 'name-list-container';
			container.classList.add(`speed-${selectionSpeed.value}`);
			if (isSelecting) {
				container.classList.add('selection-active');
			}
			
			saveSettings(); // Save settings after change
		}
        
        // Update selection duration display
		function updateSelectionDurationDisplay() {
			selectionDurationValue.textContent = selectionDuration.value;
			saveSettings(); // Save settings after change
		}
        
        // Open the import/export modal
        function openImportExportModal() {
            namesTextarea.value = names.join('\n');
            importExportModal.style.display = 'flex';
        }
        
        // Close the import/export modal
        function closeImportExportModal() {
            importExportModal.style.display = 'none';
        }
        
        // Save imported names
        function saveImportedNames(e) {
            e.preventDefault();
            const importedText = namesTextarea.value.trim();
            
            if (importedText) {
                // Split by new lines and filter empty lines
                const newNames = importedText
                    .split('\n')
                    .map(name => name.trim())
                    .filter(name => name.length > 0);
                
                // Deduplicate names
                const uniqueNames = [...new Set(newNames)];
                
                names = uniqueNames;
                
                // Assign colors to new names
                names.forEach(name => assignColorToName(name));
                
                saveNames();
                updateNameList();
            }
            
            closeImportExportModal();
        }
        
        // Reset all data
		function resetAll() {
			if (confirm('Are you sure you want to reset all data? This cannot be undone.')) {
				names = [];
				originalNames = [];
				winHistory = [];
				nameColorAssignments = {}; // Clear color assignments
				currentPlace = 1; // Reset currentPlace
				
				// Save the reset state
				localStorage.removeItem('winnerListNames');
				localStorage.removeItem('winnerListColorAssignments');
				localStorage.removeItem('winnerListSettings'); // Also clear settings
				
				// Reset to default settings
				gameMode.value = 'first';
				selectionSpeed.value = 3;
				selectionDuration.value = 3;
				
				// Reset music settings
				musicToggle.checked = true;
				musicSelection.value = 'v1';
				savedSettings.musicEnabled = true;
				savedSettings.musicTrack = 'v1';
				playMusic('v1');
				
				updateSpeedDisplay();
				updateSelectionDurationDisplay();
				
				updateNameList();
				winnerDisplay.textContent = 'Click Pick to find out!';
				winnerDisplay.style.color = 'var(--primary)';
				
				updateRemainingDisplay();
			}
		}
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', init);
    </script>
	
</body>
</html>
